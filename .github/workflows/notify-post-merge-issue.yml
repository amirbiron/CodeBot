name: Notify on post-merge test failures (Issues)

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types: [completed]
  workflow_dispatch:
    inputs:
      action:
        description: "open or close a TEST issue notification"
        required: false
        default: "open"

permissions:
  contents: read
  actions: read
  issues: write

jobs:
  open-issue-on-failure:
    name: Open issue and mention on failure
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_run' &&
      github.event.workflow_run.event == 'push' &&
      github.event.workflow_run.head_branch == 'main' &&
      github.event.workflow_run.conclusion != 'success'
    steps:
      - name: Create/Update failure issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const run = context.payload.workflow_run;
            const { owner, repo } = context.repo;

            const shortSha = run.head_sha.slice(0, 7);
            const title = `Post-merge failure: ${run.name} on main @ ${shortSha}`;

            // Fetch commit message (first line) for context
            let commitMessage = '';
            try {
              const commit = await github.rest.repos.getCommit({ owner, repo, ref: run.head_sha });
              commitMessage = (commit.data.commit.message || '').split('\n')[0];
            } catch (e) {
              commitMessage = '';
            }

            // List failed jobs with links
            let failedJobsText = '';
            try {
              const jobs = await github.rest.actions.listJobsForWorkflowRun({ owner, repo, run_id: run.id, per_page: 100 });
              const failed = jobs.data.jobs.filter(j => (j.conclusion || 'unknown') !== 'success');
              if (failed.length > 0) {
                failedJobsText = failed.map(j => `- ${j.name}: ${j.html_url}`).join('\n');
              }
            } catch (e) {
              // ignore
            }

            const bodyLines = [
              `@amirbiron ğŸš¨ ×‘×“×™×§×•×ª post-merge × ×›×©×œ×•.`,
              `Workflow: ${run.name}`,
              `Branch: ${run.head_branch}`,
              `Commit: ${shortSha}${commitMessage ? ` â€” ${commitMessage}` : ''}`,
              `[×§×™×©×•×¨ ×œ×”×¨×¦×”](${run.html_url})`,
              failedJobsText ? '\nJobs ×©× ×›×©×œ×•:\n' + failedJobsText : ''
            ].filter(Boolean);
            const body = bodyLines.join('\n');

            // Try to find an existing open issue with the same title
            const existing = await github.paginate(github.rest.issues.listForRepo, {
              owner, repo, state: 'open', per_page: 100
            });
            const dup = existing.find(i => i.title === title);

            // Ensure useful labels (best-effort)
            const desiredLabels = ['post-merge-failure', 'automated'];
            for (const name of desiredLabels) {
              try {
                await github.rest.issues.createLabel({ owner, repo, name, color: name === 'post-merge-failure' ? 'B60205' : '6A737D' });
              } catch (e) {
                // 422 if exists - ignore
              }
            }

            if (dup) {
              // Update existing issue with a new comment and ensure labels/assignee
              await github.rest.issues.createComment({ owner, repo, issue_number: dup.number, body });
              try { await github.rest.issues.addLabels({ owner, repo, issue_number: dup.number, labels: desiredLabels }); } catch (e) {}
              try { await github.rest.issues.addAssignees({ owner, repo, issue_number: dup.number, assignees: ['amirbiron'] }); } catch (e) {}
              core.info(`Updated existing issue #${dup.number}`);
            } else {
              // Create new issue
              const created = await github.rest.issues.create({
                owner, repo,
                title,
                body,
                assignees: ['amirbiron']
              });
              const num = created.data.number;
              try { await github.rest.issues.addLabels({ owner, repo, issue_number: num, labels: desiredLabels }); } catch (e) {}
              core.info(`Created issue #${num}`);
            }

  close-issue-on-success:
    name: Close issue on success
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_run' &&
      github.event.workflow_run.event == 'push' &&
      github.event.workflow_run.head_branch == 'main' &&
      github.event.workflow_run.conclusion == 'success'
    steps:
      - name: Close matching failure issue if exists
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const run = context.payload.workflow_run;
            const { owner, repo } = context.repo;
            const titlePrefix = `Post-merge failure: ${run.name} on main @`;
            // fetch open issues labeled as post-merge failures
            const openIssues = await github.paginate(github.rest.issues.listForRepo, {
              owner, repo, state: 'open', per_page: 100, labels: 'post-merge-failure'
            });
            // filter to our workflow's failure issues (exclude PRs)
            const candidates = openIssues
              .filter(i => !i.pull_request)
              .filter(i => i.title && i.title.startsWith(titlePrefix));
            if (candidates.length === 0) {
              core.info('No open post-merge failure issues to close for this workflow');
              return;
            }
            // close the most recent
            candidates.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            const issue = candidates[0];
            await github.rest.issues.createComment({ owner, repo, issue_number: issue.number, body: 'âœ… ×”×¨×™×¦×” ×”××—×¨×•× ×” ×¢×œ main ×¢×‘×¨×” ×‘×”×¦×œ×—×”. ×¡×•×’×¨ ××ª ×”×ª×§×œ×” ×”××—×¨×•× ×”.' });
            await github.rest.issues.update({ owner, repo, issue_number: issue.number, state: 'closed' });
            core.info(`Closed latest failure issue #${issue.number}`);

  test-issue:
    name: Manual test â€“ open/close issue and mention
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
      - name: Open/Close TEST issue
        uses: actions/github-script@v7
        env:
          ACTION: ${{ github.event.inputs.action }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const action = (process.env.ACTION || 'open').toLowerCase();
            const title = '[TEST] Post-merge failure notification check';
            const labels = ['automated', 'notify-test'];

            // ensure labels exist
            for (const name of labels) {
              try { await github.rest.issues.createLabel({ owner, repo, name, color: name === 'notify-test' ? '0366D6' : '6A737D' }); } catch {}
            }

            // find existing test issue
            const openIssues = await github.paginate(github.rest.issues.listForRepo, { owner, repo, state: 'open', per_page: 100 });
            const existing = openIssues.find(i => i.title === title);

            if (action === 'close') {
              if (existing) {
                await github.rest.issues.createComment({ owner, repo, issue_number: existing.number, body: 'âœ… ×‘×“×™×§×ª ×¤×•×©×™×: ×¡×•×’×¨ ××ª ××™×©×•×– ×”××‘×—×Ÿ.' });
                await github.rest.issues.update({ owner, repo, issue_number: existing.number, state: 'closed' });
                core.info(`Closed TEST issue #${existing.number}`);
              } else {
                core.info('No TEST issue to close');
              }
              return;
            }

            // default: open
            if (existing) {
              await github.rest.issues.createComment({ owner, repo, issue_number: existing.number, body: '@amirbiron ğŸ”” ×‘×“×™×§×ª ×¤×•×©×™× â€“ ××–×›×•×¨ ××‘×—×Ÿ' });
              try { await github.rest.issues.addAssignees({ owner, repo, issue_number: existing.number, assignees: ['amirbiron'] }); } catch {}
              try { await github.rest.issues.addLabels({ owner, repo, issue_number: existing.number, labels }); } catch {}
              core.info(`Updated TEST issue #${existing.number}`);
            } else {
              const created = await github.rest.issues.create({ owner, repo, title, body: '@amirbiron ğŸ”” ×‘×“×™×§×ª ×¤×•×©×™× â€“ ×–×”×• ××™×©×•×– ××‘×—×Ÿ', assignees: ['amirbiron'] });
              try { await github.rest.issues.addLabels({ owner, repo, issue_number: created.data.number, labels }); } catch {}
              core.info(`Created TEST issue #${created.data.number}`);
            }
