{% extends "base.html" %}

{% block title %}{{ file.file_name }} - Markdown Preview{% endblock %}

{% block extra_css %}
<style>
/* אזור התצוגה והביצועים */
#md-root {
  /* הרחבת אזור התוכן הלבן לצדדים והרחקה מהשוליים הסגולים */
  max-width: min(1600px, 100vw);
  margin: 0 auto;
  padding: 0.5rem 0; /* את הריווח הצדדי ניתן דרך הכרטיס הפנימי */
}
#md-content {
  background: #ffffff;
  color: #111111;
  border-radius: 12px;
  border: none; /* ביטול מסגרת (שנתפסה כ"סגולה") */
  padding: 14px; /* ריווח אחיד ועדין – לא מרחיק את הבלוק מהגבול */
  transition: background-color 0.3s ease, color 0.3s ease;
  --md-mark-bg: rgba(255, 191, 0, 0.3);
  --md-mark-color: #1a1a1a;
  --md-mark-border: #FFBF00;
  --md-inline-code-bg: #f6f8fa;
  --md-inline-code-border: #d0d7de;
  --md-inline-code-color: #1f2328;
  --md-code-border: #d0d7de;
  --md-code-shell-bg: #e6edf4;
  --md-code-header-bg: #e6edf4;
  --md-code-header-text: #57606a;
  --md-code-bg: #f6f8fa;
  --md-code-text: #24292f;
  --md-code-shadow: 0 12px 24px rgba(15, 23, 42, 0.08);
  --md-code-copy-bg: #ffffff;
  --md-code-copy-border: #d0d7de;
  --md-code-copy-color: #57606a;
  --md-code-copy-hover-bg: #e6ebf1;
  --md-code-copy-success-color: #1a7f37;
  --md-code-copy-error-color: #b42318;
  --md-code-lang-bg: #dce3eb;
  --md-code-lang-text: #24292f;
  --hljs-text: #24292f;
  --hljs-keyword: #cf222e;
  --hljs-string: #0a3069;
  --hljs-function: #8250df;
  --hljs-comment: #6e7781;
  --hljs-number: #0550ae;
  --hljs-operator: #24292f;
  --hljs-addition-text: #1a7f37;
  --hljs-addition-bg: rgba(26, 127, 55, 0.12);
  --hljs-deletion-text: #cf222e;
  --hljs-deletion-bg: rgba(207, 34, 46, 0.15);
  --md-blockquote-bg: #eef2f7;
  --md-blockquote-border: #cbd5e1;
  --md-blockquote-color: #0f172a;
  --md-table-border: #e5e7eb;
  --md-table-header-bg: #f8fafc;
}

/* Dark/Dim theme support */
[data-theme="dark"] #md-content,
[data-theme="dim"] #md-content,
[data-theme="nebula"] #md-content {
  background: var(--bg-primary);
  color: var(--text-primary);
}

[data-theme="dark"] #md-content {
  --md-mark-bg: rgba(255, 191, 0, 0.3);
  --md-mark-color: #FFFFFF;
  --md-mark-border: #FFBF00;
  --md-inline-code-bg: rgba(255, 255, 255, 0.08);
  --md-inline-code-border: rgba(255, 255, 255, 0.2);
  --md-inline-code-color: #e9ecff;
  --md-code-border: rgba(255, 255, 255, 0.18);
  --md-code-shell-bg: #1f1f28;
  --md-code-header-bg: #25273a;
  --md-code-header-text: #cfd7ff;
  --md-code-bg: #1a1c23;
  --md-code-text: #e5eaf7;
  --md-code-copy-bg: #2d2f49;
  --md-code-copy-border: #3c3f60;
  --md-code-copy-color: #f8f9ff;
  --md-code-copy-hover-bg: #3b3f5c;
  --md-code-copy-success-color: #4ade80;
  --md-code-copy-error-color: #f87171;
  --md-code-lang-bg: rgba(255, 255, 255, 0.12);
  --md-code-lang-text: #f4f4ff;
  --md-code-shadow: 0 18px 30px rgba(0, 0, 0, 0.55);
  --hljs-text: #e5eaf7;
  --hljs-keyword: #c678dd;
  --hljs-string: #98c379;
  --hljs-function: #61afef;
  --hljs-comment: #5c6370;
  --hljs-number: #d19a66;
  --hljs-operator: #56b6c2;
  --hljs-addition-text: #98c379;
  --hljs-addition-bg: rgba(152, 195, 121, 0.18);
  --hljs-deletion-text: #e06c75;
  --hljs-deletion-bg: rgba(224, 108, 117, 0.22);
  --md-blockquote-bg: color-mix(in srgb, var(--bg-tertiary) 70%, rgba(255, 255, 255, 0.05));
  --md-blockquote-border: var(--glass-border);
  --md-blockquote-color: var(--text-secondary);
  --md-table-border: var(--glass-border);
  --md-table-header-bg: color-mix(in srgb, var(--bg-tertiary) 80%, rgba(255,255,255,0.08));
}

[data-theme="dim"] #md-content {
  --md-mark-bg: rgba(255, 191, 0, 0.3);
  --md-mark-color: #FFFFFF;
  --md-mark-border: #FFBF00;
  --md-inline-code-bg: rgba(236, 239, 244, 0.08);
  --md-inline-code-border: rgba(236, 239, 244, 0.18);
  --md-inline-code-color: #eceff4;
  --md-code-border: rgba(236, 239, 244, 0.1);
  --md-code-shell-bg: #2e3440;
  --md-code-header-bg: #3b4252;
  --md-code-header-text: #eceff4;
  --md-code-bg: #272c36;
  --md-code-text: #eceff4;
  --md-code-copy-bg: #39404f;
  --md-code-copy-border: #4c566a;
  --md-code-copy-color: #eceff4;
  --md-code-copy-hover-bg: #4c5568;
  --md-code-copy-success-color: #a3be8c;
  --md-code-copy-error-color: #d08770;
  --md-code-lang-bg: rgba(236, 239, 244, 0.15);
  --md-code-lang-text: #eceff4;
  --md-code-shadow: 0 20px 36px rgba(17, 24, 39, 0.65);
  --hljs-text: #eceff4;
  --hljs-keyword: #81a1c1;
  --hljs-string: #a3be8c;
  --hljs-function: #88c0d0;
  --hljs-comment: #616e88;
  --hljs-number: #b48ead;
  --hljs-operator: #ebcb8b;
  --hljs-addition-text: #a3be8c;
  --hljs-addition-bg: rgba(163, 190, 140, 0.2);
  --hljs-deletion-text: #d08770;
  --hljs-deletion-bg: rgba(208, 135, 112, 0.25);
  --md-blockquote-bg: color-mix(in srgb, var(--bg-tertiary) 70%, rgba(255, 255, 255, 0.04));
  --md-blockquote-border: color-mix(in srgb, var(--glass-border) 80%, rgba(255,255,255,0.05));
  --md-blockquote-color: var(--text-secondary);
  --md-table-border: color-mix(in srgb, var(--glass-border) 90%, rgba(255,255,255,0.05));
  --md-table-header-bg: color-mix(in srgb, var(--bg-tertiary) 80%, rgba(255,255,255,0.07));
}

[data-theme="nebula"] #md-content {
  --md-mark-bg: rgba(255, 191, 0, 0.3);
  --md-mark-color: #FFFFFF;
  --md-mark-border: #FFBF00;
  --md-inline-code-bg: rgba(248, 248, 242, 0.08);
  --md-inline-code-border: rgba(248, 248, 242, 0.2);
  --md-inline-code-color: #f8f8f2;
  --md-code-border: rgba(248, 248, 242, 0.12);
  --md-code-shell-bg: #282a36;
  --md-code-header-bg: #343746;
  --md-code-header-text: #f8f8f2;
  --md-code-bg: #242635;
  --md-code-text: #f8f8f2;
  --md-code-copy-bg: #363850;
  --md-code-copy-border: #44475a;
  --md-code-copy-color: #f8f8f2;
  --md-code-copy-hover-bg: #4b4e68;
  --md-code-copy-success-color: #50fa7b;
  --md-code-copy-error-color: #ff5555;
  --md-code-lang-bg: rgba(248, 248, 242, 0.12);
  --md-code-lang-text: #f8f8f2;
  --md-code-shadow: 0 18px 34px rgba(40, 42, 54, 0.65);
  --hljs-text: #f8f8f2;
  --hljs-keyword: #ff79c6;
  --hljs-string: #f1fa8c;
  --hljs-function: #50fa7b;
  --hljs-comment: #6272a4;
  --hljs-number: #bd93f9;
  --hljs-operator: #8be9fd;
  --hljs-addition-text: #50fa7b;
  --hljs-addition-bg: rgba(80, 250, 123, 0.18);
  --hljs-deletion-text: #ff5555;
  --hljs-deletion-bg: rgba(255, 85, 85, 0.2);
  --md-blockquote-bg: color-mix(in srgb, var(--bg-tertiary) 65%, rgba(255,255,255,0.04));
  --md-blockquote-border: color-mix(in srgb, var(--glass-border) 80%, rgba(255,255,255,0.05));
  --md-blockquote-color: var(--text-secondary);
  --md-table-border: color-mix(in srgb, var(--glass-border) 90%, rgba(255,255,255,0.05));
  --md-table-header-bg: color-mix(in srgb, var(--bg-tertiary) 78%, rgba(255,255,255,0.08));
}

:root[data-theme="rose-pine-dawn"] #md-content {
  --md-mark-bg: rgba(255, 191, 0, 0.3);
  --md-mark-color: #1a1a1a;
  --md-mark-border: #FFBF00;
  --md-inline-code-bg: rgba(244, 219, 214, 0.9);
  --md-inline-code-border: rgba(180, 99, 122, 0.4);
  --md-inline-code-color: #4a2c2a;
  --md-code-border: rgba(180, 99, 122, 0.45);
  --md-code-shell-bg: #fffaf3;
  --md-code-header-bg: #f4dbd6;
  --md-code-header-text: #42211f;
  --md-code-bg: #faf4ed;
  --md-code-text: #4a2c2a;
  --md-code-copy-bg: #ffe9ea;
  --md-code-copy-border: #f2d4d7;
  --md-code-copy-color: #b4637a;
  --md-code-copy-hover-bg: #f8dfe4;
  --md-code-copy-success-color: #286983;
  --md-code-copy-error-color: #b4637a;
  --md-code-lang-bg: #fbe8e0;
  --md-code-lang-text: #b4637a;
  --md-code-shadow: 0 16px 30px rgba(180, 99, 122, 0.25);
  --hljs-text: #575279;
  --hljs-keyword: #907aa9;
  --hljs-string: #56949f;
  --hljs-function: #286983;
  --hljs-comment: #9893a5;
  --hljs-number: #ea9d34;
  --hljs-operator: #d7827e;
  --hljs-addition-text: #56949f;
  --hljs-addition-bg: rgba(86, 148, 159, 0.18);
  --hljs-deletion-text: #b4637a;
  --hljs-deletion-bg: rgba(180, 99, 122, 0.2);
  --md-blockquote-bg: color-mix(in srgb, var(--bg-secondary) 85%, rgba(255,255,255,0.2));
  --md-blockquote-border: color-mix(in srgb, var(--glass-border) 80%, rgba(180,99,122,0.2));
  --md-blockquote-color: #4a2c2a;
  --md-table-border: color-mix(in srgb, var(--glass-border) 90%, rgba(180,99,122,0.2));
  --md-table-header-bg: color-mix(in srgb, var(--bg-secondary) 80%, rgba(255,255,255,0.3));
}

/* Custom/Shared Theme support - משתמש במשתני CSS מהערכה המותאמת */
/* Note: Using color-mix with --text-primary ensures good contrast even when --bg-tertiary is similar to --bg-primary */
[data-theme="custom"] #md-content,
[data-theme^="shared:"] #md-content {
  background: var(--bg-primary, var(--md-surface, #1a1c23));
  color: var(--text-primary, var(--md-text, #e5eaf7));
  --md-mark-bg: color-mix(in srgb, #FFBF00 30%, transparent);
  --md-mark-color: var(--text-primary, #FFFFFF);
  --md-mark-border: #FFBF00;
  /* Inline code: mix 12% of text color into background for visible contrast */
  --md-inline-code-bg: color-mix(in srgb, var(--text-primary, #ffffff) 12%, var(--bg-primary, #1a1c23));
  --md-inline-code-border: color-mix(in srgb, var(--text-primary, #ffffff) 20%, transparent);
  /* Inline code text: mix primary accent with text for dynamic emphasis */
  --md-inline-code-color: color-mix(in srgb, var(--primary, var(--warning, #DCCC44)) 65%, var(--text-primary, #e5eaf7));
  --md-code-border: var(--glass-border, rgba(255, 255, 255, 0.18));
  /* Code blocks: use theme variables (these usually have good contrast) */
  --md-code-shell-bg: var(--bg-secondary, #1f1f28);
  --md-code-header-bg: var(--bg-tertiary, #25273a);
  --md-code-header-text: var(--text-secondary, #cfd7ff);
  --md-code-bg: color-mix(in srgb, var(--text-primary, #ffffff) 8%, var(--bg-primary, #1a1c23));
  --md-code-text: var(--code-text, var(--text-primary, #e5eaf7));
  --md-code-copy-bg: color-mix(in srgb, var(--text-primary, #ffffff) 10%, var(--bg-primary, #1a1c23));
  --md-code-copy-border: color-mix(in srgb, var(--text-primary, #ffffff) 18%, transparent);
  --md-code-copy-color: var(--text-primary, #f8f9ff);
  --md-code-copy-hover-bg: color-mix(in srgb, var(--text-primary, #ffffff) 15%, var(--bg-primary, #1a1c23));
  --md-code-copy-success-color: var(--success, #4ade80);
  --md-code-copy-error-color: var(--danger, #f87171);
  --md-code-lang-bg: color-mix(in srgb, var(--text-primary, #ffffff) 14%, var(--bg-primary, #1a1c23));
  --md-code-lang-text: var(--text-primary, #f4f4ff);
  --md-code-shadow: 0 18px 30px rgba(0, 0, 0, 0.55);
  --hljs-text: var(--text-primary, #e5eaf7);
  --hljs-keyword: var(--primary, #c678dd);
  --hljs-string: var(--success, #98c379);
  --hljs-function: var(--secondary, #61afef);
  --hljs-comment: var(--text-muted, #5c6370);
  --hljs-number: var(--warning, #d19a66);
  --hljs-operator: var(--info, #56b6c2);
  --hljs-addition-text: var(--success, #98c379);
  --hljs-addition-bg: color-mix(in srgb, var(--success, #98c379) 18%, transparent);
  --hljs-deletion-text: var(--danger, #e06c75);
  --hljs-deletion-bg: color-mix(in srgb, var(--danger, #e06c75) 22%, transparent);
  /* Blockquotes: 10% mix for clear distinction */
  --md-blockquote-bg: color-mix(in srgb, var(--text-primary, #ffffff) 10%, var(--bg-primary, #1a1c23));
  --md-blockquote-border: color-mix(in srgb, var(--text-primary, #ffffff) 25%, transparent);
  --md-blockquote-color: var(--text-secondary, var(--text-primary, #b0b8d1));
  --md-table-border: color-mix(in srgb, var(--text-primary, #ffffff) 20%, transparent);
  /* Table header: 12% mix for clear distinction */
  --md-table-header-bg: color-mix(in srgb, var(--text-primary, #ffffff) 12%, var(--bg-primary, #1a1c23));
}

/* Highlight ("marker") syntax: ==text== -> <mark>text</mark> */
#md-content mark {
  background-color: var(--md-mark-bg, rgba(255, 191, 0, 0.3));
  color: var(--md-mark-color, #FFFFFF);
  border-radius: 2px;
  padding: 0 4px;
  border-bottom: 1.5px solid var(--md-mark-border, #FFBF00);
}

/* Mermaid diagrams - ensure readable colors for custom/shared themes */
[data-theme="custom"] #md-content .mermaid,
[data-theme="custom"] #md-content [class*="mermaid"],
[data-theme^="shared:"] #md-content .mermaid,
[data-theme^="shared:"] #md-content [class*="mermaid"] {
  /* Node backgrounds and text */
  --mermaid-node-bg: color-mix(in srgb, var(--text-primary, #ffffff) 15%, var(--bg-primary, #1a1c23));
  --mermaid-node-text: var(--text-primary, #e5eaf7);
  --mermaid-node-border: color-mix(in srgb, var(--text-primary, #ffffff) 30%, transparent);
}

[data-theme="custom"] #md-content .node rect,
[data-theme="custom"] #md-content .node polygon,
[data-theme="custom"] #md-content .node circle,
[data-theme^="shared:"] #md-content .node rect,
[data-theme^="shared:"] #md-content .node polygon,
[data-theme^="shared:"] #md-content .node circle {
  fill: color-mix(in srgb, var(--text-primary, #ffffff) 15%, var(--bg-primary, #1a1c23)) !important;
  stroke: color-mix(in srgb, var(--primary, var(--text-primary, #ffffff)) 50%, transparent) !important;
}

[data-theme="custom"] #md-content .node .label,
[data-theme="custom"] #md-content .nodeLabel,
[data-theme="custom"] #md-content .label,
[data-theme^="shared:"] #md-content .node .label,
[data-theme^="shared:"] #md-content .nodeLabel,
[data-theme^="shared:"] #md-content .label {
  color: var(--text-primary, #e5eaf7) !important;
  fill: var(--text-primary, #e5eaf7) !important;
}

[data-theme="custom"] #md-content .edgeLabel,
[data-theme^="shared:"] #md-content .edgeLabel {
  background-color: var(--bg-primary, #1a1c23) !important;
  color: var(--text-primary, #e5eaf7) !important;
  fill: var(--text-primary, #e5eaf7) !important;
}

[data-theme="custom"] #md-content .edgePath path,
[data-theme^="shared:"] #md-content .edgePath path {
  stroke: color-mix(in srgb, var(--text-primary, #ffffff) 40%, transparent) !important;
}

/* Sequence diagram specific */
[data-theme="custom"] #md-content .actor,
[data-theme^="shared:"] #md-content .actor {
  fill: color-mix(in srgb, var(--text-primary, #ffffff) 15%, var(--bg-primary, #1a1c23)) !important;
  stroke: color-mix(in srgb, var(--primary, var(--text-primary, #ffffff)) 50%, transparent) !important;
}

[data-theme="custom"] #md-content .actor-line,
[data-theme^="shared:"] #md-content .actor-line {
  stroke: color-mix(in srgb, var(--text-primary, #ffffff) 30%, transparent) !important;
}

[data-theme="custom"] #md-content text.actor,
[data-theme="custom"] #md-content .messageText,
[data-theme="custom"] #md-content .loopText,
[data-theme^="shared:"] #md-content text.actor,
[data-theme^="shared:"] #md-content .messageText,
[data-theme^="shared:"] #md-content .loopText {
  fill: var(--text-primary, #e5eaf7) !important;
}

[data-theme="custom"] #md-content .messageLine0,
[data-theme="custom"] #md-content .messageLine1,
[data-theme^="shared:"] #md-content .messageLine0,
[data-theme^="shared:"] #md-content .messageLine1 {
  stroke: color-mix(in srgb, var(--text-primary, #ffffff) 50%, transparent) !important;
}

[data-theme="custom"] #md-content .note,
[data-theme^="shared:"] #md-content .note {
  fill: color-mix(in srgb, var(--warning, var(--text-primary, #ffffff)) 20%, var(--bg-primary, #1a1c23)) !important;
  stroke: color-mix(in srgb, var(--warning, var(--text-primary, #ffffff)) 40%, transparent) !important;
}

[data-theme="custom"] #md-content .noteText,
[data-theme^="shared:"] #md-content .noteText {
  fill: var(--text-primary, #e5eaf7) !important;
}

[data-theme="dark"] #md-content code:not(pre code),
[data-theme="dim"] #md-content code:not(pre code),
[data-theme="nebula"] #md-content code:not(pre code) {
  background: var(--bg-tertiary);
  color: var(--code-text, var(--text-primary));
  border: 1px solid var(--code-border, var(--glass-border));
}

/* Custom/Shared theme: use color-mix for better contrast since --bg-tertiary may be too similar to --bg-primary */
[data-theme="custom"] #md-content code:not(pre code),
[data-theme^="shared:"] #md-content code:not(pre code) {
  background: color-mix(in srgb, var(--text-primary, #ffffff) 12%, var(--bg-primary, #1a1c23));
  color: var(--code-text, var(--text-primary));
  border: 1px solid color-mix(in srgb, var(--text-primary, #ffffff) 20%, transparent);
}

[data-theme="dark"] #md-content pre,
[data-theme="dim"] #md-content pre,
[data-theme="nebula"] #md-content pre {
  background: var(--code-bg, var(--bg-secondary));
  border: 1px solid var(--code-border, var(--glass-border));
}

/* Custom/Shared theme: use theme variables for code blocks */
[data-theme="custom"] #md-content pre,
[data-theme^="shared:"] #md-content pre {
  background: var(--code-bg, var(--bg-secondary, #1a1c23));
  border: 1px solid var(--code-border, var(--glass-border, rgba(255, 255, 255, 0.15)));
}

/* צבעי רקע חומים לתצוגת מארקדאון — גוונים בהירים ונעימים */
#md-content.bg-light {
  background: #f5e6d3;
  color: #2b2b2b;
  --md-inline-code-bg: rgba(255, 255, 255, 0.4);
  --md-inline-code-border: rgba(0, 0, 0, 0.08);
  --md-inline-code-color: #2b2b2b;
  --md-code-border: #e6d4bc;
  --md-code-shell-bg: #eddcc4;
  --md-code-header-bg: #e3d1b8;
  --md-code-header-text: #6b5d4f;
  --md-code-bg: #eddcc4;
  --md-code-text: #5a4a3a;
  --md-code-copy-bg: #f5e7cf;
  --md-code-copy-border: #d8c5ac;
  --md-code-copy-color: #5a4a3a;
  --md-code-copy-hover-bg: #e9d9c0;
  --md-code-lang-bg: #dcc7ab;
  --md-code-lang-text: #5a4a3a;
  --md-code-shadow: 0 14px 30px rgba(87, 63, 32, 0.18);
  --hljs-text: #5a4a3a;
  --hljs-keyword: #a67c52;
  --hljs-string: #6b8e23;
  --hljs-function: #4682b4;
  --hljs-comment: #8b7d6b;
  --hljs-number: #c97b63;
  --hljs-operator: #5a4a3a;
  --hljs-addition-text: #6b8e23;
  --hljs-addition-bg: rgba(107, 142, 35, 0.18);
  --hljs-deletion-text: #a67c52;
  --hljs-deletion-bg: rgba(166, 124, 82, 0.22);
}

#md-content.bg-medium {
  background: #e8d4b0;
  color: #1f1f1f;
  --md-inline-code-bg: rgba(255, 255, 255, 0.35);
  --md-inline-code-border: rgba(0, 0, 0, 0.12);
  --md-inline-code-color: #2b241b;
  --md-code-border: #d4c19c;
  --md-code-shell-bg: #dcc9a8;
  --md-code-header-bg: #d0bd98;
  --md-code-header-text: #5d5040;
  --md-code-bg: #dcc9a8;
  --md-code-text: #4a3d2f;
  --md-code-copy-bg: #ebd8b6;
  --md-code-copy-border: #cbb793;
  --md-code-copy-color: #4a3d2f;
  --md-code-copy-hover-bg: #decaa8;
  --md-code-lang-bg: #c9b48f;
  --md-code-lang-text: #443628;
  --md-code-shadow: 0 15px 32px rgba(92, 60, 25, 0.2);
  --hljs-text: #4a3d2f;
  --hljs-keyword: #8b6914;
  --hljs-string: #2e8b57;
  --hljs-function: #4169e1;
  --hljs-comment: #7a6e5d;
  --hljs-number: #c97b63;
  --hljs-operator: #4a3d2f;
  --hljs-addition-text: #2e8b57;
  --hljs-addition-bg: rgba(46, 139, 87, 0.18);
  --hljs-deletion-text: #8b6914;
  --hljs-deletion-bg: rgba(139, 105, 20, 0.22);
}

#md-content.bg-dark {
  background: #d4b896;
  color: #111111;
  --md-inline-code-bg: rgba(255, 255, 255, 0.3);
  --md-inline-code-border: rgba(0, 0, 0, 0.15);
  --md-inline-code-color: #2b1f16;
  --md-code-border: #c4a882;
  --md-code-shell-bg: #c9ae88;
  --md-code-header-bg: #bea47a;
  --md-code-header-text: #4a3f2f;
  --md-code-bg: #c9ae88;
  --md-code-text: #3d3020;
  --md-code-copy-bg: #d6ba92;
  --md-code-copy-border: #bfa37b;
  --md-code-copy-color: #3d3020;
  --md-code-copy-hover-bg: #c7ad87;
  --md-code-lang-bg: #b7966d;
  --md-code-lang-text: #3d2f1e;
  --md-code-shadow: 0 18px 36px rgba(70, 44, 15, 0.22);
  --hljs-text: #3d3020;
  --hljs-keyword: #8b4513;
  --hljs-string: #228b22;
  --hljs-function: #4682b4;
  --hljs-comment: #6b5d4f;
  --hljs-number: #d2691e;
  --hljs-operator: #3d3020;
  --hljs-addition-text: #228b22;
  --hljs-addition-bg: rgba(34, 139, 34, 0.2);
  --hljs-deletion-text: #8b4513;
  --hljs-deletion-bg: rgba(139, 69, 19, 0.22);
}

#md-content.bg-sepia {
  background: #fdf6e3;
  color: #586e75;
  --md-inline-code-bg: rgba(255, 255, 255, 0.45);
  --md-inline-code-border: rgba(0, 0, 0, 0.08);
  --md-inline-code-color: #2c2520;
  --md-code-border: #d3cbb7;
  --md-code-shell-bg: #eee8d5;
  --md-code-header-bg: #e4dfc9;
  --md-code-header-text: #586e75;
  --md-code-bg: #eee8d5;
  --md-code-text: #657b83;
  --md-code-copy-bg: #faf2da;
  --md-code-copy-border: #d1c7ab;
  --md-code-copy-color: #5a4c3a;
  --md-code-copy-hover-bg: #eadfca;
  --md-code-lang-bg: #d9cfb6;
  --md-code-lang-text: #4f4a3a;
  --md-code-shadow: 0 14px 28px rgba(90, 66, 33, 0.16);
  --hljs-text: #657b83;
  --hljs-keyword: #859900;
  --hljs-string: #2aa198;
  --hljs-function: #268bd2;
  --hljs-comment: #93a1a1;
  --hljs-number: #b58900;
  --hljs-operator: #b58900;
  --hljs-addition-text: #2aa198;
  --hljs-addition-bg: rgba(42, 161, 152, 0.2);
  --hljs-deletion-text: #dc322f;
  --hljs-deletion-bg: rgba(220, 50, 47, 0.2);
}

/* קיפול H3 (admin) – צבע רקע נעים לעיניים בהתאם לצבע הכללי */
#md-content { --md-fold-bg: #f6f6f6; --md-fold-border: rgba(0,0,0,0.06); }
#md-content.bg-light { --md-fold-bg: #fbf2e6; --md-fold-border: rgba(0,0,0,0.08); }
#md-content.bg-medium { --md-fold-bg: #f2e2c8; --md-fold-border: rgba(0,0,0,0.09); }
#md-content.bg-dark { --md-fold-bg: #e8d2b4; --md-fold-border: rgba(0,0,0,0.10); }
#md-content.bg-sepia { --md-fold-bg: #fff3dc; --md-fold-border: rgba(0,0,0,0.07); }

#md-content details.md-section-collapse {
  background: transparent;
  border: 1px solid var(--md-fold-border);
  border-radius: 10px;
  margin: 0.5rem 0 0.75rem;
}
#md-content details.md-section-collapse > summary.markdown-summary {
  cursor: pointer;
  list-style: none;
  padding: 0.55rem 0.8rem;
  font-weight: 600;
}
#md-content details.md-section-collapse > summary.markdown-summary::-webkit-details-marker { display: none; }
#md-content details.md-section-collapse[open] > summary.markdown-summary {
  border-bottom: 1px solid var(--md-fold-border);
}
#md-content details.md-section-collapse > .md-section-content {
  background: var(--md-fold-bg);
  border-top: 1px solid var(--md-fold-border);
  padding: 0.8rem 1rem;
  border-radius: 0 0 10px 10px;
}

/* התאמת צבעי אלמנטים פנימיים לרקע החום */
#md-content.bg-light code:not(pre code),
#md-content.bg-medium code:not(pre code),
#md-content.bg-dark code:not(pre code),
#md-content.bg-sepia code:not(pre code) {
  background: rgba(255, 255, 255, 0.4);
  border: 1px solid rgba(0, 0, 0, 0.1);
}

#md-content.bg-light blockquote,
#md-content.bg-medium blockquote,
#md-content.bg-dark blockquote,
#md-content.bg-sepia blockquote {
  background: rgba(255, 255, 255, 0.3);
  border-inline-start-color: rgba(0, 0, 0, 0.2);
}

#md-content.bg-light table thead,
#md-content.bg-medium table thead,
#md-content.bg-dark table thead,
#md-content.bg-sepia table thead {
  background: rgba(255, 255, 255, 0.3);
}

#md-content.bg-light table th,
#md-content.bg-light table td,
#md-content.bg-medium table th,
#md-content.bg-medium table td,
#md-content.bg-dark table th,
#md-content.bg-dark table td,
#md-content.bg-sepia table th,
#md-content.bg-sepia table td {
  border-color: rgba(0, 0, 0, 0.1);
}

/* hover effect for color options */
.bg-color-option:hover {
  transform: scale(1.05);
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.bg-color-option.active {
  border: 2px solid #4a90e2 !important;
  box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
}
/* במסך מלא – לאפשר גלילה בתוך הכרטיס עצמו (תמיכה גם ב-WebKit) */
#mdCard:fullscreen { height: 100vh; overflow: auto; }
#mdCard:-webkit-full-screen { height: 100vh; overflow: auto; }
#md-content img {
  max-width: 100%;
  height: auto;
}
/* ==========================================================================
   MD Editor Toolbar - עיצוב חדש כמו view_file
   ========================================================================== */
.md-editor-toolbar {
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 10px;
  padding: 8px;
  margin: 0 0 1rem;
  background: var(--glass, rgba(255, 255, 255, 0.08));
  border: 1px solid var(--glass-border, rgba(255, 255, 255, 0.18));
  border-radius: 12px;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  position: sticky;
  top: 0;
  z-index: 5;
}

.md-search-capsule {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 8px;
  flex: 1 1 320px;
  min-width: 240px;
  padding: 6px 10px;
  border-radius: 10px;
  background: color-mix(in srgb, var(--bg-primary, #000) 25%, transparent);
  border: 1px solid transparent;
  transition: border-color 0.2s ease, background 0.2s ease;
}

.md-search-capsule:focus-within {
  border-color: color-mix(in srgb, var(--text-primary, #fff) 50%, transparent);
  background: color-mix(in srgb, var(--bg-primary, #000) 40%, transparent);
}

.md-search-capsule .md-search-input {
  flex: 1 1 200px;
  min-width: 0;
  border: none;
  background: transparent;
  color: var(--text-primary, #ffffff);
  font-size: 15px;
  padding: 6px 4px;
  outline: none;
}

.md-search-capsule .md-search-input::placeholder {
  color: var(--text-muted, rgba(255, 255, 255, 0.6));
}

.md-search-capsule .md-search-count {
  color: var(--text-secondary, rgba(255, 255, 255, 0.85));
  font-size: 13px;
  white-space: nowrap;
  min-width: 48px;
  text-align: center;
  font-variant-numeric: tabular-nums;
}

.md-search-capsule .md-divider {
  width: 1px;
  height: 22px;
  background: color-mix(in srgb, var(--text-primary, #fff) 25%, transparent);
}

.md-search-capsule .md-icon-btn {
  background: transparent;
  border: none;
  color: var(--text-primary, rgba(255, 255, 255, 0.9));
  width: 34px;
  height: 34px;
  border-radius: 6px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background 0.2s ease;
  font-size: 16px;
}

.md-search-capsule .md-icon-btn:hover,
.md-search-capsule .md-icon-btn:focus-visible {
  background: color-mix(in srgb, var(--text-primary, #fff) 15%, transparent);
}

.md-fullscreen-btn {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 10px 20px;
  border-radius: 10px;
  border: 1px solid var(--glass-border, rgba(255, 255, 255, 0.25));
  background: var(--glass, rgba(255, 255, 255, 0.12));
  color: var(--text-primary, #ffffff);
  font-size: 14px;
  cursor: pointer;
  transition: background 0.2s ease, border-color 0.2s ease;
  white-space: nowrap;
  margin-inline-start: auto;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

.md-fullscreen-btn:hover,
.md-fullscreen-btn:focus-visible {
  background: color-mix(in srgb, var(--text-primary, #fff) 22%, transparent);
  border-color: color-mix(in srgb, var(--text-primary, #fff) 40%, transparent);
}

/* Classic Theme */
:root[data-theme="classic"] .md-editor-toolbar {
  background: linear-gradient(135deg, rgba(102, 126, 234, 0.25) 0%, rgba(118, 99, 255, 0.3) 100%);
  border-color: rgba(255, 255, 255, 0.3);
}
:root[data-theme="classic"] .md-search-capsule {
  background: rgba(0, 0, 0, 0.2);
}
:root[data-theme="classic"] .md-search-capsule:focus-within {
  border-color: rgba(255, 255, 255, 0.5);
  background: rgba(0, 0, 0, 0.35);
}
:root[data-theme="classic"] .md-fullscreen-btn {
  background: rgba(255, 255, 255, 0.15);
  border-color: rgba(255, 255, 255, 0.3);
}
:root[data-theme="classic"] .md-fullscreen-btn:hover,
:root[data-theme="classic"] .md-fullscreen-btn:focus-visible {
  background: rgba(255, 255, 255, 0.25);
  border-color: rgba(255, 255, 255, 0.5);
}

/* Ocean Theme */
:root[data-theme="ocean"] .md-editor-toolbar {
  background: rgba(49, 130, 206, 0.2);
  border-color: rgba(49, 130, 206, 0.4);
}
:root[data-theme="ocean"] .md-search-capsule {
  background: rgba(0, 0, 0, 0.25);
}
:root[data-theme="ocean"] .md-search-capsule:focus-within {
  border-color: rgba(49, 130, 206, 0.6);
  background: rgba(0, 0, 0, 0.35);
}
:root[data-theme="ocean"] .md-fullscreen-btn {
  background: rgba(49, 130, 206, 0.15);
  border-color: rgba(49, 130, 206, 0.35);
}
:root[data-theme="ocean"] .md-fullscreen-btn:hover,
:root[data-theme="ocean"] .md-fullscreen-btn:focus-visible {
  background: rgba(49, 130, 206, 0.3);
  border-color: rgba(49, 130, 206, 0.5);
}

/* Rose Pine Dawn - Light Theme */
:root[data-theme="rose-pine-dawn"] .md-editor-toolbar {
  background: color-mix(in srgb, var(--bg-secondary) 65%, #ffffff 35%);
  border-color: var(--glass-border);
}
:root[data-theme="rose-pine-dawn"] .md-search-capsule {
  background: color-mix(in srgb, var(--bg-primary) 30%, rgba(0,0,0,0.1));
}
:root[data-theme="rose-pine-dawn"] .md-search-capsule:focus-within {
  border-color: rgba(144, 122, 169, 0.5);
  background: color-mix(in srgb, var(--bg-primary) 40%, rgba(0,0,0,0.15));
}
:root[data-theme="rose-pine-dawn"] .md-fullscreen-btn {
  background: color-mix(in srgb, var(--bg-secondary) 65%, #ffffff 35%);
  border-color: var(--glass-border);
  color: var(--text-primary);
}
:root[data-theme="rose-pine-dawn"] .md-fullscreen-btn:hover,
:root[data-theme="rose-pine-dawn"] .md-fullscreen-btn:focus-visible {
  background: color-mix(in srgb, var(--bg-secondary) 45%, #ffffff 55%);
  border-color: rgba(144, 122, 169, 0.5);
}

/* Custom/Shared Theme support */
:root[data-theme="custom"] .md-editor-toolbar,
:root[data-theme^="shared:"] .md-editor-toolbar {
  background: var(--glass, color-mix(in srgb, var(--text-primary, #fff) 10%, transparent));
  border-color: var(--glass-border, color-mix(in srgb, var(--text-primary, #fff) 20%, transparent));
}
:root[data-theme="custom"] .md-search-capsule,
:root[data-theme^="shared:"] .md-search-capsule {
  background: color-mix(in srgb, var(--bg-primary, #000) 25%, transparent);
}
:root[data-theme="custom"] .md-search-capsule:focus-within,
:root[data-theme^="shared:"] .md-search-capsule:focus-within {
  border-color: color-mix(in srgb, var(--primary, var(--text-primary, #fff)) 50%, transparent);
  background: color-mix(in srgb, var(--bg-primary, #000) 40%, transparent);
}

/* Responsive - Mobile */
@media (max-width: 500px) {
  .md-search-capsule {
    flex-basis: 100%;
    width: 100%;
    min-width: 0;
    order: 2;
  }
  .md-fullscreen-btn {
    width: auto;
    order: 1;
    margin-inline-start: auto;
  }
}
/* כפתור "צבע רקע" — יוצג רק בערכות: classic/ocean/rose-pine-dawn */
#bgColorSwitcher {
  display: none;
  position: relative;
  z-index: 1;
  margin-inline-end: .5rem;
}

:root[data-theme="classic"] #bgColorSwitcher,
:root[data-theme="ocean"] #bgColorSwitcher,
:root[data-theme="rose-pine-dawn"] #bgColorSwitcher {
  display: inline-flex;
  align-items: center;
}
@media (max-width: 600px) {
  /* במובייל – אם צריך, ניתן להעביר לשורה שנייה בתוך הכותרת */
  #bgColorSwitcher { order: 2; width: auto; margin-top: 6px; }
}
/* כפתור Reader Mode — מוצג רק בערכות כהות */
.md-reader-mode-btn { display: none !important; }
:root[data-theme="custom"] .md-reader-mode-btn,
:root[data-theme^="shared:"] .md-reader-mode-btn,
:root[data-theme="dark"] .md-reader-mode-btn,
:root[data-theme="dim"] .md-reader-mode-btn,
:root[data-theme="nebula"] .md-reader-mode-btn {
  display: inline-flex !important;
  align-items: center;
  justify-content: center;
  padding: 8px 12px;
  font-size: 14px;
  line-height: 1;
}
/* הרחבת הקונטיינר בעמוד Markdown כדי לצמצם את הסגול בצדדים */
.main-content > .container {
  /* מכולה רחבה כדי לצמצם "סגול" בצדדים */
  max-width: 100% !important;
  width: 100% !important;
  padding-left: 8px !important;
  padding-right: 8px !important;
}
/* בעמוד Markdown בלבד: צמצום הפס הסגול משמאל – מרחיבים את הכרטיס שמאלה */
.main-content .glass-card {
  margin-left: 0 !important;        /* שמאל קרוב יותר לקצה */
  margin-right: 0.5rem !important;  /* שומרים על ימין קיים */
  width: calc(100% - 0.5rem) !important;
}
/* טבלאות בסגנון GitHub */
#md-content table {
  width: 100%;
  border-collapse: collapse;
  overflow: auto;
  display: block;
}
#md-content table th, #md-content table td {
  border: 1px solid var(--md-table-border, #e5e7eb);
  padding: 0.5rem 0.75rem;
}
#md-content table thead {
  background: var(--md-table-header-bg, #f8fafc);
}
/* קוד (fenced) */
#md-content pre code,
#md-content pre > code,
#md-content code.hljs {
  display: block;
  padding: 0;
  border-radius: 0;
  font-family: 'Fira Code', 'Consolas', monospace;
  font-size: 16px;
  line-height: 1.5;
  white-space: pre !important;
  word-break: normal !important;
  overflow-wrap: normal !important;
}
#md-content .md-highlight {
  background: linear-gradient(90deg, #ffd700 0%, #ffed4e 100%);
  color: #000;
  padding: 2px 4px;
  border-radius: 3px;
  font-weight: 600;
}
#md-content pre {
  overflow-x: auto;
  max-width: 100%;
  width: 100%;
  margin: 1rem 0;
  background: var(--md-code-bg);
  color: var(--md-code-text);
  border: 0;
  border-radius: 12px;
  border-top: 1px solid var(--md-code-border);
  padding: 1.25rem clamp(1.5rem, 6vw, 2.25rem) 1.5rem;
  box-shadow: var(--md-code-shadow);
  box-sizing: border-box;
}
#md-content .code-block {
  margin: 1.5rem 0;
  border: 1px solid var(--md-code-border);
  border-radius: 12px;
  overflow: hidden;
  background: var(--md-code-shell-bg, var(--md-code-bg));
  box-shadow: var(--md-code-shadow);
  position: relative;
  direction: ltr;
  text-align: left;
}
#md-content .code-block pre {
  margin: 0;
  border-radius: 0;
  border: none;
  border-top: 0;
  box-shadow: none;
}
#md-content .hljs { overflow-x: auto; display: block; }
#md-content .md-code-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.75rem;
  flex-wrap: wrap;
  padding: 0.65rem 1.25rem;
  background: var(--md-code-header-bg);
  color: var(--md-code-header-text);
  font-family: ui-monospace, 'SFMono-Regular', Consolas, monospace;
  font-size: 0.82rem;
  border-bottom: 1px solid var(--md-code-border);
}
#md-content .md-code-lang {
  text-transform: capitalize;
  font-weight: 600;
  letter-spacing: 0.04em;
  color: var(--md-code-lang-text, var(--md-code-header-text));
  background: var(--md-code-lang-bg, color-mix(in srgb, var(--md-code-header-text) 12%, transparent));
  padding: 0.15rem 0.85rem;
  border-radius: 999px;
  display: inline-flex;
  align-items: center;
  text-shadow: none;
}
#md-content .md-copy-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.35rem;
  padding: 0.35rem 0.75rem;
  font-size: 0.9rem;
  border-radius: 6px;
  border: 1px solid var(--md-code-copy-border, transparent);
  background: var(--md-code-copy-bg);
  color: var(--md-code-copy-color);
  cursor: pointer;
  transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
  box-shadow: var(--md-code-copy-shadow, none);
  opacity: 0.9;
}
#md-content .md-copy-btn svg {
  width: 16px;
  height: 16px;
  stroke: currentColor;
  fill: none;
}
#md-content .md-copy-btn .icon-check {
  display: none;
}
#md-content .md-copy-btn:hover,
#md-content .md-copy-btn:focus-visible {
  background: var(--md-code-copy-hover-bg);
  color: var(--md-code-copy-color);
  transform: translateY(-1px);
  outline: 2px solid var(--primary, #8b5cf6);
  outline-offset: 2px;
  opacity: 1;
}
#md-content .md-copy-btn.copied {
  color: var(--md-code-copy-success-color);
  background: color-mix(in srgb, var(--md-code-copy-success-color) 18%, transparent);
  border-color: transparent;
}
#md-content .md-copy-btn.copied .icon-copy {
  display: none;
}
#md-content .md-copy-btn.copied .icon-check {
  display: inline-block;
}
#md-content .md-copy-btn.copy-error {
  color: var(--md-code-copy-error-color);
  background: color-mix(in srgb, var(--md-code-copy-error-color) 20%, transparent);
  border-color: transparent;
}

#md-content code.hljs,
#md-content pre code.hljs {
  background: transparent !important;
  color: var(--hljs-text, var(--md-code-text));
}
#md-content .hljs {
  background: transparent !important;
  color: var(--hljs-text, var(--md-code-text));
}
#md-content .hljs-comment,
#md-content .hljs-quote {
  color: var(--hljs-comment, var(--hljs-text));
  font-style: italic;
}
#md-content .hljs-keyword,
#md-content .hljs-selector-tag,
#md-content .hljs-meta .hljs-keyword,
#md-content .hljs-doctag {
  color: var(--hljs-keyword, var(--hljs-text));
}
#md-content .hljs-string,
#md-content .hljs-regexp,
#md-content .hljs-symbol,
#md-content .hljs-template-tag,
#md-content .hljs-template-variable {
  color: var(--hljs-string, var(--hljs-text));
}
#md-content .hljs-title,
#md-content .hljs-title.class_,
#md-content .hljs-title.function_,
#md-content .hljs-built_in,
#md-content .hljs-attr,
#md-content .hljs-attribute {
  color: var(--hljs-function, var(--hljs-text));
}
#md-content .hljs-number,
#md-content .hljs-literal,
#md-content .hljs-bullet {
  color: var(--hljs-number, var(--hljs-text));
}
#md-content .hljs-variable,
#md-content .hljs-params,
#md-content .hljs-operator,
#md-content .hljs-punctuation {
  color: var(--hljs-operator, var(--hljs-text));
}
#md-content .hljs-addition {
  color: var(--hljs-addition-text, var(--hljs-string, var(--hljs-text)));
  background: var(--hljs-addition-bg, transparent);
}
#md-content .hljs-deletion {
  color: var(--hljs-deletion-text, var(--hljs-keyword, var(--hljs-text)));
  background: var(--hljs-deletion-bg, transparent);
}
#md-content {
  /* לא נחסום גלישה כדי שלא ייחתכו מספרים/תווים מחוץ לקופסה (למשל ברשימות) */
  overflow: visible;
}
/* מניעת גלישה אופקית של טקסט מחוץ לקוד/inline-code */
#md-content p, #md-content li, #md-content blockquote {
  overflow-wrap: anywhere;
  word-break: break-word;
}
/* מרווח נעים בין פסקאות */
#md-content p { margin: 0.75rem 0; }
/* ריווח ברור סביב כותרות משנה כדי למנוע הדבקה לטקסט שלפניהן/אחריהן */
#md-content h2, #md-content h3, #md-content h4 {
  margin-top: 1.25rem;
  margin-bottom: 0.75rem;
}
/* ברשימות ממוספרות/תבליטים ב-RTL המספר/סמל יישב בתוך הבלוק, לא מחוצה לו */
#md-content ol, #md-content ul {
  /* הצגת התבליט/מספור מחוץ לבלוק כדי ליצור הזחה טבעית */
  list-style-position: outside;
  /* ריווח תחתון כדי שלא יידבקו לכותרת/פסקה הבאה */
  margin-block: 0 1rem;
  /* הזחה בצד ההתחלה (RTL: ימין) */
  padding-inline-start: 1.25rem;
}
/* רווח עדין בין פריטי רשימה */
#md-content li { margin: 0.25rem 0; }
/* רשימות מקוננות – מעט רווח מעל/מתחת */
#md-content li > ul, #md-content li > ol { margin-block: 0.25rem 0.5rem; }
#md-content code:not(pre code) {
  background: var(--md-inline-code-bg);
  color: var(--md-inline-code-color);
  border: 1px solid var(--md-inline-code-border);
  padding: 0.2rem 0.4rem;
  border-radius: 6px;
  font-family: 'Fira Code', 'Consolas', monospace;
}
#md-content .md-color-token {
  display: inline-flex;
  align-items: center;
  gap: 0.35em;
  white-space: nowrap;
  font-family: inherit;
  line-height: inherit;
  vertical-align: baseline;
}

#md-content .md-color-token::after {
  content: '';
  display: inline-block;
  width: 0.9em;
  height: 0.9em;
  border-radius: 0.2em;
  border: 1px solid rgba(17, 24, 39, 0.2);
  box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.55) inset;
  background: var(--md-color-swatch, transparent);
  flex-shrink: 0;
}

#md-content code .md-color-token {
  gap: 0.25em;
}

#md-content code .md-color-token::after {
  width: 0.75em;
  height: 0.75em;
}

/* חיווי למופע פעיל בחיפוש */
#md-content .md-highlight.is-active {
  outline: 2px solid #ffd700;
  outline-offset: 1px;
}
/* ציטוטים */
#md-content blockquote {
  margin: 0.75rem 0;
  padding: 0.5rem 0.75rem;
  background: var(--md-blockquote-bg);
  border-inline-start: 4px solid var(--md-blockquote-border);
  color: var(--md-blockquote-color, inherit);
}
/* שם קובץ ארוך – מניעת חריגה במסגרת הכותרת */
#md-file-name-wrap { min-width: 0; }
#md-file-name {
  margin: 0;
  font-size: 1.6rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
  display: block;
}
/* רשימות משימות */
input.md-task-checkbox {
  margin-inline-end: .5rem;
  transform: scale(1.1);
}
/* שיפורי כותרות עם גבולות תחתונים */
#md-content h1 {
  font-size: 2.2em;
  margin-top: 1.5em;
  margin-bottom: 0.5em;
  font-weight: 700;
  border-bottom: 3px solid #e1e4e8;
  padding-bottom: 0.3em;
}

#md-content h2 {
  font-size: 1.8em;
  font-weight: 600;
  border-bottom: 2px solid #e1e4e8;
  padding-bottom: 0.3em;
}

#md-content h3 {
  font-size: 1.4em;
  font-weight: 600;
}

#md-content h4 {
  font-size: 1.2em;
  font-weight: 500;
}

/* שבירת שורות לכותרות ארוכות בתצוגת Markdown */
#md-content h1,
#md-content h2,
#md-content h3,
#md-content h4,
#md-content h5,
#md-content h6 {
  white-space: normal;
  overflow-wrap: anywhere;
  word-break: break-word;
}

/* אנימציות כניסה עדינות */
#md-content > * {
  animation: fadeIn 0.4s ease-in;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* אנימציה מהירה יותר לאלמנטים ספציפיים */
#md-content pre,
#md-content blockquote,
#md-content table {
  animation: fadeIn 0.3s ease-out;
}

@media (prefers-reduced-motion: reduce) {
  /* נטרל אנימציות לכל ילד ישיר */
  #md-content > * { animation: none; }
  /* נטרל גם לכללים הספציפיים יותר כדי לא לעקוף את ההעדפה */
  #md-content pre,
  #md-content blockquote,
  #md-content table { animation: none; }
  /* צמצם גם מעברים לקישורים ואפקט ה-::after שלהם */
  #md-content a,
  #md-content a::after { transition: none; }
}

/* עיצוב משופר לקישורים */
#md-content a {
  color: #0366d6;
  text-decoration: none;
  border-bottom: 1px solid transparent;
  transition: all 0.2s ease;
  position: relative;
}

#md-content a:hover {
  color: #0256c7;
}

/* אפקט hover נוסף אופציונלי - קו תחתון מתרחב */
#md-content a::after {
  content: '';
  position: absolute;
  bottom: -1px;
  left: 50%;
  width: 0;
  height: 1px;
  background: #0366d6;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  transform: translateX(-50%);
}

#md-content a:hover::after {
  width: 100%;
}

/* קישורים בכותרות - ללא קו תחתון */
#md-content h1 a,
#md-content h2 a,
#md-content h3 a {
  border-bottom: none;
}

#md-content h1 a::after,
#md-content h2 a::after,
#md-content h3 a::after {
  display: none;
}

/* קישורי עוגן (permalink) */
#md-content .header-anchor {
  opacity: 0;
  transition: opacity 0.2s;
  margin-left: 0.5em;
  color: #6c757d;
}

#md-content h1:hover .header-anchor,
#md-content h2:hover .header-anchor,
#md-content h3:hover .header-anchor {
  opacity: 1;
}
</style>
<style>
/* === תוכן עניינים צף מתקדם === */
:root {
  --toc-bg-light: linear-gradient(135deg, rgba(255,255,255,0.98) 0%, rgba(250,250,252,0.98) 100%);
  --toc-bg-dark: linear-gradient(135deg, rgba(30,30,40,0.98) 0%, rgba(40,40,50,0.98) 100%);
  --toc-header-gradient: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
  --toc-text-light: #2d3748;
  --toc-text-dark: #e0e0e0;
  --toc-hover-light: color-mix(in srgb, var(--primary) 10%, transparent);
  --toc-hover-dark: color-mix(in srgb, var(--primary) 20%, transparent);
  --toc-active-light: color-mix(in srgb, var(--primary) 15%, transparent);
  --toc-active-dark: color-mix(in srgb, var(--primary) 25%, transparent);
  /* theme-derived accent transparencies */
  --accent-05: color-mix(in srgb, var(--primary) 5%, transparent);
  --accent-10: color-mix(in srgb, var(--primary) 10%, transparent);
  --accent-20: color-mix(in srgb, var(--primary) 20%, transparent);
  --accent-30: color-mix(in srgb, var(--primary) 30%, transparent);
  --accent-35: color-mix(in srgb, var(--primary) 35%, transparent);
  --accent-40: color-mix(in srgb, var(--primary) 40%, transparent);
  --md-toc-mini-bg: var(--card-bg, var(--glass, rgba(255, 255, 255, 0.92)));
  --md-toc-mini-hover-bg: var(--bg-tertiary, var(--glass-hover, rgba(255, 255, 255, 0.98)));
  --md-toc-mini-border: var(--card-border, var(--glass-border, rgba(0, 0, 0, 0.12)));
  --md-toc-mini-shadow: 0 4px 14px rgba(15, 23, 42, 0.15);
  --md-toc-surface: var(--toc-bg-light);
  --md-toc-border: rgba(255, 255, 255, 0.3);
  --md-toc-text: var(--toc-text-light);
  --md-toc-hover: var(--toc-hover-light);
  --md-toc-active: var(--toc-active-light);
  --md-toc-control-bg: var(--glass, rgba(255,255,255,0.2));
  --md-toc-shadow:
    0 10px 40px rgba(0,0,0,0.12),
    0 2px 10px rgba(0,0,0,0.06),
    inset 0 1px 0 rgba(255,255,255,0.5);
}

:root[data-theme="dark"],
:root[data-theme="dim"],
:root[data-theme="nebula"] {
  --md-toc-surface: var(--toc-bg-dark);
  --md-toc-border: rgba(255, 255, 255, 0.1);
  --md-toc-text: var(--toc-text-dark);
  --md-toc-hover: var(--toc-hover-dark);
  --md-toc-active: var(--toc-active-dark);
  --md-toc-control-bg: rgba(255, 255, 255, 0.12);
  --md-toc-mini-bg: var(--card-bg);
  --md-toc-mini-border: var(--card-border);
  --md-toc-mini-shadow: 0 12px 32px rgba(0, 0, 0, 0.45);
  --md-toc-shadow:
    0 10px 40px rgba(0,0,0,0.5),
    0 2px 10px rgba(0,0,0,0.3);
}

:root[data-theme="rose-pine-dawn"] {
  --md-toc-surface: var(--card-bg);
  --md-toc-border: var(--card-border);
  --md-toc-text: var(--text-primary);
  --md-toc-hover: color-mix(in srgb, var(--bg-tertiary) 70%, rgba(0,0,0,0.04));
  --md-toc-active: color-mix(in srgb, var(--bg-secondary) 65%, rgba(0,0,0,0.08));
  --md-toc-control-bg: var(--bg-secondary);
  --md-toc-mini-bg: var(--card-bg);
  --md-toc-mini-border: var(--card-border);
  --md-toc-mini-shadow: 0 6px 20px rgba(149, 121, 166, 0.25);
  --md-toc-shadow:
    0 8px 24px rgba(149, 121, 166, 0.3),
    inset 0 1px 0 rgba(255,255,255,0.6);
}

/* Custom/Shared themes - TOC uses theme variables for consistent dark appearance */
:root[data-theme="custom"],
:root[data-theme^="shared:"] {
  --md-toc-surface: var(--card-bg, var(--toc-bg-dark));
  --md-toc-border: var(--card-border, rgba(255, 255, 255, 0.1));
  --md-toc-text: var(--text-primary, var(--toc-text-dark));
  --md-toc-hover: color-mix(in srgb, var(--primary, #6366f1) 20%, transparent);
  --md-toc-active: color-mix(in srgb, var(--primary, #6366f1) 25%, transparent);
  --md-toc-control-bg: var(--glass, rgba(255, 255, 255, 0.12));
  --md-toc-mini-bg: var(--card-bg, var(--bg-secondary));
  --md-toc-mini-border: var(--card-border, var(--glass-border));
  --md-toc-mini-hover-bg: var(--bg-tertiary, var(--glass-hover));
  --md-toc-mini-shadow: 0 12px 32px rgba(0, 0, 0, 0.45);
  --md-toc-shadow:
    0 10px 40px rgba(0,0,0,0.5),
    0 2px 10px rgba(0,0,0,0.3);
}

.md-toc {
  position: fixed;
  top: 100px;
  left: 20px;
  max-width: 320px;
  min-width: 250px;
  max-height: calc(100vh - 140px);
  background: var(--md-toc-surface);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border-radius: 16px;
  box-shadow: var(--md-toc-shadow);
  border: 1px solid var(--md-toc-border);
  z-index: 970;
  overflow: hidden;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* כותרת עם gradient */
.md-toc-header {
  padding: 1rem;
  background: var(--toc-header-gradient);
  color: white;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative;
  user-select: none;
}

.md-toc-title-wrapper {
  flex: 1;
}

.md-toc-title-wrapper h3 {
  margin: 0;
  font-size: 1.1rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: 600;
}

/* פס התקדמות */
.md-toc-progress {
  height: 3px;
  background: rgba(255,255,255,0.2);
  border-radius: 2px;
  margin-top: 0.5rem;
  overflow: hidden;
}

.md-toc-progress-bar {
  height: 100%;
  background: rgba(255,255,255,0.9);
  border-radius: 2px;
  width: 0%;
  transition: width 0.3s ease;
  box-shadow: 0 0 10px rgba(255,255,255,0.5);
}

/* כפתורי בקרה */
.md-toc-controls {
  display: flex;
  gap: 0.5rem;
}

.md-toc-toggle,
.md-toc-search-btn {
  background: var(--md-toc-control-bg);
  border: 1px solid color-mix(in srgb, var(--md-toc-border) 60%, rgba(255,255,255,0.25));
  border-radius: 8px;
  padding: 0.4rem 0.6rem;
  cursor: pointer;
  color: var(--md-toc-text);
  transition: all 0.2s ease;
}

.md-toc-toggle:hover,
.md-toc-search-btn:hover {
  background: color-mix(in srgb, var(--md-toc-control-bg) 70%, rgba(255,255,255,0.2));
  transform: scale(1.05);
}

.md-toc-toggle:active,
.md-toc-search-btn:active {
  transform: scale(0.95);
}

.md-toc-toggle i {
  transition: transform 0.3s ease;
}

.md-toc.collapsed .md-toc-toggle i {
  transform: rotate(180deg);
}

/* תיבת חיפוש */
.md-toc-search-container {
  padding: 0.75rem;
  background: var(--accent-05);
  border-bottom: 1px solid var(--accent-20);
}

.md-toc-search-input {
  width: 100%;
  padding: 0.5rem;
  border: 1px solid color-mix(in srgb, var(--md-toc-border) 65%, var(--accent-30));
  border-radius: 8px;
  background: color-mix(in srgb, var(--md-toc-surface) 70%, rgba(255,255,255,0.25));
  color: var(--md-toc-text);
  font-size: 0.9rem;
  transition: all 0.2s ease;
}

.md-toc-search-input:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px var(--accent-10);
}

.md-toc-search-results {
  display: block;
  margin-top: 0.25rem;
  font-size: 0.75rem;
  color: var(--primary);
  text-align: center;
}

/* אזור ניווט עם גלילה */
.md-toc-nav {
  padding: 0.5rem 0;
  overflow-y: auto;
  max-height: calc(100vh - 240px);
  scrollbar-width: thin;
  scrollbar-color: var(--primary) transparent;
  position: relative;
}

.md-toc-nav::-webkit-scrollbar {
  width: 6px;
}

.md-toc-nav::-webkit-scrollbar-thumb {
  background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
  border-radius: 3px;
}

.md-toc-nav::-webkit-scrollbar-track {
  background: transparent;
}

/* פריטי תוכן עניינים */
.md-toc-item {
  padding: 0.6rem 1rem;
  cursor: pointer;
  color: var(--md-toc-text);
  transition: all 0.2s ease;
  border-right: 3px solid transparent;
  font-size: 0.9rem;
  display: block;
  text-decoration: none;
  position: relative;
  overflow: hidden;
}

/* Custom/Shared themes - override global link color for TOC items */
[data-theme="custom"] .md-toc-item,
[data-theme^="shared:"] .md-toc-item {
  color: var(--md-toc-text);
}

[data-theme="custom"] .md-toc-item:hover,
[data-theme^="shared:"] .md-toc-item:hover {
  color: var(--md-toc-text);
}

[data-theme="custom"] .md-toc-item.active,
[data-theme^="shared:"] .md-toc-item.active {
  color: var(--primary);
}

/* אפקט hover מתקדם */
.md-toc-item::before {
  content: '';
  position: absolute;
  right: 0;
  top: 0;
  height: 100%;
  width: 3px;
  background: var(--toc-header-gradient);
  transform: translateX(100%);
  transition: transform 0.3s ease;
}

.md-toc-item:hover {
  background: var(--md-toc-hover);
  padding-right: 1.25rem;
}

.md-toc-item:hover::before,
.md-toc-item.active::before {
  transform: translateX(0);
}

.md-toc-item.active {
  background: var(--md-toc-active);
  color: var(--primary);
  font-weight: 600;
}

/* הדגשת חיפוש */
.md-toc-item.search-match {
  background: rgba(255, 235, 59, 0.2);
}

.md-toc-item.search-match mark {
  background: rgba(255, 235, 59, 0.5);
  color: inherit;
  padding: 0 2px;
  border-radius: 2px;
}

/* הסתרה בחיפוש */
.md-toc-item.search-hidden {
  display: none;
}

/* הזחה לפי רמת כותרת */
.md-toc-item[data-level="1"] { padding-right: 1rem; font-weight: 600; }
.md-toc-item[data-level="2"] { padding-right: 1.25rem; }
.md-toc-item[data-level="3"] { padding-right: 2rem; font-size: 0.85rem; }
.md-toc-item[data-level="4"] { padding-right: 2.75rem; font-size: 0.8rem; }
.md-toc-item[data-level="5"] { padding-right: 3.5rem; font-size: 0.75rem; }
.md-toc-item[data-level="6"] { padding-right: 4.25rem; font-size: 0.75rem; }

/* מצב מכווץ */
.md-toc.collapsed {
  max-height: 60px;
}

.md-toc.collapsed .md-toc-nav,
.md-toc.collapsed .md-toc-search-container {
  display: none;
}

.md-toc.collapsed .md-toc-progress {
  margin-top: 0.25rem;
}

/* מצב מינימלי */
.md-toc.minimized {
  display: none;
}

.md-toc-mini-btn {
  position: fixed;
  top: 100px;
  left: 12px;  /* בצד שמאל של המסך */
  width: 44px;
  height: 44px;
  border-radius: 12px;
  background: var(--md-toc-mini-bg);
  color: var(--text-primary, #1f2933);
  border: 1px solid var(--md-toc-mini-border);
  cursor: pointer;
  box-shadow: var(--md-toc-mini-shadow);
  transition: transform 0.15s ease, box-shadow 0.2s ease;
  z-index: 1000;
  touch-action: none; /* מאפשר גרירה חלקה במובייל */
}

.md-toc-mini-btn:hover {
  transform: scale(1.1);
  background: var(--md-toc-mini-hover-bg);
  box-shadow: 0 6px 20px rgba(15, 23, 42, 0.22);
  color: var(--primary, currentColor);
}

/* Virtual Scrolling - פריט placeholder */
.md-toc-item-placeholder {
  height: 32px;
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: loading 1.5s infinite;
  margin: 0.25rem 1rem;
  border-radius: 4px;
}

@keyframes loading {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

/* התאמה למסכים קטנים */
@media (max-width: 1024px) {
  .md-toc {
    left: 10px;
    max-width: 280px;
    min-width: 220px;
    font-size: 0.85rem;
  }
  
  .md-toc-item {
    padding: 0.5rem 0.75rem;
  }
}

@media (max-width: 768px) {
  /* במובייל: הסתרת הפאנל והצגת כפתור מינימלי לפתיחה */
  .md-toc { display: none; }
  .md-toc-mini-btn { display: block; }
}

/* במסך מלא - הסתר */
#mdCard:fullscreen ~ .md-toc,
#mdCard:-webkit-full-screen ~ .md-toc,
#mdCard:fullscreen ~ .md-toc-mini-btn,
#mdCard:-webkit-full-screen ~ .md-toc-mini-btn {
  display: none !important;
}

/* אנימציות נוספות */
@keyframes slideIn {
  from {
    transform: translateX(-100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.md-toc {
  animation: slideIn 0.3s ease-out;
}

/* Tooltip לכותרות ארוכות */
.md-toc-item[title] {
  position: relative;
}

.md-toc-item[title]:hover::after {
  content: attr(title);
  position: absolute;
  right: calc(100% + 10px);
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0,0,0,0.8);
  color: white;
  padding: 0.5rem;
  border-radius: 6px;
  white-space: nowrap;
  font-size: 0.85rem;
  z-index: 1000;
  max-width: 300px;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* === "העתק כמארקדאון" — כפתור צף להעתקת קטע מסומן === */
#mdCard {
  position: relative;
}

.md-copy-selection-fab {
  position: absolute;
  z-index: 9999;
  display: none;
  align-items: center;
  gap: 6px;
  padding: 8px 16px;
  border-radius: 10px;
  border: 1px solid rgba(0, 0, 0, 0.12);
  background: #ffffff;
  color: #1f2937;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.18);
  transition: background 0.15s ease, transform 0.15s ease;
  white-space: nowrap;
  pointer-events: auto;
  font-family: inherit;
  direction: rtl;
}

.md-copy-selection-fab:hover {
  background: #f3f4f6;
  transform: translateY(-1px);
}

.md-copy-selection-fab.is-visible {
  display: inline-flex;
}

.md-copy-selection-fab.is-copied {
  background: #ecfdf5;
  color: #065f46;
  border-color: #a7f3d0;
}

[data-theme="dark"] .md-copy-selection-fab,
[data-theme="dim"] .md-copy-selection-fab,
[data-theme="nebula"] .md-copy-selection-fab {
  background: #1e293b;
  color: #e2e8f0;
  border-color: rgba(255, 255, 255, 0.15);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
}

[data-theme="dark"] .md-copy-selection-fab:hover,
[data-theme="dim"] .md-copy-selection-fab:hover,
[data-theme="nebula"] .md-copy-selection-fab:hover {
  background: #334155;
}

[data-theme="dark"] .md-copy-selection-fab.is-copied,
[data-theme="dim"] .md-copy-selection-fab.is-copied,
[data-theme="nebula"] .md-copy-selection-fab.is-copied {
  background: #064e3b;
  color: #6ee7b7;
  border-color: #065f46;
}
</style>
{% endblock %}

{% block content %}
<div id="md-root">
  <div class="file-header" style="display:flex;justify-content:space-between;align-items:center;gap:1rem;flex-wrap:wrap;margin-bottom:1rem;">
    <div style="display:flex;align-items:center;gap:.75rem;min-width:0;">
      <span style="font-size:2rem;">📝</span>
      <div id="md-file-name-wrap">
        <h1 id="md-file-name">{{ file.file_name }}</h1>
        <div class="muted" style="margin-top:.25rem;">Markdown</div>
      </div>
    </div>
  <div class="file-actions" style="display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;">
      {% if not is_public %}
      <a href="#" onclick="return goBackToFile(event)" class="btn btn-secondary btn-icon">↩️ חזרה לתצוגת קוד</a>
      <a href="#" onclick="return goBackTwoSteps(event)" class="btn btn-secondary btn-icon" title="חזור למסך קודם"><i class="fas fa-arrow-right"></i> חזור</a>
      <!-- מפריד ויזואלי -->
      <span style="width:1px;height:24px;background:var(--glass-border,rgba(255,255,255,0.2));margin:0 0.25rem;"></span>
      <!-- כפתור ערוך - רק למשתמשים מחוברים -->
      <a href="/edit/{{ file.id }}"
         class="btn btn-secondary btn-icon"
         title="ערוך">
        <i class="fas fa-edit"></i>
        <span class="btn-text">ערוך</span>
      </a>
      {% endif %}
      <!-- כפתור העתק קוד - זמין לכל המשתמשים -->
      <button id="mdCopySourceBtn"
              type="button"
              class="btn btn-secondary btn-icon"
              title="העתק קוד"
              aria-label="העתק קוד"
              onclick="return copyMarkdownSource(event)">
        <i class="fas fa-copy"></i>
        <span class="btn-text">העתק קוד</span>
      </button>
    </div>
  </div>

  <div class="glass-card" id="mdCard" style="padding:1rem;">
    <div class="section-header" style="display:flex;justify-content:space-between;align-items:center;gap:1rem;margin-bottom:.5rem;flex-wrap:wrap;">
      <div class="section-title-wrap" style="display:flex;align-items:center;gap:.5rem;flex-wrap:wrap;">
        <h2 class="section-title" style="margin:0;display:flex;align-items:center;gap:.5rem;">
          <i class="fas fa-file-alt"></i>
          תצוגת Markdown
        </h2>
        <!-- כפתור החלפת צבעי רקע הועבר לכותרת כדי למנוע חפיפה בטאבלט -->
        <div id="bgColorSwitcher">
          <button id="bgColorBtn" class="btn btn-secondary btn-icon" style="background:rgba(255,255,255,0.95);color:#333;border:1px solid #ddd;box-shadow:0 2px 8px rgba(0,0,0,0.15);padding:8px 16px;border-radius:8px;font-size:14px;cursor:pointer;transition:all 0.2s ease;" title="החלף צבע רקע">
            <span style="display:inline-block;width:16px;height:16px;border-radius:50%;background:#ffffff;border:2px solid #333;vertical-align:middle;margin-left:6px;"></span>
            צבע רקע
          </button>
          <div id="bgColorOptions" style="display:none;position:absolute;top:100%;left:50%;transform:translateX(-50%);margin-top:5px;background:white;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.2);padding:10px;white-space:nowrap;">
            <button class="bg-color-option" data-color="sepia" style="display:block;width:100%;padding:8px 12px;margin:4px 0;border:1px solid #ddd;border-radius:6px;background:#fdf6e3;color:#333;cursor:pointer;font-size:14px;transition:all 0.2s ease;">
              <span style="display:inline-block;width:20px;height:20px;border-radius:4px;background:#fdf6e3;border:1px solid #999;vertical-align:middle;margin-left:8px;"></span>
              נייר חם
            </button>
            <button class="bg-color-option" data-color="light" style="display:block;width:100%;padding:8px 12px;margin:4px 0;border:1px solid #ddd;border-radius:6px;background:#f5e6d3;color:#333;cursor:pointer;font-size:14px;transition:all 0.2s ease;">
              <span style="display:inline-block;width:20px;height:20px;border-radius:4px;background:#f5e6d3;border:1px solid #999;vertical-align:middle;margin-left:8px;"></span>
              חום בהיר
            </button>
            <button class="bg-color-option" data-color="medium" style="display:block;width:100%;padding:8px 12px;margin:4px 0;border:1px solid #ddd;border-radius:6px;background:#e8d4b0;color:#333;cursor:pointer;font-size:14px;transition:all 0.2s ease;">
              <span style="display:inline-block;width:20px;height:20px;border-radius:4px;background:#e8d4b0;border:1px solid #999;vertical-align:middle;margin-left:8px;"></span>
              חום בינוני
            </button>
            <button class="bg-color-option" data-color="dark" style="display:block;width:100%;padding:8px 12px;margin:4px 0;border:1px solid #ddd;border-radius:6px;background:#d4b896;color:#333;cursor:pointer;font-size:14px;transition:all 0.2s ease;">
              <span style="display:inline-block;width:20px;height:20px;border-radius:4px;background:#d4b896;border:1px solid #999;vertical-align:middle;margin-left:8px;"></span>
              חום כהה
            </button>
          </div>
        </div>
      </div>
      <div class="md-toolbar-actions" style="display:flex;gap:0.5rem;align-items:center;flex-wrap:wrap;">
        {% if is_public %}
        <a id="mdReaderModeBtn"
           class="btn btn-secondary btn-icon md-reader-mode-btn"
           href="{{ url_for('public_reader_mode', share_id=file.id) }}"
           target="_blank"
           rel="noopener noreferrer"
           title="פתח במצב קריאה">📖</a>
        {% else %}
        <a id="mdReaderModeBtn"
           class="btn btn-secondary btn-icon md-reader-mode-btn"
           href="{{ url_for('reader_mode', filename=file.file_name) }}"
           target="_blank"
           rel="noopener noreferrer"
           title="פתח במצב קריאה">📖</a>
        {% endif %}
      </div>
    </div>
    <!-- Editor Toolbar - עיצוב חדש -->
    <div class="md-editor-toolbar" id="md-search">
      <div class="md-search-capsule">
        <input type="text" class="md-search-input" id="mdSearchInput" placeholder="חפש בקוד...">
        <span class="md-search-count" id="mdSearchCount"></span>
        <div class="md-divider"></div>
        <button class="md-icon-btn" id="mdSearchPrev" type="button" title="הקודם">▲</button>
        <button class="md-icon-btn" id="mdSearchNext" type="button" title="הבא">▼</button>
        <button class="md-icon-btn" id="mdSearchClear" type="button" title="נקה">✕</button>
      </div>
      <button class="md-fullscreen-btn" id="mdFullscreenBtn2" type="button" title="מסך מלא">
        <i class="fas fa-expand"></i>
        <span>מסך מלא</span>
      </button>
    </div>
    <div id="md-content" style="margin-inline:-4px;width:calc(100% + 8px);"></div>
    <button type="button"
            id="mdCopySelectionFab"
            class="md-copy-selection-fab"
            aria-label="העתק כמארקדאון">
      <i class="fas fa-copy" aria-hidden="true"></i>
      <span class="md-copy-selection-fab__label">העתק כמארקדאון</span>
    </button>
  </div>

  <!-- תוכן עניינים צף מתקדם עם כל הפיצ'רים (ממוקם אחרי #mdCard כדי שכללי CSS של fullscreen יעבדו) -->
  <div id="mdToc" class="md-toc" style="display:none;"
       role="navigation"
       aria-label="תוכן עניינים של המסמך">

    <!-- כותרת עם אינדיקטור התקדמות -->
    <div class="md-toc-header">
      <div class="md-toc-title-wrapper">
        <h3 id="toc-heading">
          <i class="fas fa-list" aria-hidden="true"></i>
          תוכן עניינים
        </h3>
        <div class="md-toc-progress" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
          <div class="md-toc-progress-bar" id="tocProgressBar"></div>
        </div>
      </div>
      <div class="md-toc-controls">
        <button id="mdTocSearch"
                class="md-toc-search-btn"
                aria-label="חפש בכותרות"
                title="חיפוש (Ctrl+F)">
          <i class="fas fa-search" aria-hidden="true"></i>
        </button>
        <!-- סמל תפריט (☰) – לחיצה ארוכה תמזער את הפאנל -->
        <button id="mdTocMenuBtn"
                class="md-toc-toggle"
                aria-label="מזעור התפריט בלחיצה ארוכה"
                title="לחיצה ארוכה: מזער (☰)">
          <i class="fas fa-bars" aria-hidden="true"></i>
        </button>
        <button id="mdTocToggle"
                class="md-toc-toggle"
                aria-controls="mdTocNav"
                aria-expanded="true"
                aria-labelledby="toc-heading"
                title="כווץ או הרחב (Ctrl+T)">
          <i class="fas fa-chevron-up" aria-hidden="true"></i>
        </button>
      </div>
    </div>

    <!-- תיבת חיפוש (מוסתרת בהתחלה) -->
    <div class="md-toc-search-container" id="tocSearchContainer" style="display:none;">
      <input type="search"
             id="tocSearchInput"
             class="md-toc-search-input"
             placeholder="חפש בכותרות..."
             aria-label="חיפוש בתוכן העניינים">
      <span class="md-toc-search-results" id="tocSearchResults"></span>
    </div>

    <!-- אזור הניווט עם Virtual Scrolling -->
    <nav id="mdTocNav"
         class="md-toc-nav"
         aria-labelledby="toc-heading"
         role="list">
      <!-- כאן יוכנסו הכותרות דינמית -->
    </nav>
  </div>
  <!-- כפתור מינימלי צף (מחוץ לפאנל) -->
  <button id="mdTocMini"
          class="md-toc-mini-btn"
          style="display:none;"
          aria-label="הצג תוכן עניינים"
          title="הצג תוכן עניינים">
    <i class="fas fa-bars"></i>
  </button>

  {% if not is_public %}
  <div class="glass-card" style="margin-top: 1rem;">
    <h2 class="section-title">
      <i class="fas fa-share-alt"></i>
      שיתוף
    </h2>
    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
      <button onclick="shareToTelegramMd()" class="btn btn-secondary btn-icon">
        <i class="fab fa-telegram"></i>
        שתף בטלגרם
      </button>
      <button onclick="openShareLinkModalMd()" class="btn btn-secondary btn-icon">
        <i class="fas fa-link"></i>
        העתק קישור
      </button>
    </div>
  </div>

  <div id="shareLinkModalMd" class="share-link-modal" role="dialog" aria-modal="true" aria-labelledby="shareLinkMdTitle" hidden>
    <div class="share-link-modal__content" role="document">
      <h3 id="shareLinkMdTitle" class="share-link-modal__title">בחרו סוג קישור</h3>
      <p class="share-link-modal__subtitle">אפשר ליצור קישור זמני (פג תוקף אוטומטית) או קישור קבוע ללא תפוגה.</p>
      <div class="share-link-modal__actions">
        <button type="button" class="btn btn-primary" onclick="copyShareLinkMd(false)">
          <i class="fas fa-clock"></i>
          קישור זמני
        </button>
        <button type="button" class="btn btn-secondary" onclick="copyShareLinkMd(true)">
          <i class="fas fa-infinity"></i>
          קישור קבוע
        </button>
      </div>
      <button type="button" class="share-link-modal__close" onclick="closeShareLinkModalMd()" aria-label="סגור">✕</button>
    </div>
  </div>

  <style>
  .share-link-modal {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.55);
    z-index: 9999;
  }
  .share-link-modal[hidden] {
    display: none;
  }
  .share-link-modal__content {
    background: #1f2a44;
    border-radius: 16px;
    padding: 1.5rem;
    max-width: 420px;
    width: calc(100% - 2rem);
    color: #fff;
    position: relative;
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
  }
  .share-link-modal__title {
    margin: 0 0 0.5rem;
    font-size: 1.3rem;
  }
  .share-link-modal__subtitle {
    margin: 0 0 1.25rem;
    color: rgba(255, 255, 255, 0.8);
  }
  .share-link-modal__actions {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
  }
  .share-link-modal__actions .btn {
    flex: 1 1 150px;
  }
  .share-link-modal__close {
    position: absolute;
    top: 0.75rem;
    left: 0.75rem;
    background: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    font-size: 1.1rem;
    cursor: pointer;
  }
  .share-link-modal__close:hover,
  .share-link-modal__close:focus {
    color: #fff;
  }
  </style>
  {% endif %}
{% if can_save_shared %}
<div class="glass-card" style="margin-top: 1rem;">
  <h2 class="section-title">
    <i class="fas fa-floppy-disk"></i>
    שמור בקבצים שלי
  </h2>
  <p style="margin-bottom: 1rem;">לחיצה על הכפתור תשמור את הקובץ הזה בחשבון שלך.</p>
  <button id="saveSharedFileBtn"
          class="btn btn-primary btn-icon"
          data-share-id="{{ file.id }}"
          data-file-name="{{ file.file_name }}">
    <i class="fas fa-save"></i>
    💾 שמור בקבצים שלי
  </button>
</div>
{% endif %}
  <script type="application/json" id="mdText">{{ md_code | tojson | safe }}</script>
  <script>
    // חשוף מזהה קובץ לשימוש רכיבי אינטראקציה (פתקים דביקים וכו')
    window.FILE_ID = "{{ file.id }}";
  </script>
</div>

<script>
// מזהה קובץ לשימוש בשמירת העדפות פר-קובץ
const FILE_ID = "{{ file.id }}";
const FILE_VIEW_URL = "{{ url_for('view_file', file_id=file.id) }}";
const saveSharedButton = document.getElementById('saveSharedFileBtn');
if (saveSharedButton) {
  const originalHtml = saveSharedButton.innerHTML;
  const shareId = saveSharedButton.getAttribute('data-share-id') || '';
  const fileName = saveSharedButton.getAttribute('data-file-name') || '';
  const markSuccess = () => {
    saveSharedButton.innerHTML = '✅ נשמר בהצלחה';
    saveSharedButton.disabled = true;
  };
  saveSharedButton.addEventListener('click', async (event) => {
    event.preventDefault();
    if (saveSharedButton.dataset.loading === '1') {
      return;
    }
    saveSharedButton.dataset.loading = '1';
    saveSharedButton.disabled = true;
    try {
      const resp = await fetch('/api/shared/save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ share_id: shareId, file_name: fileName })
      });
      const data = await resp.json().catch(() => ({}));
      if (!resp.ok || !data || data.ok !== true) {
        throw new Error((data && data.error) || 'שמירת המדריך נכשלה');
      }
      markSuccess();
    } catch (err) {
      console.error('saveSharedGuide', err);
      alert((err && err.message) ? err.message : 'שמירת המדריך נכשלה');
      saveSharedButton.innerHTML = originalHtml;
      saveSharedButton.disabled = false;
    } finally {
      saveSharedButton.dataset.loading = '0';
    }
  });
}

// תוכן ה-Markdown מועבר בבטחה JSON-encoded
const MD_TEXT = (function(){
  try {
    var el = document.getElementById('mdText');
    if (!el) return "";
    return JSON.parse(el.textContent || '""');
  } catch(_) { return ""; }
})();

// שמירת מצב רשימות משימות (לפי קובץ) ב-localStorage
const STORAGE_KEY = `md_tasks_state:{{ file.id }}`;
function loadTaskState(){
  try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); }catch(_){ return {}; }
}
function saveTaskState(state){
  try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state || {})); }catch(_){ }
}
const taskState = loadTaskState();

// טעינת bundle מקומי (ללא CDN)
const BUNDLE = {
  js: "{{ url_for('static', filename='js/md_preview.bundle.js') }}",
  css: "{{ url_for('static', filename='css/md_preview.bundle.css') }}"
};

// תאימות לאחור: מפה "CDN" לערכים מקומיים כך שלא נדרש רשת
const CDN = {
  md: BUNDLE.js,
  mdEmoji: null,
  mdTask: null,
  mdAnchor: null,
  mdFootnote: null,
  mdTocDone: null,
  mdContainer: null,
  mdAdmonition: null,
  hljs: null,
  hljsCss: BUNDLE.css,
  katexCss: BUNDLE.css,
  katexJs: null,
  katexAuto: null,
  mermaid: null
};

// Slug יציב בסגנון GitHub – שומר על התאמה לתוכן עניינים ידני גם בכותרות רב־לשוניות
function slugifyHeadingId(rawText) {
  try {
    let slug = (rawText || '')
      .toString()
      .trim()
      .toLowerCase()
      .normalize('NFKD')
      // ניקוי סימנים בלתי מודפסים/RTL וכדומה
      .replace(/[\u200B-\u200D\uFEFF]/g, '')
      // הסרת סימני ניקוד לאחר נרמול (כמו á -> a)
      .replace(/\p{M}+/gu, '')
      // השארת אותיות (מכל שפה), ספרות, רווחים ומקפים בטוחים
      .replace(/[^\p{L}\p{N}\s-]+/gu, '')
      // המרה של רווחים רצופים למקף יחיד
      .replace(/\s+/g, '-')
      // ביטול ריבוי מקפים רצופים
      .replace(/-{2,}/g, '-')
      // הסרת מקפים מובילים או מסיימים שנוצרו לאחר הניקוי
      .replace(/^-+|-+$/g, '');

    // אין מצב שנשאיר עוגן ריק – נספק ברירת מחדל יציבה
    if (!slug) {
      slug = 'section';
    }

    return slug;
  } catch (_) {
    // במקרה נדיר של שגיאת RegExp בדפדפן ישן, נ fallback לשיטה בסיסית
    const safe = (rawText || '')
      .toString()
      .trim()
      .toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-]/g, '') || 'section';
    return safe;
  }
}

function injectCss(href){
  if (!href) return;
  try {
    if (document.querySelector('link[rel="stylesheet"][href="' + href + '"]')) return;
  } catch(_) {}
  const l = document.createElement('link');
  l.rel = 'stylesheet';
  l.href = href;
  document.head.appendChild(l);
}
function loadScript(src){
  return new Promise((res, rej) => {
    if (!src) { res(); return; }
    try {
      if (document.querySelector('script[src="' + src + '"]')) { res(); return; }
    } catch(_) {}
    const s = document.createElement('script');
    s.src = src;
    s.defer = true;
    s.onload = res;
    s.onerror = rej;
    document.head.appendChild(s);
  });
}

function attachColorSwatches(root){
  if (!root || !root.querySelector) return;
  const BASE_REGEX = /#(?:[0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})\b|(?:rgb|rgba|hsl|hsla)\s*\([^\)]+\)/gi;
  const SKIP_TAGS = new Set(['SCRIPT','STYLE','NOSCRIPT','TEMPLATE']);
  const supportsCssSupports = typeof CSS !== 'undefined' && typeof CSS.supports === 'function';
  const colorProbe = document.createElement('span');

  function isRenderableColor(str) {
    if (!str) return false;
    try {
      if (supportsCssSupports && CSS.supports('color', str)) {
        return true;
      }
    } catch(_) {}
    try {
      colorProbe.style.color = '';
      colorProbe.style.color = str;
      return !!colorProbe.style.color;
    } catch(_) {
      return false;
    }
  }
  let walker;
  try {
    walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
      acceptNode(node) {
        if (!node || !node.nodeValue) return NodeFilter.FILTER_REJECT;
        if (!node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
        const parent = node.parentElement;
        if (!parent) return NodeFilter.FILTER_REJECT;
        if (parent.closest('[data-md-color-token]')) return NodeFilter.FILTER_REJECT;
        if (parent.closest('pre')) return NodeFilter.FILTER_REJECT;
        if (SKIP_TAGS.has(parent.tagName)) return NodeFilter.FILTER_REJECT;
        const tester = new RegExp(BASE_REGEX.source, BASE_REGEX.flags);
        return tester.test(node.nodeValue) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
      }
    });
  } catch(_) {
    return;
  }

  const textNodes = [];
  let current;
  while ((current = walker.nextNode())) {
    textNodes.push(current);
  }
  if (!textNodes.length) return;

  textNodes.forEach(node => {
    const value = node && node.nodeValue;
    if (!value) return;
    const regex = new RegExp(BASE_REGEX.source, BASE_REGEX.flags);
    const matches = Array.from(value.matchAll(regex));
    if (!matches.length) return;

    const frag = document.createDocumentFragment();
    let cursor = 0;
    for (const match of matches) {
      const rawMatch = (match && match[0]) || '';
      const idx = typeof match?.index === 'number' ? match.index : value.indexOf(rawMatch, cursor);
      const safeIndex = idx < 0 ? cursor : idx;
      if (safeIndex > cursor) {
        frag.appendChild(document.createTextNode(value.slice(cursor, safeIndex)));
      }
      const trimmed = rawMatch.trim();
      if (!trimmed || !isRenderableColor(trimmed)) {
        frag.appendChild(document.createTextNode(rawMatch));
        cursor = safeIndex + rawMatch.length;
        continue;
      }
      const token = document.createElement('span');
      token.className = 'md-color-token';
      token.setAttribute('data-md-color-token', '1');
      token.dataset.mdColor = trimmed;
      token.title = trimmed;
      token.textContent = trimmed;
      token.style.setProperty('--md-color-swatch', trimmed);
      frag.appendChild(token);
      cursor = safeIndex + rawMatch.length;
    }
    if (cursor < value.length) {
      frag.appendChild(document.createTextNode(value.slice(cursor)));
    }
    if (node.parentNode) {
      node.parentNode.replaceChild(frag, node);
    }
  });
}

try { if (typeof window !== 'undefined') { window.attachColorSwatches = attachColorSwatches; } } catch(_) {}

(async function(){
  try{
    injectCss(CDN.hljsCss);
    injectCss(CDN.katexCss);
    try { await loadScript(CDN.md); } catch(_){}
    try { await loadScript(CDN.mdEmoji); } catch(_){}
    try { await loadScript(CDN.mdTask); } catch(_){}
    try { await loadScript(CDN.mdAnchor); } catch(_){}
    try { await loadScript(CDN.mdFootnote); } catch(_){}
    try { await loadScript(CDN.mdTocDone); } catch(_){}
    try { await loadScript(CDN.mdContainer); } catch(_){}
    try { await loadScript(CDN.mdAdmonition); } catch(_){}
    try { await loadScript(CDN.hljs); } catch(_){}
    try { await loadScript(CDN.katexJs); } catch(_){}
    try { await loadScript(CDN.katexAuto); } catch(_){}
    try { await loadScript(CDN.mermaid); } catch(_){}

    const md = (window.markdownit ? window.markdownit : (()=>({render:(s)=>s})))({
      breaks: true,
      linkify: true,
      typographer: true,
      html: false,
      // לא לבצע הדגשה בשלב ה-render של markdown-it; נבצע post-process עם hljs
      highlight: function (_str, _lang) { return ''; }
    })
    // תמיכה בהדגשת "טוש" בתחביר Markdown: ==טקסט== -> <mark>טקסט</mark>
    ;(function enableMarkdownMark(){
      try {
        function markdownItMarkPlugin(mdInstance) {
          function isSpace(code) {
            return code === 0x20 /* space */ || code === 0x0A /* \n */ || code === 0x09 /* \t */;
          }
          function isEscaped(src, pos) {
            // pos הוא תחילת הסוגריים "==" (כלומר התו הראשון)
            let backslashes = 0;
            let i = pos - 1;
            while (i >= 0 && src.charCodeAt(i) === 0x5C /* \ */) { backslashes += 1; i -= 1; }
            return (backslashes % 2) === 1;
          }
          function tokenize(state, silent) {
            const start = state.pos;
            const max = state.posMax;
            const src = state.src;

            if (start + 4 > max) return false; // מינימום: ==a==
            if (src.charCodeAt(start) !== 0x3D || src.charCodeAt(start + 1) !== 0x3D) return false; // "=="

            const next = src.charCodeAt(start + 2);
            if (isSpace(next)) return false; // לא פותחים הדגשה עם רווח מיד אחרי

            // חיפוש סוגר תואם
            let end = start + 2;
            while (true) {
              end = src.indexOf('==', end);
              if (end < 0 || end + 2 > max) return false;
              if (end === start + 2) { end += 2; continue; } // "====" לא שימושי
              if (isSpace(src.charCodeAt(end - 1))) { end += 2; continue; } // לא סוגרים עם רווח לפני
              if (isEscaped(src, end)) { end += 2; continue; } // סוגר עם escape
              break;
            }

            if (silent) return true;

            // פתיחה
            const open = state.push('mark_open', 'mark', 1);
            open.markup = '==';

            // תוכן פנימי – נותן ל-markdown-it לפרש גם **, _, קישורים וכו'
            const inner = src.slice(start + 2, end);
            state.md.inline.parse(inner, state.md, state.env, state.tokens);

            // סגירה
            const close = state.push('mark_close', 'mark', -1);
            close.markup = '==';

            state.pos = end + 2;
            return true;
          }

          mdInstance.inline.ruler.before('emphasis', 'mark', tokenize);
        }
        md.use(markdownItMarkPlugin);
      } catch(_) {}
    })();
    if (window.markdownitEmoji) md.use(window.markdownitEmoji);
    if (window.markdownitTaskLists) md.use(window.markdownitTaskLists, { label: true, enabled: true });
    // עוגני כותרות – הגדרה יציבה למניעת רגרסיות בין גרסאות התוסף
    if (window.markdownitAnchor) {
      const anchorOptions = { permalink: true, permalinkSymbol: '¶', slugify: slugifyHeadingId };
      try {
        md.use(window.markdownitAnchor, anchorOptions);
      } catch(_) {
        try { md.use(window.markdownitAnchor, { slugify: slugifyHeadingId }); } catch(__) {}
      }
    }
    if (window.markdownitFootnote) md.use(window.markdownitFootnote);
    // תמיכה גם בשמות גלובליים שונים של התוסף (markdown-it-admonition)
    (function(){
      try {
        const admonitionPlugin = (window.markdownitAdmonition || window.markdownItAdmonition || window.markdownItAdmonitionDefault || null);
        if (admonitionPlugin) {
          md.use(admonitionPlugin, {
            types: ['note','tip','warning','danger','info','success','question','example','quote','experimental','deprecated','todo','abstract']
          });
        }
      } catch(_) {}
    })();
    // תמיכה רשמית בתחביר ::: ע"י markdown-it-container עבור כל הסוגים וה-details
    (function(){
      try {
        const containerPlugin = (window.markdownitContainer || window.markdownItContainer || null);
        if (!containerPlugin) return;
        const types = ['details','note','tip','warning','danger','info','success','question','example','quote','experimental','deprecated','todo','abstract'];
        const DEFAULT_TITLES = { note:'הערה', tip:'טיפ', warning:'אזהרה', danger:'סכנה', info:'מידע', success:'הצלחה', question:'שאלה', example:'דוגמה', quote:'ציטוט', experimental:'ניסוי', deprecated:'לא מומלץ', todo:'לעשות', abstract:'תקציר' };
        function defaultTitle(type){ return DEFAULT_TITLES[type] || type; }

        types.forEach(function(type){
          if (type === 'details') {
            md.use(containerPlugin, 'details', {
              validate: function(params){ return /^details\b/i.test((params||'').trim()); },
              render: function(tokens, idx){
                const m = (tokens[idx].info || '').trim().match(/^details\s+(.*)$/i);
                const title = (m && m[1] && m[1].trim()) || 'לחץ להצגה';
                if (tokens[idx].nesting === 1) {
                  return `<details class="markdown-details"><summary class="markdown-summary">${md.utils.escapeHtml(title)}</summary><div class="details-content">`;
                }
                return `</div></details>\n`;
              }
            });
          } else {
            // כרטיסיות הסבר (admonitions) עם ::: tip כותרת
            const rxOpen = new RegExp('^' + type + '\\b\\s*(.*)$', 'i');
            md.use(containerPlugin, type, {
              validate: function(params){ return rxOpen.test((params||'').trim()); },
              render: function(tokens, idx){
                const info = (tokens[idx].info || '').trim();
                const m = info.match(rxOpen);
                const title = (m && m[1] && m[1].trim()) || defaultTitle(type);
                if (tokens[idx].nesting === 1) {
                  return `<div class="admonition admonition-${type}"><div class="admonition-title">${md.utils.escapeHtml(title)}</div><div class="admonition-content">`;
                }
                return `</div></div>\n`;
              }
            });
          }
        });
      } catch(_) {}
    })();
    if (window.markdownitTocDoneRight) {
      try {
        md.use(window.markdownitTocDoneRight, { slugify: slugifyHeadingId });
      } catch(_) {
        try { md.use(window.markdownitTocDoneRight); } catch(__) {}
      }
    }

    // רינדור ראשוני
    const container = document.getElementById('md-content');
    container.innerHTML = md.render(MD_TEXT || '');
    attachColorSwatches(container);
    // בדיקת smoke מהירה: האם ::: tip מומר ל-admonition (לוג בלבד)
    try {
      const smoke = md.render('::: tip בדיקת טיפ\nתוכן\n:::');
      console.info('Admonition(::: tip) supported =', /class="admonition admonition-tip"/.test(smoke));
    } catch(_) {}
    try {
      // השלם מזהי עוגן חסרים והסר כפילויות כדי שסימניות על כותרות יעבדו יציב
      const seen = new Set();
      const gen = (t, el) => {
        const base = slugifyHeadingId(t);
        let candidate = base;
        let idx = 2;
        while (seen.has(candidate) || (document.getElementById(candidate) && document.getElementById(candidate) !== el)) {
          candidate = `${base}-${idx++}`;
        }
        seen.add(candidate);
        return candidate;
      };
      Array.from(container.querySelectorAll('h1, h2, h3, h4, h5, h6')).forEach(h => {
        const txt = (h.textContent || '').trim();
        if (!h.id) { h.id = gen(txt, h); }
        else if (seen.has(h.id)) { h.id = gen(txt, h); }
        else { seen.add(h.id); }
      });
    } catch(_) {}

    // המרה של ::: details / ::: admonitions / ??? ו-!!! ל-HTML בטוח לאחר הרינדור
    (function enhanceMarkdownContainers() {
      try {
        if (!container) return;
        const OPEN_RE = /^:{3,}\s*(details|note|tip|warning|danger|info|success|question|example|quote|experimental|deprecated|todo|abstract)\b/i;
        const CLOSE_RE = /^:{3,}\s*$/;
        const Q_OPEN_RE = /^\?{3,}\s*([+\-])?\s*(?:details|note|tip|warning|danger|info|success|question|example|quote|experimental|deprecated|todo|abstract)?\b/i;
        const Q_CLOSE_RE = /^\?{3,}\s*$/;
        const B_OPEN_RE = /^!{3,}\s*([a-z]+)?\s*(.*)$/i; // !!! type? title?
        const B_CLOSE_RE = /^!{3,}\s*$/;
        function isOpenMarker(p){ return p && p.tagName === 'P' && OPEN_RE.test((p.textContent || '').trim()); }
        function isCloseMarker(p){ return p && p.tagName === 'P' && CLOSE_RE.test((p.textContent || '').trim()); }
        function isQOpenMarker(p){ return p && p.tagName === 'P' && Q_OPEN_RE.test((p.textContent || '').trim()); }
        function isQCloseMarker(p){ return p && p.tagName === 'P' && Q_CLOSE_RE.test((p.textContent || '').trim()); }
        function isBOpenMarker(p){ return p && p.tagName === 'P' && B_OPEN_RE.test((p.textContent || '').trim()); }
        function isBCloseMarker(p){ return p && p.tagName === 'P' && B_CLOSE_RE.test((p.textContent || '').trim()); }
        function findMatchingClose(startP) {
          let depth = 0;
          let cursor = startP.nextElementSibling;
          while (cursor) {
            if (isOpenMarker(cursor)) depth += 1;
            else if (isCloseMarker(cursor)) {
              if (depth === 0) return cursor;
              depth -= 1;
            }
            cursor = cursor.nextElementSibling;
          }
          return null;
        }
        function findMatchingQClose(startP) {
          let depth = 0;
          let cursor = startP.nextElementSibling;
          while (cursor) {
            if (isQOpenMarker(cursor)) depth += 1;
            else if (isQCloseMarker(cursor)) {
              if (depth === 0) return cursor;
              depth -= 1;
            }
            cursor = cursor.nextElementSibling;
          }
          return null;
        }
        function findMatchingBClose(startP) {
          let depth = 0;
          let cursor = startP.nextElementSibling;
          while (cursor) {
            if (isBOpenMarker(cursor)) depth += 1;
            else if (isBCloseMarker(cursor)) {
              if (depth === 0) return cursor;
              depth -= 1;
            }
            cursor = cursor.nextElementSibling;
          }
          return null;
        }
        function extractBetween(startP, endP) {
          if (!endP) return null;
          const frag = document.createDocumentFragment();
          let cur = startP.nextSibling;
          while (cur && cur !== endP) { const next = cur.nextSibling; frag.appendChild(cur); cur = next; }
          return frag;
        }
        function defaultTitle(type){ const m={note:'הערה',tip:'טיפ',warning:'אזהרה',danger:'סכנה',info:'מידע',success:'הצלחה',question:'שאלה',example:'דוגמה',quote:'ציטוט',experimental:'ניסוי',deprecated:'לא מומלץ',todo:'לעשות',abstract:'תקציר'}; return m[type]||type; }
        function transformIn(root) {
          let changed = false;
          let node = root.firstElementChild;
          while (node) {
            if (node.tagName === 'P') {
              const text = (node.textContent || '').trim();
              let m = text.match(/^:{3,}\s*details\s*(.*)$/i);
              if (m) {
                const endP = findMatchingClose(node);
                if (!endP) { node = node.nextElementSibling; continue; }
                const frag = extractBetween(node, endP);
                const details = document.createElement('details'); details.className = 'markdown-details';
                const summary = document.createElement('summary'); summary.className = 'markdown-summary'; summary.textContent = m[1] ? m[1].trim() : 'לחץ להצגה';
                const content = document.createElement('div'); content.className = 'details-content'; content.appendChild(frag);
                details.appendChild(summary); details.appendChild(content);
                const parent = node.parentNode; parent.replaceChild(details, node);
                if (endP && endP.parentNode) endP.parentNode.removeChild(endP);
                // עבד רקורסיבית בתוך התוכן, לתמיכה בקינון
                try { transformIn(content); } catch(_) {}
                node = details;
                changed = true;
              } else {
                m = text.match(/^:{3,}\s*(note|tip|warning|danger|info|success|question|example|quote|experimental|deprecated|todo|abstract)\s*(.*)$/i);
                if (m) {
                  const type = m[1].toLowerCase(); const titleTxt = (m[2] || '').trim() || defaultTitle(type);
                  const endP = findMatchingClose(node);
                  if (!endP) { node = node.nextElementSibling; continue; }
                  const frag = extractBetween(node, endP);
                  const wrap = document.createElement('div'); wrap.className = 'admonition admonition-' + type;
                  const title = document.createElement('div'); title.className = 'admonition-title'; title.textContent = titleTxt;
                  const content = document.createElement('div'); content.className = 'admonition-content'; content.appendChild(frag);
                  wrap.appendChild(title); wrap.appendChild(content);
                  const parent = node.parentNode; parent.replaceChild(wrap, node);
                  if (endP && endP.parentNode) endP.parentNode.removeChild(endP);
                  try { transformIn(content); } catch(_) {}
                  node = wrap;
                  changed = true;
                } else {
                  // ??? blocks: ??? [+/−] [type?] [title?]
                  m = text.match(/^\?{3,}\s*([+\-])?\s*([a-z]+)?\s*(.*)$/i);
                  if (m) {
                    const openFlag = (m[1] || '').trim();
                    const type = (m[2] || 'question').toLowerCase();
                    const titleTxt = (m[3] || '').trim() || defaultTitle(type);
                    const endP = findMatchingQClose(node);
                    if (!endP) { node = node.nextElementSibling; continue; }
                    const frag = extractBetween(node, endP);
                    const details = document.createElement('details'); details.className = 'markdown-details admonition admonition-' + type; if (openFlag === '+') details.setAttribute('open', '');
                    const summary = document.createElement('summary'); summary.className = 'markdown-summary admonition-title'; summary.textContent = titleTxt;
                    const content = document.createElement('div'); content.className = 'details-content admonition-content'; content.appendChild(frag);
                    details.appendChild(summary); details.appendChild(content);
                    const parent = node.parentNode; parent.replaceChild(details, node);
                    if (endP && endP.parentNode) endP.parentNode.removeChild(endP);
                    try { transformIn(content); } catch(_) {}
                    node = details;
                    changed = true;
                  } else {
                    // !!! blocks: !!! [type?] [title?] ... !!!
                    m = text.match(/^!{3,}\s*([a-z]+)?\s*(.*)$/i);
                    if (m) {
                      const type = (m[1] || 'note').toLowerCase();
                      const titleTxt = (m[2] || '').trim() || defaultTitle(type);
                      const endP = findMatchingBClose(node);
                      if (!endP) { node = node.nextElementSibling; continue; }
                      const frag = extractBetween(node, endP);
                      const wrap = document.createElement('div'); wrap.className = 'admonition admonition-' + type;
                      const title = document.createElement('div'); title.className = 'admonition-title'; title.textContent = titleTxt;
                      const content = document.createElement('div'); content.className = 'admonition-content'; content.appendChild(frag);
                      wrap.appendChild(title); wrap.appendChild(content);
                      const parent = node.parentNode; parent.replaceChild(wrap, node);
                      if (endP && endP.parentNode) endP.parentNode.removeChild(endP);
                      try { transformIn(content); } catch(_) {}
                      node = wrap;
                      changed = true;
                    }
                  }
                }
              }
            }
            node = node.nextElementSibling;
          }
          return changed;
        }
        // הרץ עד שלא נשארים בלוקים לעיבוד (מגן מלולאות אינסופיות ע"י מקסימום איטרציות)
        let guard = 0;
        while (transformIn(container) && guard < 10) { guard++; }
      } catch(_) {}
    })();

    // הדגשת תחביר לאחר הרינדור: הדגשה ממוקדת בתוך #md-content בלבד
    try {
      if (window.hljs) {
        try { if (typeof window.hljs.highlightAll === 'function') window.hljs.highlightAll(); } catch(_){}
        container.querySelectorAll('pre code').forEach(el => {
          try {
            if (el.classList.contains('hljs')) return;
            var hasLang = /\blanguage-/.test(el.className || '');
            if (hasLang && typeof window.hljs.highlightElement === 'function') {
              window.hljs.highlightElement(el);
            } else if (typeof window.hljs.highlightAuto === 'function') {
              var res = window.hljs.highlightAuto(el.textContent || '');
              el.innerHTML = res.value;
              el.classList.add('hljs');
            }
          } catch(__) {}
        });
      }
    } catch(_) { }

    // אחרי הדגשת hljs – נשמור מקור רק לכל בלוק קוד (לא לכל הקונטיינר)
    try {
      const blocks = container.querySelectorAll('pre code');
      blocks.forEach(code => {
        if (!code.hasAttribute('data-original-html')) {
          code.setAttribute('data-original-html', code.innerHTML);
        }
      });
    } catch(_) {}

    // חיפוש והדגשה בתוך קטעי קוד בלבד
    (function(){
      const input = document.getElementById('mdSearchInput');
      const clearBtn = document.getElementById('mdSearchClear');
      const nextBtn = document.getElementById('mdSearchNext');
      const countEl = document.getElementById('mdSearchCount');
      if (!input || !clearBtn || !countEl) return;
      let justAutoFocused = false;

      function restore() {
        // משחזר כל בלוק קוד מהמקור שנשמר בו, בלי לגעת בשאר ה-HTML והדגשות hljs
        const blocks = container.querySelectorAll('pre code');
        blocks.forEach(code => {
          try {
            const orig = code.getAttribute('data-original-html');
            if (orig != null) {
              code.innerHTML = orig;
            }
          } catch(_) {}
        });
      }

      function highlightTerm(term) {
        // מדגיש רק בתוך pre > code כדי לא לשבור HTML מחוץ לקוד
        const blocks = container.querySelectorAll('pre code');
        let total = 0;
        blocks.forEach(code => {
          try {
            const original = code.getAttribute('data-original-html') || code.innerHTML;
            code.setAttribute('data-original-html', original);
            if (!term) { code.innerHTML = original; return; }
            const safe = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const rx = new RegExp(`(${safe})`, 'gi');
            const replaced = original.replace(rx, '<span class="md-highlight">$1</span>');
            code.innerHTML = replaced;
            total += (original.match(rx) || []).length;
          } catch(_) {}
        });
        return total;
      }

      function updateCount(n, term){
        if (!term) { countEl.textContent = ''; return; }
        const active = container.querySelector('.md-highlight.is-active');
        const activeIndex = active ? (Array.from(container.querySelectorAll('.md-highlight')).indexOf(active) + 1) : 0;
        countEl.textContent = n > 0 ? (activeIndex ? `${activeIndex}/${n}` : `${n} תוצאות`) : 'אין תוצאות';
      }

      function setActiveAndScroll(target){
        try { container.querySelectorAll('.md-highlight.is-active').forEach(el => el.classList.remove('is-active')); } catch(_){ }
        if (!target) return;
        try { target.classList.add('is-active'); } catch(_){ }
        try { target.scrollIntoView({ behavior:'smooth', block:'center' }); } catch(_){ }
      }

      function focusFirst(){
        const first = container.querySelector('.md-highlight');
        if (first) setActiveAndScroll(first);
      }

      // פונקציה מאוחדת לניווט בין תוצאות - direction: 1 להבא, -1 להקודם
      function navigateHighlight(direction){
        const all = Array.from(container.querySelectorAll('.md-highlight'));
        if (all.length === 0) return;
        const current = container.querySelector('.md-highlight.is-active');
        const idx = current ? all.indexOf(current) : (direction === 1 ? -1 : 0);
        const target = all[(idx + direction + all.length) % all.length];
        setActiveAndScroll(target);
        updateCount(all.length, input.value.trim());
      }

      function focusNext(){ navigateHighlight(1); }
      function focusPrev(){ navigateHighlight(-1); }

      input.addEventListener('input', () => {
        const term = (input.value || '').trim();
        restore();
        const n = highlightTerm(term);
        if (term && n > 0) {
          focusFirst();
          justAutoFocused = true;
        }
        updateCount(n, term);
      });

      clearBtn.addEventListener('click', () => {
        input.value = '';
        restore();
        updateCount(0, '');
        justAutoFocused = false;
      });

      if (nextBtn) {
        nextBtn.addEventListener('click', () => {
          const term = (input.value || '').trim();
          if (!term) return;
          const active = container.querySelector('.md-highlight.is-active');
          if (justAutoFocused || !active) {
            const first = container.querySelector('.md-highlight');
            if (first) setActiveAndScroll(first);
            justAutoFocused = false;
            updateCount(container.querySelectorAll('.md-highlight').length, term);
          } else {
            focusNext();
          }
        });
      }

      const prevBtn = document.getElementById('mdSearchPrev');
      if (prevBtn) {
        prevBtn.addEventListener('click', () => {
          const term = (input.value || '').trim();
          if (!term) return;
          focusPrev();
          justAutoFocused = false;
        });
      }

      input.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') {
          ev.preventDefault();
          const all = container.querySelectorAll('.md-highlight');
          if (all.length === 0) return;
          if (ev.shiftKey) {
            // Shift+Enter: navigate to previous result
            focusPrev();
            justAutoFocused = false;
          } else {
            const active = container.querySelector('.md-highlight.is-active');
            if (justAutoFocused || !active) {
              const first = container.querySelector('.md-highlight');
              if (first) setActiveAndScroll(first);
              justAutoFocused = false;
              updateCount(all.length, input.value.trim());
            } else {
              focusNext();
            }
          }
        }
      });

      // הוסר הקוד הכפול מהמיין; נשארת רק הלוגיקה החדשה שלא מדלגת על הראשונה
    })();

    // Lazy loading לתמונות
    container.querySelectorAll('img').forEach(img => { img.loading = 'lazy'; });

    // KaTeX אוטו-רנדר (בבטחה; אין html גולמי)
    try { if (window.renderMathInElement) window.renderMathInElement(container, { delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}] }); } catch(_){ }

    // Mermaid: רנדר דיאגרמות בקוד fence ```mermaid
    try {
      if (!window.mermaid) throw new Error('mermaid missing');
      // Choose Mermaid theme based on actual background brightness
      const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
      const knownDarkThemes = ['dark', 'dim', 'nebula', 'ocean', 'forest', 'high-contrast'];
      const knownLightThemes = ['classic', 'rose-pine-dawn'];
      let mermaidTheme = 'dark';
      if (knownLightThemes.includes(currentTheme)) {
        mermaidTheme = 'default';
      } else if (currentTheme === 'custom') {
        // For custom themes, check actual background color brightness
        const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--bg-primary').trim();
        if (bgColor) {
          const hex = bgColor.replace('#', '');
          if (hex.length >= 6) {
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            mermaidTheme = brightness > 128 ? 'default' : 'dark';
          }
        }
      }
      window.mermaid.initialize({ 
        startOnLoad: false, 
        securityLevel: 'strict',
        theme: mermaidTheme
      });
      const blocks = container.querySelectorAll('code.language-mermaid, pre code.language-mermaid');
      let i=0;
      for (const el of blocks) {
        const parent = el.closest('pre') || el.parentElement;
        const svgId = 'mmd_' + (++i);
        const code = el.textContent;
        const wrapper = document.createElement('div');
        parent.replaceWith(wrapper);
        try {
          const { svg } = await window.mermaid.render(svgId, code);
          wrapper.innerHTML = svg;
        } catch(e) {
          wrapper.innerHTML = '<div class="alert alert-warning">Mermaid render failed</div>';
        }
      }
    } catch(_){ }

    // פונקציות עזר נגישות בשימוש משותף (copy/permalink)
    function announceToScreenReader(message) {
      try {
        const announcement = document.createElement('div');
        announcement.setAttribute('role', 'status');
        announcement.setAttribute('aria-live', 'polite');
        announcement.className = 'sr-only';
        announcement.textContent = message;
        document.body.appendChild(announcement);
        setTimeout(() => { try { document.body.removeChild(announcement); } catch(_){} }, 1000);
      } catch(_) {}
    }
    // כפתור העתקה משופר לכל בלוק קוד + נגישות מלאה
    try {
      const FALLBACK_LANG = (document.documentElement && document.documentElement.dir === 'rtl') ? 'טקסט' : 'Text';
      function showCopySuccess(btn) {
        try {
          btn.classList.remove('copy-error');
          btn.classList.add('copied');
          setTimeout(() => btn.classList.remove('copied'), 1800);
        } catch(_) {}
      }
      function showCopyError(btn) {
        try {
          btn.classList.remove('copied');
          btn.classList.add('copy-error');
          setTimeout(() => btn.classList.remove('copy-error'), 1800);
        } catch(_) {}
      }
      function detectLanguage(pre) {
        try {
          const code = pre.querySelector('code');
          let lang = null;
          if (code) {
            lang = code.getAttribute('data-language') || code.getAttribute('data-lang');
            if (!lang && code.dataset) {
              lang = code.dataset.language || code.dataset.lang || null;
            }
            if (!lang) {
              const classes = (code.className || '').split(/\s+/);
              for (const cls of classes) {
                if (!cls) continue;
                if (cls.startsWith('language-')) { lang = cls.replace(/^language-/, ''); break; }
                if (cls.startsWith('lang-')) { lang = cls.replace(/^lang-/, ''); break; }
              }
            }
          }
          if (!lang && pre.className) {
            const preClasses = pre.className.split(/\s+/);
            for (const cls of preClasses) {
              if (!cls) continue;
              if (cls.startsWith('language-')) { lang = cls.replace(/^language-/, ''); break; }
              if (cls.startsWith('lang-')) { lang = cls.replace(/^lang-/, ''); break; }
            }
          }
          if (!lang) return FALLBACK_LANG;
          lang = lang.replace(/[-_]+/g, ' ').trim();
          if (!lang) return FALLBACK_LANG;
          return lang.replace(/\b\w/g, (ch) => ch.toUpperCase());
        } catch(_) {
          return FALLBACK_LANG;
        }
      }
      function addCopyButtons() {
        const pres = document.querySelectorAll('#md-content pre');
        pres.forEach(pre => {
          let wrapper = pre.parentElement;
          if (!wrapper || !wrapper.classList || !wrapper.classList.contains('code-block')) {
            wrapper = document.createElement('div');
            wrapper.className = 'code-block';
            pre.replaceWith(wrapper);
            wrapper.appendChild(pre);
          }
          let header = wrapper.querySelector('.md-code-header');
          if (!header) {
            header = document.createElement('div');
            header.className = 'md-code-header';
            wrapper.insertBefore(header, pre);
          }
          let langEl = header.querySelector('.md-code-lang');
          if (!langEl) {
            langEl = document.createElement('span');
            langEl.className = 'md-code-lang';
            header.insertBefore(langEl, header.firstChild || null);
          }
          langEl.textContent = detectLanguage(pre);
          let btn = header.querySelector('.md-copy-btn');
          if (!btn) {
            btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'md-copy-btn';
            btn.setAttribute('aria-label', 'העתק קוד');
            btn.setAttribute('title', 'העתק קוד');
            btn.innerHTML = `
              <svg class="icon-copy" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
              <svg class="icon-check" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
                <polyline points="20 6 9 17 4 12"></polyline>
              </svg>
              <span class="sr-only">העתק קוד</span>
            `;
            btn.addEventListener('click', async () => {
              const code = pre.querySelector('code')?.innerText || pre.innerText;
              try {
                await navigator.clipboard.writeText(code);
                showCopySuccess(btn);
                announceToScreenReader('הקוד הועתק ללוח');
              } catch(_) {
                if (fallbackCopy(code)) {
                  showCopySuccess(btn);
                  announceToScreenReader('הקוד הועתק ללוח');
                } else {
                  showCopyError(btn);
                  announceToScreenReader('ההעתקה נכשלה');
                }
              }
            });
            btn.addEventListener('keydown', (e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                btn.click();
              }
            });
            header.appendChild(btn);
          }
        });
      }
      addCopyButtons();
    } catch(_){ }

    // Permalinks נגישים: העתקת קישור כותרת בלחיצה ומשוב ידידותי
    try {
      function showTooltip(element, message) {
        try {
          const tooltip = document.createElement('div');
          tooltip.className = 'permalink-tooltip';
          tooltip.textContent = message;
          tooltip.setAttribute('role', 'tooltip');
          const rect = element.getBoundingClientRect();
          tooltip.style.position = 'fixed';
          tooltip.style.top = `${rect.top - 30}px`;
          tooltip.style.left = `${rect.left}px`;
          document.body.appendChild(tooltip);
          setTimeout(() => { tooltip.style.opacity = '0'; setTimeout(() => { try { document.body.removeChild(tooltip); } catch(_){} }, 300); }, 2000);
        } catch(_) {}
      }
      function enhanceHeaderPermalinks() {
        const headers = document.querySelectorAll('#md-content h1, #md-content h2, #md-content h3, #md-content h4, #md-content h5, #md-content h6');
        headers.forEach(header => {
          if (!header.id) {
            // יצירת מזהה ייחודי אם חסר
            const base = (header.textContent || '').trim().toLowerCase()
              .replace(/[^\w\u0590-\u05FF\s-]/g, '')
              .replace(/[\s_]+/g, '-')
              .replace(/^-+|-+$/g, '') || 'section';
            let id = base; let i = 1;
            while (document.getElementById(id)) { id = `${base}-${++i}`; }
            header.id = id;
          }
          // אם אין עוגן שנוצר ע"י התוסף – הוסף ידנית
          if (!header.querySelector('.header-anchor')) {
            const permalink = document.createElement('a');
            permalink.className = 'header-anchor';
            permalink.href = `#${header.id}`;
            permalink.innerHTML = '🔗';
            permalink.setAttribute('aria-label', `קישור קבוע לסעיף: ${header.textContent || ''}`);
            permalink.setAttribute('title', 'העתק קישור לסעיף זה');
            header.appendChild(permalink);
          }
        });
        // רישום מאזינים להעתקה
        document.querySelectorAll('#md-content .header-anchor').forEach(permalink => {
          permalink.addEventListener('click', async (e) => {
            e.preventDefault();
            const header = permalink.closest('h1, h2, h3, h4, h5, h6');
            if (!header || !header.id) return;
            const url = new URL(window.location.href);
            url.hash = header.id;
            try {
              await navigator.clipboard.writeText(url.toString());
              showTooltip(permalink, 'הקישור הועתק!');
              // שימוש בפונקציה שהוגדרה למעלה (אם קיימת)
              try { announceToScreenReader('קישור לכותרת הועתק'); } catch(_){}
            } catch(_) {
              if (fallbackCopy(url.toString())) {
                showTooltip(permalink, 'הקישור הועתק!');
                try { announceToScreenReader('קישור לכותרת הועתק'); } catch(_){}
              }
            }
            try { header.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch(_){}
          });
        });
      }
      enhanceHeaderPermalinks();
    } catch(_){ }

    // קיצורי מקלדת בסיסיים: העתקת קוד ראשון והעתקת קישור לכותרת גלויה
    try {
      function getCurrentVisibleHeader() {
        const headers = document.querySelectorAll('#md-content h1, #md-content h2, #md-content h3, #md-content h4, #md-content h5, #md-content h6');
        const scrollPos = window.scrollY + 100;
        for (let i = headers.length - 1; i >= 0; i--) {
          const el = headers[i];
          if (el.offsetTop <= scrollPos) return el;
        }
        return headers[0] || null;
      }
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.shiftKey && e.key.toUpperCase() === 'C') {
          e.preventDefault();
          const firstCopyBtn = document.querySelector('#md-content .md-copy-btn');
          if (firstCopyBtn) firstCopyBtn.click();
        }
        if (e.ctrlKey && (e.key === 'l' || e.key === 'L')) {
          e.preventDefault();
          const currentHeader = getCurrentVisibleHeader();
          if (currentHeader) {
            const permalink = currentHeader.querySelector('.header-anchor');
            if (permalink) permalink.click();
          }
        }
      });
    } catch(_){ }

    // גלילה/פוקוס לפי hash אם הוזן בכניסה
    try {
      (function restoreScrollPosition(){
        const hash = window.location.hash;
        if (!hash) return;
        const element = document.querySelector(hash);
        if (!element) return;
        setTimeout(() => { try { element.scrollIntoView({ behavior: 'smooth', block: 'start' }); element.tabIndex = -1; element.focus(); } catch(_){} }, 100);
      })();
    } catch(_){ }

    // רשימות משימות אינטראקטיביות: שמירה/שחזור מצב
    // ב-render, markdown-it-task-lists הופך ל-input[type=checkbox]
    const boxes = container.querySelectorAll('input[type="checkbox"]');
    let idx = 0;
    boxes.forEach(cb => {
      cb.classList.add('md-task-checkbox');
      const key = 'i' + (idx++);
      // שחזור מצב
      if (Object.prototype.hasOwnProperty.call(taskState, key)) {
        cb.checked = !!taskState[key];
      }
      cb.addEventListener('change', () => {
        taskState[key] = cb.checked;
        saveTaskState(taskState);
      });
    });

    // וירטואליזציה בסיסית למסמכים ארוכים (חלוקה לקטעים לפי כותרות)
    try {
      const MAX_NODES = 2000;
      const nodes = Array.from(container.childNodes);
      if (nodes.length > MAX_NODES) {
        const chunk = document.createDocumentFragment();
        nodes.slice(0, MAX_NODES).forEach(n => chunk.appendChild(n));
        const rest = nodes.slice(MAX_NODES);
        container.innerHTML = '';
        container.appendChild(chunk);
        const more = document.createElement('button');
        more.className = 'btn btn-secondary btn-icon';
        more.textContent = 'טען עוד…';
        more.addEventListener('click', () => {
          const frag = document.createDocumentFragment();
          rest.forEach(n => frag.appendChild(n));
          container.appendChild(frag);
          more.remove();
        });
        container.appendChild(document.createElement('hr'));
        container.appendChild(more);
      }
    } catch(_){ }

    // אות שהרינדור הראשוני של ה-Markdown הושלם – מאפשר לרכיבים חיצוניים (כמו פתקים דביקים)
    // להמתין לסיום הרינדור לפני אתחול, כדי להימנע מחפיפה/קפיצות.
    try { document.dispatchEvent(new CustomEvent('md:rendered', { detail: { fileId: FILE_ID } })); } catch(_) {}

  } catch (e) {
    console.error('Markdown preview failed', e);
    const container = document.getElementById('md-content');
    container.innerHTML = '<div class="alert alert-error">שגיאה ברינדור Markdown</div>';
  }
})();

// === מצב מצומצם (קיפול כותרות ##) — אדמין בלבד ===
(function initAdminH2Folding(){
  'use strict';
  const isAdmin = Boolean({{ (is_admin|default(false))|tojson }});
  const isPublic = Boolean({{ (is_public|default(false))|tojson }});
  if (!isAdmin || isPublic) return;

  const FILE_KEY = String({{ file.id|tojson }} || '');
  const ENABLE_KEY = 'mdCollapseEnabled:' + FILE_KEY;
  const STATE_KEY = 'mdCollapseState:' + FILE_KEY;

  function lsGet(key, fallback){
    try { const v = localStorage.getItem(key); return v == null ? fallback : v; } catch(_) { return fallback; }
  }
  function lsSet(key, val){ try { localStorage.setItem(key, val); } catch(_) {} }
  function loadEnabled(){ return lsGet(ENABLE_KEY, '0') === '1'; }
  function saveEnabled(on){ lsSet(ENABLE_KEY, on ? '1' : '0'); }

  function loadState(){
    try { return JSON.parse(localStorage.getItem(STATE_KEY) || '{}') || {}; } catch(_) { return {}; }
  }
  function saveState(state){ try { localStorage.setItem(STATE_KEY, JSON.stringify(state || {})); } catch(_) {} }

  function applyFolding(){
    const container = document.getElementById('md-content');
    if (!container) return;
    // הימנע מקיפול כפול
    if (container.querySelector('details.md-section-collapse')) return;
    const headers = Array.from(container.querySelectorAll('h3'));
    if (headers.length === 0) return;
    const state = loadState();
    headers.forEach((h2, idx) => {
      // דלג אם כבר טופל
      if (h2.hasAttribute('data-collapsed-bound')) return;
      h2.setAttribute('data-collapsed-bound','1');
      const details = document.createElement('details');
      details.className = 'markdown-details md-section-collapse';
      const summary = document.createElement('summary');
      summary.className = 'markdown-summary';
      // שמור הורה ונקודת הוצאה להחדרה חזרה במקום המקורי
      const parent = h2.parentNode;
      const insertBeforeNode = h2.nextSibling; // על מה שנמצא מיד אחרי ה-H3
      // אסוף את כל האחים עד הכותרת H2/H1 הבאה (לפני שמזיזים DOM)
      const toMove = [];
      {
        let cursor = insertBeforeNode;
        while (cursor) {
          const next = cursor.nextSibling;
          if (cursor.nodeType === 1) { // ELEMENT_NODE
            const tag = String(cursor.tagName || '').toLowerCase();
            if (tag === 'h3' || tag === 'h2' || tag === 'h1') break;
          }
          toMove.push(cursor);
          cursor = next;
        }
      }
      // העבר את הכותרת עצמה לתוך הסיכום
      summary.appendChild(h2);
      const content = document.createElement('div');
      content.className = 'details-content md-section-content';
      details.appendChild(summary);
      details.appendChild(content);
      // הזרק למיקום המקורי (לפני האיבר שאחריו עמד ה-H2 קודם)
      if (parent) {
        parent.insertBefore(details, insertBeforeNode);
      } else {
        container.appendChild(details);
      }
      // העבר את האחים שאספנו לתוך ה-content של המקטע
      toMove.forEach(node => { try { content.appendChild(node); } catch(_) {} });
      // קבע פתיחה: לפי סטייט שמור, אחרת ברירת מחדל — הראשון פתוח, אחרים סגורים
      const id = h2.id || ('h3_' + (idx+1));
      if (!h2.id) h2.id = id;
      const saved = Object.prototype.hasOwnProperty.call(state, id) ? !!state[id] : null;
      details.open = (saved === null) ? (idx === 0) : saved;
      // שמירת מצב בלבד (ללא אנימציה)
      details.addEventListener('toggle', () => {
        const s = loadState();
        s[id] = details.open ? 1 : 0;
        saveState(s);
      });
    });
  }

  function removeFolding(){
    const container = document.getElementById('md-content');
    if (!container) return;
    const sections = Array.from(container.querySelectorAll('details.md-section-collapse'));
    sections.forEach(details => {
      try {
        const summary = details.querySelector('summary');
        const header = summary ? summary.querySelector('h3') : null;
        const content = details.querySelector('.md-section-content') || details.querySelector('.details-content');
        if (header) {
          details.parentNode.insertBefore(header, details);
          try { header.removeAttribute('data-collapsed-bound'); } catch(_) {}
        }
        if (content) {
          while (content.firstChild) {
            details.parentNode.insertBefore(content.firstChild, details);
          }
        }
        details.remove();
      } catch(_) {}
    });
  }

  function updateButtonVisual(btn, on){
    try {
      btn.setAttribute('aria-pressed', on ? 'true' : 'false');
      btn.innerHTML = on
        ? '<i class="fas fa-compress-alt"></i> בטל מצב מצומצם'
        : '<i class="fas fa-compress-alt"></i> מצב מצומצם';
    } catch(_) {}
  }

  function bind(){
    const btn = document.getElementById('mdCollapseBtn');
    if (!btn) return;
    let enabled = loadEnabled();
    updateButtonVisual(btn, enabled);
    const run = () => { enabled ? applyFolding() : removeFolding(); };
    // הפעלה ראשונית אחרי רינדור ה-Markdown
    document.addEventListener('md:rendered', () => { run(); });
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      enabled = !enabled;
      saveEnabled(enabled);
      updateButtonVisual(btn, enabled);
      run();
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bind);
  } else {
    bind();
  }
})();

// === מערכת החלפת צבעי רקע למארקדאון ===
(function initBackgroundColorSwitcher() {
  'use strict';
  
  const COLORS = {
    sepia: '#fdf6e3',
    light: '#f5e6d3',
    medium: '#e8d4b0',
    dark: '#d4b896'
  };
  
  const STORAGE_KEY = 'md_bg_color_preference';
  const ALLOWED_THEMES = new Set(['classic', 'ocean', 'rose-pine-dawn']);
  
  // שליפת העדפה שמורה
  function getSavedColorPreference() {
    try {
      return localStorage.getItem(STORAGE_KEY) || null;
    } catch(_) {
      return null;
    }
  }
  
  // שמירת העדפה
  function saveColorPreference(color) {
    try {
      if (color) {
        localStorage.setItem(STORAGE_KEY, color);
      } else {
        localStorage.removeItem(STORAGE_KEY);
      }
    } catch(_) {}
  }
  
  function clearAppliedBackground() {
    const mdContent = document.getElementById('md-content');
    if (!mdContent) return;
    mdContent.classList.remove('bg-sepia', 'bg-light', 'bg-medium', 'bg-dark');
    const indicator = document.querySelector('#bgColorBtn span');
    if (indicator) indicator.style.background = '#ffffff';
  }

  // החלת צבע רקע
  function applyBackgroundColor(color) {
   const mdContent = document.getElementById('md-content');
   if (!mdContent) return;
 
   const indicator = document.querySelector('#bgColorBtn span');
   
   // הסרת כל המחלקות הקודמות
   mdContent.classList.remove('bg-sepia', 'bg-light', 'bg-medium', 'bg-dark');
   
   // החלת צבע חדש אם נבחר
   if (color && COLORS[color]) {
     mdContent.classList.add(`bg-${color}`);
     
     // עדכון הכפתור הראשי
     if (indicator) {
       indicator.style.background = COLORS[color];
     }
   } else {
     // חזרה לצבע ברירת המחדל (לבן)
     if (indicator) {
       indicator.style.background = '#ffffff';
     }
   }
   
   // סימון האפשרות הפעילה
   document.querySelectorAll('.bg-color-option').forEach(btn => {
     btn.classList.remove('active');
     // השוואה גם לערך ריק עבור ברירת המחדל
     if ((color === null || color === '') && (btn.dataset.color === '' || btn.dataset.color === 'default')) {
       btn.classList.add('active');
     } else if (btn.dataset.color === color) {
       btn.classList.add('active');
     }
   });
   
   // שמירת ההעדפה
   saveColorPreference(color);
 }
  
  // אתחול המערכת
  function init() {
    const bgColorBtn = document.getElementById('bgColorBtn');
    const bgColorOptions = document.getElementById('bgColorOptions');
    const bgColorSwitcher = document.getElementById('bgColorSwitcher');
    
    if (!bgColorBtn || !bgColorOptions || !bgColorSwitcher) return;

    // הכפתור פעיל רק בערכות ספציפיות (אחרת גם לא מיישמים צבע שמור)
    const currentTheme = document.documentElement.getAttribute('data-theme') || '';
    if (!ALLOWED_THEMES.has(currentTheme)) {
      try { bgColorSwitcher.style.display = 'none'; } catch(_) {}
      clearAppliedBackground();
      return;
    } else {
      // אם הגיעו לכאן זה אומר שה-Theme מאפשר, לכן נדאג שהכפתור יופיע גם אם CSS לא נטען עדיין
      try { bgColorSwitcher.style.display = 'inline-flex'; } catch(_) {}
    }
    
    // טעינת העדפה שמורה
   const savedColor = getSavedColorPreference();
   applyBackgroundColor(savedColor);
    
    // פתיחה/סגירה של התפריט
    bgColorBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const isVisible = bgColorOptions.style.display !== 'none';
      bgColorOptions.style.display = isVisible ? 'none' : 'block';
    });
    
    // בחירת צבע
    document.querySelectorAll('.bg-color-option').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const color = btn.dataset.color;
        applyBackgroundColor(color);
        bgColorOptions.style.display = 'none';
      });
    });
    
    // סגירת התפריט בלחיצה מחוץ לאזור
    document.addEventListener('click', (e) => {
      if (!e.target.closest('#bgColorSwitcher')) {
        bgColorOptions.style.display = 'none';
      }
    });
    
    // הוספת אפשרות לחזור לצבע הלבן המקורי
    const defaultBtn = document.createElement('button');
    defaultBtn.className = 'bg-color-option';
    defaultBtn.dataset.color = ''; // ערך ריק לברירת מחדל
    defaultBtn.style = 'display:block;width:100%;padding:8px 12px;margin:4px 0;border:1px solid #ddd;border-radius:6px;background:#ffffff;color:#333;cursor:pointer;font-size:14px;transition:all 0.2s ease;';
    defaultBtn.innerHTML = `
      <span style="display:inline-block;width:20px;height:20px;border-radius:4px;background:#ffffff;border:1px solid #999;vertical-align:middle;margin-left:8px;"></span>
      לבן (ברירת מחדל)
    `;
    defaultBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      applyBackgroundColor(null); // שימוש בפונקציה המרכזית
      bgColorOptions.style.display = 'none';
    });
    
    // הוספת כפתור ברירת המחדל לתחילת הרשימה
    bgColorOptions.insertBefore(defaultBtn, bgColorOptions.firstChild);
    
    // סימון ברירת המחדל אם אין צבע שמור - יעשה אוטומטית דרך applyBackgroundColor
  }
  
  // הפעלת המערכת לאחר טעינת הדף
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();

// === תוכן עניינים צף מתקדם - גרסה 2.0 ===
(function initAdvancedTableOfContents() {
  'use strict';
  const CONFIG = {
    MAX_HEADINGS: 200,
    VIRTUAL_SCROLL_THRESHOLD: 50,
    SEARCH_DEBOUNCE: 300,
    SCROLL_OFFSET: 120,
    INTERSECTION_THRESHOLD: 0.5,
    INTERSECTION_MARGIN: '-20% 0% -70% 0%',
    WAIT_TIMEOUT: 5000,
    CHECK_INTERVAL: 100,
    LONG_PRESS_MS: 450,
    MINI_POS_KEY: 'md_toc_mini_top',
    MINIMIZED_KEY_GLOBAL: 'mdTocMinimized',
    MINIMIZED_KEY_PER_FILE_PREFIX: 'mdTocMinimized:'
  };
  let tocState = {
    headings: [],
    visibleHeadings: [],
    activeHeading: null,
    observer: null,
    clickHandlers: [],
    searchTerm: '',
    isCollapsed: false,
    isMinimized: false,
    scrollPercentage: 0
  };
  function clamp(value, min, max){ return Math.min(Math.max(value, min), max); }
  function getSavedMiniTop(){
    try { const v = parseInt(localStorage.getItem(CONFIG.MINI_POS_KEY) || '100', 10); return isNaN(v) ? 100 : v; } catch(_) { return 100; }
  }
  function saveMiniTop(top){ try { localStorage.setItem(CONFIG.MINI_POS_KEY, String(top)); } catch(_){} }
  function applyMiniTop(top){
    const miniBtn = document.getElementById('mdTocMini');
    const tocElement = document.getElementById('mdToc');
    if (miniBtn) miniBtn.style.top = top + 'px';
    if (tocElement) tocElement.style.top = top + 'px';
  }
  function debounce(func, wait) {
    let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); };
  }
  function sanitizeText(text) {
    const div = document.createElement('div'); div.textContent = text; return div.innerHTML.replace(/[<>\"'&]/g, '').replace(/¶/g, '').trim();
  }
  function generateUniqueId(prefix, index) {
    return `${prefix}-${Date.now()}-${index}-${Math.random().toString(36).substr(2, 9)}`;
  }
  function waitForContent(callback) {
    const startTime = Date.now();
    function check() {
      try {
        const container = document.getElementById('md-content');
        const hasContent = container && container.innerHTML.trim().length > 0 && container.querySelector('h1, h2, h3, h4, h5, h6');
        if (hasContent) { setTimeout(callback, 50); }
        else if (Date.now() - startTime < CONFIG.WAIT_TIMEOUT) { setTimeout(check, CONFIG.CHECK_INTERVAL); }
        else { console.warn('TOC: תוכן לא נטען בזמן המוגדר'); hideTOC(); }
      } catch (e) { console.error('TOC: שגיאה בבדיקת תוכן', e); hideTOC(); }
    }
    check();
  }
  function hideTOC() { const tocElement = document.getElementById('mdToc'); if (tocElement) tocElement.style.display = 'none'; }
  function cleanup() {
    try {
      if (tocState.observer) { tocState.observer.disconnect(); tocState.observer = null; }
      tocState.clickHandlers.forEach(({ element, event, handler }) => { element.removeEventListener(event, handler); });
      tocState.clickHandlers = [];
    } catch (e) { console.error('TOC: שגיאה בניקוי', e); }
  }
  function buildTOC() {
    try {
      const container = document.getElementById('md-content');
      const tocElement = document.getElementById('mdToc');
      const tocNav = document.getElementById('mdTocNav');
      if (!container || !tocElement || !tocNav) { console.error('TOC: אלמנטים חסרים'); return; }
      let headings = Array.from(container.querySelectorAll('h1, h2, h3, h4, h5, h6'));
      if (headings.length === 0) { console.info('TOC: לא נמצאו כותרות במסמך'); hideTOC(); return; }
      if (headings.length > CONFIG.MAX_HEADINGS) { console.warn(`TOC: נמצאו ${headings.length} כותרות, מציג רק ${CONFIG.MAX_HEADINGS} הראשונות`); headings = headings.slice(0, CONFIG.MAX_HEADINGS); }
      tocState.headings = headings;
      const fragment = document.createDocumentFragment();
      const seenIds = new Map();
      headings.forEach((heading, index) => {
        try {
          const level = parseInt(heading.tagName.substring(1));
          const text = sanitizeText(heading.textContent || '');
          // שמירת מזהים קיימים שנוצרו ע״י markdown-it-anchor; שינוי רק במקרה כפילויות או חוסר מזהה
          let currentId = heading.id || '';
          if (!currentId) {
            currentId = generateUniqueId('toc-heading', index);
            heading.id = currentId;
          }
          const priorCount = seenIds.get(currentId) || 0;
          if (priorCount > 0) {
            // הפוך לכותרת ייחודית בלי לשנות את הראשונה
            let suffix = priorCount + 1;
            let candidate = `${currentId}-${suffix}`;
            while (document.getElementById(candidate) || seenIds.has(candidate)) {
              suffix += 1;
              candidate = `${currentId}-${suffix}`;
            }
            heading.id = candidate;
            currentId = candidate;
          }
          seenIds.set(currentId, (seenIds.get(currentId) || 0) + 1);

          const item = document.createElement('a');
          item.className = 'md-toc-item';
          item.setAttribute('data-level', level);
          item.setAttribute('href', `#${encodeURIComponent(currentId)}`);
          item.setAttribute('data-index', index);
          item.setAttribute('aria-label', `עבור לכותרת: ${text}`);
          item.textContent = text;
          if (text.length > 30) { item.title = text; item.textContent = text.substring(0, 30) + '...'; }
          const clickHandler = (e) => { e.preventDefault(); try { heading.scrollIntoView({ behavior: 'smooth', block: 'start' }); updateActiveItem(item); closeSearch(); minimizeTOC(); } catch (error) { console.error('TOC: שגיאה בגלילה', error); } };
          item.addEventListener('click', clickHandler);
          tocState.clickHandlers.push({ element: item, event: 'click', handler: clickHandler });
          fragment.appendChild(item);
        } catch (error) { console.error('TOC: שגיאה ביצירת פריט', error); }
      });
      tocNav.appendChild(fragment);
      if (headings.length > CONFIG.VIRTUAL_SCROLL_THRESHOLD) { setupVirtualScrolling(); }
      setupIntersectionObserver();
      setupInteractions();
      setupSearch();
      setupKeyboardShortcuts();
      setupProgressIndicator();
      tocElement.style.display = 'block';
      // החלת העדפת מיזעור (גלובלי/פר-קובץ) לאחר בנייה
      try { if (typeof getSavedMinimizedPreference === 'function' && getSavedMinimizedPreference()) { minimizeTOC(); } } catch(_) {}
      console.info(`TOC: נבנה בהצלחה עם ${headings.length} כותרות`);
    } catch (e) { console.error('TOC: שגיאה כללית בבנייה', e); hideTOC(); }
  }
  function setupVirtualScrolling() {
    console.info('TOC: מפעיל Virtual Scrolling');
    const tocNav = document.getElementById('mdTocNav'); if (!tocNav) return;
    const observer = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) { entry.target.classList.remove('md-toc-item-placeholder'); } else { entry.target.classList.add('md-toc-item-placeholder'); } }); }, { root: tocNav, rootMargin: '100px' });
    tocNav.querySelectorAll('.md-toc-item').forEach(item => { observer.observe(item); });
  }
  function setupIntersectionObserver() {
    try {
      const options = { rootMargin: CONFIG.INTERSECTION_MARGIN, threshold: CONFIG.INTERSECTION_THRESHOLD };
      tocState.observer = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) { const index = tocState.headings.indexOf(entry.target); if (index !== -1) { const item = document.querySelector(`.md-toc-item[data-index="${index}"]`); if (item) updateActiveItem(item); } } }); }, options);
      tocState.headings.forEach(heading => { tocState.observer.observe(heading); });
      console.debug('TOC: Intersection Observer מופעל');
    } catch (e) { console.error('TOC: שגיאה ב-Intersection Observer', e); setupScrollFallback(); }
  }
  function setupScrollFallback() {
    console.info('TOC: משתמש ב-scroll event כ-fallback');
    let ticking = false; const scrollHandler = () => { if (!ticking) { window.requestAnimationFrame(() => { updateActiveHeadingByScroll(); ticking = false; }); ticking = true; } };
    window.addEventListener('scroll', scrollHandler, { passive: true });
    tocState.clickHandlers.push({ element: window, event: 'scroll', handler: scrollHandler });
  }
  function updateActiveHeadingByScroll() {
    const scrollPos = window.scrollY + CONFIG.SCROLL_OFFSET; let activeHeading = null;
    for (let i = tocState.headings.length - 1; i >= 0; i--) { const heading = tocState.headings[i]; if (heading.offsetTop <= scrollPos) { activeHeading = heading; break; } }
    if (activeHeading) { const index = tocState.headings.indexOf(activeHeading); const item = document.querySelector(`.md-toc-item[data-index="${index}"]`); if (item) updateActiveItem(item); }
  }
  function updateActiveItem(newActiveItem) {
    document.querySelectorAll('.md-toc-item').forEach(item => { item.classList.remove('active'); });
    if (newActiveItem) {
      newActiveItem.classList.add('active'); tocState.activeHeading = newActiveItem;
      const tocNav = document.getElementById('mdTocNav'); if (tocNav) { const itemRect = newActiveItem.getBoundingClientRect(); const navRect = tocNav.getBoundingClientRect(); if (itemRect.top < navRect.top || itemRect.bottom > navRect.bottom) { newActiveItem.scrollIntoView({ behavior: 'smooth', block: 'center' }); } }
    }
  }
  function setupInteractions() {
    const tocElement = document.getElementById('mdToc');
    const tocToggle = document.getElementById('mdTocToggle');
    const tocHeader = document.querySelector('.md-toc-header');
    const miniBtn = document.getElementById('mdTocMini');
    const menuBtn = document.getElementById('mdTocMenuBtn');
    if (tocToggle && tocElement) {
      const toggleHandler = (e) => { e.stopPropagation(); tocState.isCollapsed = !tocState.isCollapsed; tocElement.classList.toggle('collapsed'); tocToggle.setAttribute('aria-expanded', !tocState.isCollapsed); localStorage.setItem('mdTocCollapsed', tocState.isCollapsed); };
      tocToggle.addEventListener('click', toggleHandler);
      tocState.clickHandlers.push({ element: tocToggle, event: 'click', handler: toggleHandler });
    }
    if (tocHeader && tocElement) {
      const headerHandler = () => { tocState.isCollapsed = !tocState.isCollapsed; tocElement.classList.toggle('collapsed'); if (tocToggle) { tocToggle.setAttribute('aria-expanded', !tocState.isCollapsed); } localStorage.setItem('mdTocCollapsed', tocState.isCollapsed); };
      tocHeader.addEventListener('click', headerHandler);
      tocState.clickHandlers.push({ element: tocHeader, event: 'click', handler: headerHandler });
    }
    if (miniBtn && tocElement) {
      // שחזור מיקום שמור
      applyMiniTop(getSavedMiniTop());
      const miniHandler = () => {
        tocElement.classList.remove('minimized');
        tocElement.classList.remove('collapsed');
        const tocToggle = document.getElementById('mdTocToggle');
        if (tocToggle) tocToggle.setAttribute('aria-expanded', 'true');
        tocState.isCollapsed = false;
        tocElement.style.display = 'block';
        miniBtn.style.display = 'none';
        tocState.isMinimized = false;
      };
      miniBtn.addEventListener('click', miniHandler);
      tocState.clickHandlers.push({ element: miniBtn, event: 'click', handler: miniHandler });

      // גרירה אנכית לריבוע הצף (שומר מיקום)
      let dragActive = false; let startY = 0; let startTop = 0; const onPointerDown = (ev) => {
        try { ev.preventDefault(); } catch(_){}
        dragActive = true; startY = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || 0;
        startTop = parseInt(window.getComputedStyle(miniBtn).top || '100', 10) || 100;
        try { miniBtn.setPointerCapture && miniBtn.setPointerCapture(ev.pointerId); } catch(_){}
      };
      const onPointerMove = (ev) => {
        if (!dragActive) return; const y = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || 0; const delta = y - startY; let newTop = startTop + delta; const maxTop = Math.max(60, window.innerHeight - 64); newTop = clamp(newTop, 60, maxTop); applyMiniTop(newTop);
      };
      const onPointerUp = (ev) => { if (!dragActive) return; dragActive = false; const top = parseInt(miniBtn.style.top || '100', 10) || 100; saveMiniTop(top); };
      miniBtn.addEventListener('pointerdown', onPointerDown, { passive: false });
      window.addEventListener('pointermove', onPointerMove, { passive: false });
      window.addEventListener('pointerup', onPointerUp);
      window.addEventListener('pointercancel', onPointerUp);
      // רישום לניקוי
      tocState.clickHandlers.push({ element: miniBtn, event: 'pointerdown', handler: onPointerDown });
      tocState.clickHandlers.push({ element: window, event: 'pointermove', handler: onPointerMove });
      tocState.clickHandlers.push({ element: window, event: 'pointerup', handler: onPointerUp });
      tocState.clickHandlers.push({ element: window, event: 'pointercancel', handler: onPointerUp });
    }
    // לחיצה ארוכה על סמל ☰ למזעור מהיר
    if (menuBtn) {
      let pressTimer = null;
      const start = (e) => { try { e.preventDefault(); } catch(_){}; clearTimeout(pressTimer); pressTimer = setTimeout(() => { minimizeTOC(); }, CONFIG.LONG_PRESS_MS); };
      const cancel = () => { clearTimeout(pressTimer); };
      const ctxHandler = (e)=>{ try{ e.preventDefault(); }catch(_){} };
      menuBtn.addEventListener('pointerdown', start);
      menuBtn.addEventListener('pointerup', cancel);
      menuBtn.addEventListener('pointerleave', cancel);
      menuBtn.addEventListener('contextmenu', ctxHandler);
      // רישום לניקוי
      tocState.clickHandlers.push({ element: menuBtn, event: 'pointerdown', handler: start });
      tocState.clickHandlers.push({ element: menuBtn, event: 'pointerup', handler: cancel });
      tocState.clickHandlers.push({ element: menuBtn, event: 'pointerleave', handler: cancel });
      tocState.clickHandlers.push({ element: menuBtn, event: 'contextmenu', handler: ctxHandler });
    }
    const savedCollapsed = localStorage.getItem('mdTocCollapsed');
    if (savedCollapsed === 'true') {
      tocElement?.classList.add('collapsed'); if (tocToggle) tocToggle.setAttribute('aria-expanded', 'false'); tocState.isCollapsed = true;
    }
  }
  function setupSearch() {
    const searchBtn = document.getElementById('mdTocSearch');
    const searchContainer = document.getElementById('tocSearchContainer');
    const searchInput = document.getElementById('tocSearchInput');
    const searchResults = document.getElementById('tocSearchResults');
    if (!searchBtn || !searchContainer || !searchInput) return;
    const searchBtnHandler = (e) => { e.stopPropagation(); const isVisible = searchContainer.style.display !== 'none'; searchContainer.style.display = isVisible ? 'none' : 'block'; if (!isVisible) { searchInput.focus(); } else { closeSearch(); } };
    searchBtn.addEventListener('click', searchBtnHandler);
    tocState.clickHandlers.push({ element: searchBtn, event: 'click', handler: searchBtnHandler });
    function escapeRegExp(string) { return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
    function highlightText(element, searchTerm) {
      const originalText = element.textContent; if (!searchTerm) { element.textContent = originalText; return; }
      element.textContent = ''; const escapedTerm = escapeRegExp(searchTerm); const regex = new RegExp(escapedTerm, 'gi'); let lastIndex = 0; let match; const maxIterations = 100; let iterations = 0;
      while ((match = regex.exec(originalText)) !== null && iterations < maxIterations) {
        iterations++; if (match.index > lastIndex) { const textNode = document.createTextNode(originalText.slice(lastIndex, match.index)); element.appendChild(textNode); }
        const mark = document.createElement('mark'); mark.textContent = match[0]; element.appendChild(mark); lastIndex = regex.lastIndex; if (regex.lastIndex === match.index) { regex.lastIndex++; }
      }
      if (lastIndex < originalText.length) { const textNode = document.createTextNode(originalText.slice(lastIndex)); element.appendChild(textNode); }
    }
    const searchHandler = debounce((e) => {
      const searchTerm = e.target.value.toLowerCase().trim(); const MAX_SEARCH_LENGTH = 100; if (searchTerm.length > MAX_SEARCH_LENGTH) { console.warn('TOC: חיפוש ארוך מדי'); return; }
      tocState.searchTerm = searchTerm; const items = document.querySelectorAll('.md-toc-item'); let matchCount = 0; items.forEach(item => { if (!item.dataset.originalText) { item.dataset.originalText = item.textContent; } const originalText = item.dataset.originalText; const text = originalText.toLowerCase(); if (!searchTerm) { item.classList.remove('search-hidden', 'search-match'); item.textContent = originalText; } else if (text.includes(searchTerm)) { item.classList.remove('search-hidden'); item.classList.add('search-match'); highlightText(item, searchTerm); matchCount++; } else { item.classList.add('search-hidden'); item.classList.remove('search-match'); item.textContent = originalText; } }); if (searchResults) { if (!searchTerm) { searchResults.textContent = ''; } else if (matchCount === 0) { searchResults.textContent = 'לא נמצאו תוצאות'; } else { searchResults.textContent = `נמצאו ${matchCount} תוצאות`; } }
    }, CONFIG.SEARCH_DEBOUNCE);
    searchInput.addEventListener('input', searchHandler);
    tocState.clickHandlers.push({ element: searchInput, event: 'input', handler: searchHandler });
    const escapeHandler = (e) => { if (e.key === 'Escape' && searchContainer.style.display !== 'none') { closeSearch(); } };
    searchInput.addEventListener('keydown', escapeHandler);
    tocState.clickHandlers.push({ element: searchInput, event: 'keydown', handler: escapeHandler });
  }
  function closeSearch() {
    const searchContainer = document.getElementById('tocSearchContainer');
    const searchInput = document.getElementById('tocSearchInput');
    const searchResults = document.getElementById('tocSearchResults');
    if (searchContainer) searchContainer.style.display = 'none'; if (searchInput) searchInput.value = ''; if (searchResults) searchResults.textContent = '';
    document.querySelectorAll('.md-toc-item').forEach(item => { item.classList.remove('search-hidden', 'search-match'); if (item.dataset.originalText) { item.textContent = item.dataset.originalText; } });
    tocState.searchTerm = '';
  }
  function setupKeyboardShortcuts() {
    const keyboardHandler = (e) => {
      if (e.ctrlKey && e.key === 't') { e.preventDefault(); const tocToggle = document.getElementById('mdTocToggle'); if (tocToggle) tocToggle.click(); }
      if (e.ctrlKey && e.key === 'f') { const tocElement = document.getElementById('mdToc'); if (tocElement && tocElement.contains(document.activeElement)) { e.preventDefault(); const searchBtn = document.getElementById('mdTocSearch'); if (searchBtn) searchBtn.click(); } }
      if (e.ctrlKey && e.key === 'm') { e.preventDefault(); toggleMinimize(); }
    };
    document.addEventListener('keydown', keyboardHandler);
    tocState.clickHandlers.push({ element: document, event: 'keydown', handler: keyboardHandler });
  }
  function setMinimizedPreference(isMinimized){
    try {
      // שמירה גלובלית
      localStorage.setItem(CONFIG.MINIMIZED_KEY_GLOBAL, isMinimized ? '1' : '0');
      // שמירה פר-קובץ
      if (typeof FILE_ID !== 'undefined' && FILE_ID) {
        localStorage.setItem(CONFIG.MINIMIZED_KEY_PER_FILE_PREFIX + FILE_ID, isMinimized ? '1' : '0');
      }
    } catch(_) {}
  }
  function getSavedMinimizedPreference(){
    try {
      // עדיפות להגדרה פר-קובץ אם קיימת
      if (typeof FILE_ID !== 'undefined' && FILE_ID) {
        const perFile = localStorage.getItem(CONFIG.MINIMIZED_KEY_PER_FILE_PREFIX + FILE_ID);
        if (perFile === '1' || perFile === '0') return perFile === '1';
      }
      const globalVal = localStorage.getItem(CONFIG.MINIMIZED_KEY_GLOBAL);
      if (globalVal === '1' || globalVal === '0') return globalVal === '1';
    } catch(_) {}
    return false;
  }
  function minimizeTOC(){
    const tocElement = document.getElementById('mdToc');
    const miniBtn = document.getElementById('mdTocMini');
    if (!tocElement || !miniBtn) return;
    tocState.isMinimized = true;
    tocElement.style.display = 'none';
    miniBtn.style.display = 'block';
    applyMiniTop(parseInt(miniBtn.style.top||String(getSavedMiniTop()),10));
    setMinimizedPreference(true);
  }
  function restoreTOC(){
    const tocElement = document.getElementById('mdToc');
    const miniBtn = document.getElementById('mdTocMini');
    if (!tocElement || !miniBtn) return;
    tocState.isMinimized = false;
    tocElement.style.display = 'block';
    miniBtn.style.display = 'none';
    setMinimizedPreference(false);
  }
  function toggleMinimize() { if (tocState.isMinimized) { restoreTOC(); } else { minimizeTOC(); } }
  function setupProgressIndicator() {
    const progressBar = document.getElementById('tocProgressBar'); if (!progressBar) return; const updateProgress = () => { const scrollHeight = document.documentElement.scrollHeight - window.innerHeight; const scrollPosition = window.scrollY; const percentage = Math.round((scrollPosition / scrollHeight) * 100); progressBar.style.width = `${percentage}%`; tocState.scrollPercentage = percentage; const progressContainer = document.querySelector('.md-toc-progress'); if (progressContainer) { progressContainer.setAttribute('aria-valuenow', percentage); } };
    updateProgress(); let progressTicking = false; const progressHandler = () => { if (!progressTicking) { window.requestAnimationFrame(() => { updateProgress(); progressTicking = false; }); progressTicking = true; } };
    window.addEventListener('scroll', progressHandler, { passive: true });
    tocState.clickHandlers.push({ element: window, event: 'scroll', handler: progressHandler });
  }
  function init() {
    try {
      console.info('TOC: מתחיל אתחול');
      waitForContent(buildTOC);
      window.addEventListener('beforeunload', cleanup);
      if (window.navigation && typeof window.navigation.addEventListener === 'function') {
        const navHandler = (event) => {
          try {
            if (event && event.destination && event.destination.sameDocument) {
              return;
            }
          } catch(_) {}
          cleanup();
        };
        window.navigation.addEventListener('navigate', navHandler);
        tocState.clickHandlers.push({ element: window.navigation, event: 'navigate', handler: navHandler });
      }
      // יישר מיקום התפריט והכפתור המינימלי לשורה אחת בצד שמאל
      applyMiniTop(getSavedMiniTop());
      // שחזור העדפת מיזעור (גלובלי/פר-קובץ)
      if (getSavedMinimizedPreference()) {
        // נבטיח שהכפתור המינימלי נראה כבר בטעינה
        const tocElement = document.getElementById('mdToc');
        const miniBtn = document.getElementById('mdTocMini');
        if (tocElement && miniBtn) {
          tocElement.style.display = 'none';
          miniBtn.style.display = 'block';
          tocState.isMinimized = true;
        }
      }
    } catch (e) { console.error('TOC: שגיאה באתחול', e); hideTOC(); }
  }
  init();
})();
// מסך מלא ל- Markdown Card
(function(){
  try {
    const btn = document.getElementById('mdFullscreenBtn2');
    const card = document.getElementById('mdCard');
    if (!btn || !card) return;
    function isFullscreen(){ return document.fullscreenElement === card; }
    function updateButton(){
      if (isFullscreen()) {
        btn.innerHTML = '<i class="fas fa-compress"></i><span>יציאה</span>';
        // Fallback: הסתרת TOC במצב מסך מלא גם אם כלל ה-CSS לא תופס
        try {
          const toc = document.getElementById('mdToc');
          const mini = document.getElementById('mdTocMini');
          if (toc) { toc.dataset.prevDisplay = toc.style.display || ''; toc.style.display = 'none'; }
          if (mini) { mini.dataset.prevDisplay = mini.style.display || ''; mini.style.display = 'none'; }
        } catch(_) {}
      } else {
        btn.innerHTML = '<i class="fas fa-expand"></i><span>מסך מלא</span>';
        // Fallback: שחזור מצב ה-TOC לאחר יציאה ממסך מלא
        try {
          const toc = document.getElementById('mdToc');
          const mini = document.getElementById('mdTocMini');
          if (toc && Object.prototype.hasOwnProperty.call(toc.dataset, 'prevDisplay')) {
            toc.style.display = toc.dataset.prevDisplay;
            delete toc.dataset.prevDisplay;
          }
          if (mini && Object.prototype.hasOwnProperty.call(mini.dataset, 'prevDisplay')) {
            mini.style.display = mini.dataset.prevDisplay;
            delete mini.dataset.prevDisplay;
          }
        } catch(_) {}
      }
    }
    btn.addEventListener('click', async function(){
      try {
        if (!isFullscreen()) { await card.requestFullscreen(); }
        else { await document.exitFullscreen(); }
      } catch(_) {}
    });
    document.addEventListener('fullscreenchange', updateButton);
    updateButton();
  } catch(_) {}
})();

function fallbackCopy(text) {
  try {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    textarea.style.opacity = '0';
    document.body.appendChild(textarea);
    textarea.select();
    const success = document.execCommand('copy');
    document.body.removeChild(textarea);
    return success;
  } catch(_) {
    return false;
  }
}

function copyMarkdownSource(ev){
  try { if (ev) ev.preventDefault(); } catch(_){ }
  const text = (typeof MD_TEXT === 'string') ? MD_TEXT : '';
  if (!text) {
    alert('לא נמצא קוד להעתקה');
    return false;
  }
  const btn = document.getElementById('mdCopySourceBtn');
  const labelEl = btn ? (btn.querySelector('[data-copy-label]') || btn.querySelector('.btn-text') || btn) : null;
  const originalLabel = (btn && btn.dataset && btn.dataset.originalLabel) ? btn.dataset.originalLabel
    : (labelEl ? labelEl.textContent : 'העתק קוד');
  if (btn && btn.dataset && !btn.dataset.originalLabel) {
    btn.dataset.originalLabel = originalLabel;
  }
  function setLabel(value){
    if (labelEl && value) {
      labelEl.textContent = value;
    }
  }
  (async function(){
    let success = false;
    try {
      await navigator.clipboard.writeText(text);
      success = true;
    } catch(_) {
      success = fallbackCopy(text);
    }
    if (success) {
      setLabel('הועתק!');
      setTimeout(() => setLabel(originalLabel), 1800);
    } else {
      alert('לא הצלחנו להעתיק את הקוד');
    }
  })();
  return false;
}

// === "העתק כמארקדאון" — העתקת קטע מסומן כ-Markdown מקורי ===
(function initCopySelectionAsMarkdown() {
  const container = document.getElementById('md-content');
  const fab = document.getElementById('mdCopySelectionFab');
  if (!container || !fab) return;

  const sourceLines = (typeof MD_TEXT === 'string' ? MD_TEXT : '').split('\n');

  // Precompute whether each line is inside a fenced code block.
  // This is important so we won't strip markdown-like syntax that is literal inside code.
  const inFencedBlock = (function computeInFencedBlock() {
    const arr = new Array(sourceLines.length).fill(false);
    let open = null; // { ch, len }
    for (let i = 0; i < sourceLines.length; i++) {
      const info = _parseFenceInfo(sourceLines[i]);
      if (info) {
        if (!open) {
          open = { ch: info.ch, len: info.len };
          // Fence line itself is not considered "inside" for stripping purposes
          arr[i] = false;
          continue;
        }
        // Closing fence must not contain non-whitespace after marker (CommonMark)
        if (info.ch === open.ch && info.len >= open.len && info.tailIsWhitespace) {
          open = null;
          arr[i] = false;
          continue;
        }
      }
      arr[i] = !!open;
    }
    return arr;
  })();

  function normalize(str) {
    return (str || '')
      .replace(/\s+/g, ' ')
      .trim()
      .toLowerCase();
  }

  function stripMarkdownSyntax(line, idx) {
    // בתוך fenced code block כל התווים הם ליטרליים – לא מסירים *_` וכו'
    if (typeof idx === 'number' && idx >= 0 && idx < inFencedBlock.length && inFencedBlock[idx]) {
      return (line || '');
    }
    return (line || '')
      .replace(/^#{1,6}\s+/, '')                 // כותרות
      .replace(/^>\s?/gm, '')                    // ציטוטים
      .replace(/^[-*+]\s+/, '')                  // רשימות
      .replace(/^\d+\.\s+/, '')                  // רשימות ממוספרות
      .replace(/^[-*_]{3,}\s*$/, '')             // קווים אופקיים
      .replace(/\*\*(.+?)\*\*/g, '$1')           // bold
      .replace(/__(.+?)__/g, '$1')
      .replace(/\*(.+?)\*/g, '$1')               // italic
      .replace(/_(.+?)_/g, '$1')
      .replace(/~~(.+?)~~/g, '$1')               // strikethrough
      .replace(/==(.+?)==/g, '$1')               // mark
      .replace(/`([^`]+)`/g, '$1')               // inline code
      .replace(/!\[([^\]]*)\]\([^)]*\)/g, '$1')  // images
      .replace(/\[([^\]]*)\]\([^)]*\)/g, '$1');  // links
  }

  function _countExactMatches(needleNorm) {
    let count = 0;
    for (let i = 0; i < sourceLines.length; i++) {
      const hay = normalize(stripMarkdownSyntax(sourceLines[i], i));
      if (!hay) continue;
      if (hay === needleNorm) {
        count++;
        if (count > 1) return count;
      }
    }
    return count;
  }

  function _lineMatches(haystack, needle) {
    const MIN_SUBSTRING_LEN = 8;
    const MIN_UNIQUE_EXACT_LEN = 5;
    const CONTAINS_MIN_RATIO = 0.6; // needle is substantial part of haystack
    const REVERSE_CONTAINS_MAX_DELTA_RATIO = 0.15; // allow small expansions only

    if (!haystack || !needle) return false;

    if (haystack === needle) {
      // שורות קצרות/עמומות ("a", "1.", "}") יגרמו להרבה false positives — נקבל רק אם זה ייחודי במסמך
      if (needle.length < MIN_UNIQUE_EXACT_LEN) {
        return _countExactMatches(needle) === 1;
      }
      return true;
    }

    if (haystack.length < MIN_SUBSTRING_LEN || needle.length < MIN_SUBSTRING_LEN) return false;

    // הכיוון הבטוח: הטקסט המסומן (needle) הוא תת-מחרוזת של שורת המקור (haystack)
    if (haystack.includes(needle)) {
      if ((needle.length / haystack.length) >= CONTAINS_MIN_RATIO) return true;
    }

    // כיוון הפוך (needle כולל haystack) עלול להוביל ל-anchoring שגוי; נאפשר רק אם זה כמעט אותו אורך
    if (needle.includes(haystack)) {
      const deltaRatio = Math.abs(needle.length - haystack.length) / Math.max(needle.length, haystack.length);
      if (deltaRatio <= REVERSE_CONTAINS_MAX_DELTA_RATIO) return true;
    }

    return false;
  }

  function findFirstLineIndex(searchText, startFrom) {
    const needle = normalize(searchText);
    if (!needle) return -1;
    for (let i = startFrom; i < sourceLines.length; i++) {
      const haystack = normalize(stripMarkdownSyntax(sourceLines[i], i));
      if (!haystack) continue;
      if (_lineMatches(haystack, needle)) return i;
    }
    return -1;
  }

  function findLastLineIndex(searchText, startFrom, endAt) {
    const needle = normalize(searchText);
    if (!needle) return -1;
    const end = Math.min(sourceLines.length - 1, Math.max(startFrom, endAt));
    for (let i = end; i >= startFrom; i--) {
      const haystack = normalize(stripMarkdownSyntax(sourceLines[i], i));
      if (!haystack) continue;
      if (_lineMatches(haystack, needle)) return i;
    }
    return -1;
  }

  function _parseFenceInfo(line) {
    const m = (line || '').trim().match(/^(```+|~~~+)(.*)$/);
    if (!m) return null;
    const marker = m[1] || '';
    if (marker.length < 3) return null;
    const tail = (m[2] || '');
    return { ch: marker[0], len: marker.length, tailIsWhitespace: /^\s*$/.test(tail) };
  }

  function _getEnclosingFenceRange(lineIndex) {
    if (lineIndex < 0 || lineIndex >= sourceLines.length) return null;

    // האם אנחנו "בתוך" fenced block? (סורקים מהתחלה עד השורה)
    let open = null; // {ch,len,start}
    for (let i = 0; i <= lineIndex; i++) {
      const info = _parseFenceInfo(sourceLines[i]);
      if (!info) continue;
      if (!open) {
        open = { ch: info.ch, len: info.len, start: i };
        continue;
      }
      // בתוך בלוק: נסגור רק עם אותו marker ואורך fence תואם/ארוך יותר (markdown rule)
      if (info.ch === open.ch && info.len >= open.len && info.tailIsWhitespace) {
        open = null;
      }
    }
    if (!open) return null;

    // מצא fence סוגר
    for (let j = lineIndex + 1; j < sourceLines.length; j++) {
      const info = _parseFenceInfo(sourceLines[j]);
      if (!info) continue;
      if (info.ch === open.ch && info.len >= open.len && info.tailIsWhitespace) {
        return { start: open.start, end: j };
      }
    }
    return null;
  }

  function mapSelectionToSource(selectedText) {
    if (!selectedText || !sourceLines.length) return '';

    // חשוב לשמור שורות ריקות כדי לא "לכווץ" בחירה של כמה פסקאות / בלוקים.
    const selLinesAll = selectedText.split('\n').map(l => (l || '').trim());
    const selNonEmpty = selLinesAll.filter(l => l.length > 0);
    if (!selNonEmpty.length) return '';

    function findFirstLineIndexInRange(searchText, startFrom, endAt) {
      const needle = normalize(searchText);
      if (!needle) return -1;
      const end = Math.min(sourceLines.length - 1, Math.max(startFrom, endAt));
      for (let i = startFrom; i <= end; i++) {
        const haystack = normalize(stripMarkdownSyntax(sourceLines[i], i));
        if (!haystack) continue;
        if (_lineMatches(haystack, needle)) return i;
      }
      return -1;
    }

    function findCandidateStartIndices(searchText, maxCandidates) {
      const needle = normalize(searchText);
      if (!needle) return [];
      const res = [];
      for (let i = 0; i < sourceLines.length; i++) {
        const haystack = normalize(stripMarkdownSyntax(sourceLines[i], i));
        if (!haystack) continue;
        if (_lineMatches(haystack, needle)) {
          res.push(i);
          if (res.length >= maxCandidates) break;
        }
      }
      return res;
    }

    function pickBestStartIndex() {
      const firstNeedle = selNonEmpty[0];
      const lastNeedle = selNonEmpty[selNonEmpty.length - 1];
      const candidates = findCandidateStartIndices(firstNeedle, 80);
      if (!candidates.length) return -1;

      const LOOKAHEAD_MIN = 200;
      const LOOKAHEAD_PER_SEL_LINE = 120;
      const LOOKAHEAD_MAX = 5000;
      const baseWindow = Math.min(
        LOOKAHEAD_MAX,
        Math.max(LOOKAHEAD_MIN, selLinesAll.length * LOOKAHEAD_PER_SEL_LINE)
      );

      let bestIdx = candidates[0];
      let bestScore = -Infinity;
      let bestEndDelta = Infinity;

      const prefixCount = Math.min(6, selNonEmpty.length);
      for (const c of candidates) {
        const endHint = Math.min(sourceLines.length - 1, c + baseWindow);

        // נסה לאמת עוגן בעזרת כמה שורות רצופות מהבחירה (כדי להימנע מעיגון על שורה "נפוצה")
        let matched = 1;
        let cursor = c + 1;
        let lastPrefixIdx = c;
        for (let k = 1; k < prefixCount; k++) {
          const idx = findFirstLineIndexInRange(selNonEmpty[k], cursor, endHint);
          if (idx < 0) break;
          matched++;
          lastPrefixIdx = idx;
          cursor = idx + 1;
        }

        const endIdx = findLastLineIndex(lastNeedle, c, endHint);
        const expectedEnd = c + selLinesAll.length;
        const endDelta = (endIdx >= 0) ? Math.abs(endIdx - expectedEnd) : Infinity;

        // ניקוד: יותר התאמות רצופות + סוף סביר באזור + העדפה לטווח קומפקטי
        const span = ((endIdx >= 0 ? endIdx : lastPrefixIdx) - c);
        let score = matched * 100;
        if (endIdx >= 0) score += 50;
        score -= Math.min(250, Math.max(0, span - (selLinesAll.length * 2)));
        if (endIdx >= 0) score -= Math.min(200, endDelta);

        // Tie-breakers:
        // 1) סוף קרוב יותר לאורך הבחירה
        // 2) אם עדיין שוויון — העדף הופעה מאוחרת יותר (בדרך כלל זה מה שהמשתמש התכוון לבחור)
        const better =
          (score > bestScore) ||
          (score === bestScore && endDelta < bestEndDelta) ||
          (score === bestScore && endDelta === bestEndDelta && c > bestIdx);

        if (better) {
          bestIdx = c;
          bestScore = score;
          bestEndDelta = endDelta;
        }
      }
      return bestIdx;
    }

    let firstSourceIdx = pickBestStartIndex();
    if (firstSourceIdx < 0) return '';

    let lastSourceIdx = firstSourceIdx;
    const LOOKAHEAD_MIN = 200;
    const LOOKAHEAD_PER_SEL_LINE = 120;
    const LOOKAHEAD_MAX = 5000;
    const endHint = (firstSourceIdx >= 0)
      ? Math.min(
        sourceLines.length - 1,
        firstSourceIdx + Math.min(
          LOOKAHEAD_MAX,
          Math.max(LOOKAHEAD_MIN, selLinesAll.length * LOOKAHEAD_PER_SEL_LINE)
        )
      )
      : (sourceLines.length - 1);

    for (let i = selNonEmpty.length - 1; i >= 0; i--) {
      // חפש את ההופעה האחרונה "באזור" הבחירה – לא בסוף כל המסמך כדי להימנע מהתרחבות ענקית.
      let idx = findLastLineIndex(selNonEmpty[i], Math.max(0, firstSourceIdx), endHint);
      if (idx < 0 && firstSourceIdx >= 0) {
        idx = findLastLineIndex(selNonEmpty[i], Math.max(0, firstSourceIdx), Math.min(sourceLines.length - 1, firstSourceIdx + LOOKAHEAD_MAX));
      }
      if (idx >= 0) {
        lastSourceIdx = Math.max(lastSourceIdx, idx);
        break;
      }
    }

    // הרחבה ל-fenced blocks: בדוק גם את תחילת הבחירה וגם את סופה כדי לא לייצר fences "שבורים"
    const fenceRangeStart = _getEnclosingFenceRange(firstSourceIdx);
    if (fenceRangeStart && fenceRangeStart.end > fenceRangeStart.start) {
      if (fenceRangeStart.start <= firstSourceIdx && fenceRangeStart.end >= firstSourceIdx) {
        firstSourceIdx = Math.min(firstSourceIdx, fenceRangeStart.start);
        lastSourceIdx = Math.max(lastSourceIdx, fenceRangeStart.end);
      }
    }
    const fenceRangeEnd = _getEnclosingFenceRange(lastSourceIdx);
    if (fenceRangeEnd && fenceRangeEnd.end > fenceRangeEnd.start) {
      if (fenceRangeEnd.start <= lastSourceIdx && fenceRangeEnd.end >= lastSourceIdx) {
        firstSourceIdx = Math.min(firstSourceIdx, fenceRangeEnd.start);
        lastSourceIdx = Math.max(lastSourceIdx, fenceRangeEnd.end);
      }
    }

    return sourceLines.slice(firstSourceIdx, lastSourceIdx + 1).join('\n');
  }

  let _copyFeedbackTimer = null;
  function _getFabLabelEl() {
    return fab.querySelector('.md-copy-selection-fab__label') || fab;
  }
  function _getFabOriginalLabel() {
    const labelEl = _getFabLabelEl();
    const original = (fab.dataset && fab.dataset.originalLabel)
      ? fab.dataset.originalLabel
      : (labelEl ? labelEl.textContent : 'העתק כמארקדאון');
    if (fab.dataset && !fab.dataset.originalLabel) {
      fab.dataset.originalLabel = original;
    }
    return original;
  }
  function _clearCopyFeedbackTimer() {
    if (_copyFeedbackTimer) {
      clearTimeout(_copyFeedbackTimer);
      _copyFeedbackTimer = null;
    }
  }
  function _resetFabLabel() {
    const labelEl = _getFabLabelEl();
    const original = _getFabOriginalLabel();
    try { if (labelEl) labelEl.textContent = original; } catch(_) {}
  }

  function positionFab(range) {
    const rect = range.getBoundingClientRect();
    const card = container.closest('.glass-card') || container;
    const cardRect = card.getBoundingClientRect();

    // getBoundingClientRect נותן קואורדינטות ביחס ל-viewport.
    // ב-fullscreen ה-card נהיה scroll-container, לכן צריך להוסיף scrollTop.
    const scrollTop = (card && typeof card.scrollTop === 'number') ? card.scrollTop : 0;
    const scrollLeft = (card && typeof card.scrollLeft === 'number') ? Math.max(0, card.scrollLeft) : 0;

    const top = rect.top - cardRect.top + scrollTop - fab.offsetHeight - 8;
    fab.style.top = Math.max(8, top) + 'px';
    fab.style.right = Math.max(8, (cardRect.right - rect.right) + scrollLeft) + 'px';
    fab.style.left = '';
  }

  function showFab(range) {
    _clearCopyFeedbackTimer();
    _resetFabLabel();
    fab.classList.remove('is-copied');
    fab.classList.add('is-visible');
    requestAnimationFrame(() => positionFab(range));
  }

  function hideFab() {
    fab.classList.remove('is-visible', 'is-copied');
  }

  let hideTimer = null;

  document.addEventListener('selectionchange', () => {
    if (hideTimer) clearTimeout(hideTimer);
    hideTimer = setTimeout(() => {
      const sel = window.getSelection();
      if (!sel || sel.isCollapsed || !sel.rangeCount) {
        hideFab();
        return;
      }

      const range = sel.getRangeAt(0);
      if (!container.contains(range.commonAncestorContainer)) {
        hideFab();
        return;
      }

      const text = sel.toString().trim();
      if (text.length < 2) {
        hideFab();
        return;
      }

      showFab(range);
    }, 250);
  });

  fab.addEventListener('mousedown', (e) => {
    e.preventDefault();
    e.stopPropagation();
  });

  fab.addEventListener('click', async (e) => {
    e.preventDefault();
    e.stopPropagation();

    const sel = window.getSelection();
    const selectedText = sel ? sel.toString().trim() : '';
    if (!selectedText) return;

    const markdown = mapSelectionToSource(selectedText);
    const textToCopy = markdown || selectedText;

    let success = false;
    try {
      await navigator.clipboard.writeText(textToCopy);
      success = true;
    } catch (_) {
      try {
        success = (typeof fallbackCopy === 'function') ? fallbackCopy(textToCopy) : false;
      } catch(_) {
        success = false;
      }
    }

    if (!success) return;

    _clearCopyFeedbackTimer();
    const labelEl = _getFabLabelEl();
    const originalLabel = _getFabOriginalLabel();
    fab.classList.add('is-copied');
    if (labelEl) {
      labelEl.textContent = markdown ? 'הועתק כמארקדאון!' : 'הועתק!';
    }
    _copyFeedbackTimer = setTimeout(() => {
      _copyFeedbackTimer = null;
      try {
        if (labelEl) labelEl.textContent = originalLabel;
      } catch(_) {}
      try { fab.classList.remove('is-copied'); } catch(_) {}

      // אם עדיין יש סלקציה פעילה בתוך הקונטיינר – אל תעלים את הכפתור, רק החזר תווית ומיקום
      try {
        const curSel = window.getSelection();
        if (curSel && !curSel.isCollapsed && curSel.rangeCount) {
          const r = curSel.getRangeAt(0);
          if (container.contains(r.commonAncestorContainer)) {
            showFab(r);
            return;
          }
        }
      } catch(_) {}

      hideFab();
    }, 1500);
  });
})();

let shareLinkModalKeyHandlerMd = null;

function openShareLinkModalMd(){
  const modal = document.getElementById('shareLinkModalMd');
  if (!modal){
    copyShareLinkMd(false);
    return;
  }
  modal.hidden = false;
  if (!modal.dataset.boundBackdrop){
    modal.addEventListener('click', function(ev){
      if (ev.target === modal){ closeShareLinkModalMd(); }
    });
    modal.dataset.boundBackdrop = '1';
  }
  if (shareLinkModalKeyHandlerMd){
    try {
      document.removeEventListener('keydown', shareLinkModalKeyHandlerMd);
    } catch(_){ }
  }
  shareLinkModalKeyHandlerMd = function(ev){
    try {
      if (ev.key === 'Escape'){
        ev.preventDefault();
        closeShareLinkModalMd();
      }
    } catch(_){ }
  };
  document.addEventListener('keydown', shareLinkModalKeyHandlerMd);
  setTimeout(() => {
    try {
      const firstButton = modal.querySelector('.share-link-modal__actions button');
      if (firstButton){ firstButton.focus(); }
    } catch(_){ }
  }, 0);
}

function closeShareLinkModalMd(){
  const modal = document.getElementById('shareLinkModalMd');
  if (!modal){ return; }
  modal.hidden = true;
  if (shareLinkModalKeyHandlerMd){
    document.removeEventListener('keydown', shareLinkModalKeyHandlerMd);
    shareLinkModalKeyHandlerMd = null;
  }
}

async function requestShareLinkMd(permanent){
  let baseUrl = window.location.href;
  try {
    const resp = await fetch(`/api/share/{{ file.id }}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        type: permanent ? 'permanent' : 'temporary',
        permanent: !!permanent
      })
    });
    const data = await resp.json();
    if (data && data.ok && data.url){
      baseUrl = data.url;
    }
  } catch(err){
    console.error('share create failed', err);
  }
  try {
    const u = new URL(baseUrl, window.location.origin);
    u.searchParams.set('view','md');
    return u.toString();
  } catch(_){
    return baseUrl + (baseUrl.includes('?') ? '&' : '?') + 'view=md';
  }
}

async function copyShareLinkMd(permanent){
  try { closeShareLinkModalMd(); } catch(_){ }
  const url = await requestShareLinkMd(!!permanent);
  const successMessage = permanent ? 'הקישור הקבוע הועתק!' : 'הקישור הזמני הועתק!';
  try {
    await navigator.clipboard.writeText(url);
    alert(successMessage);
  } catch(e){
    console.error('copy failed', e);
    alert('לא הצלחנו להעתיק את הקישור');
  }
}

async function shareToTelegramMd(){
  const url = await requestShareLinkMd(false);
  const text = `צפה במסמך Markdown ב-Code Keeper:`;
  const telegramUrl = `https://t.me/share/url?url=${encodeURIComponent(url)}&text=${encodeURIComponent(text)}`;
  try { window.open(telegramUrl, '_blank'); }
  catch(_){ window.location.href = telegramUrl; }
}

// ניווט חזרה אמין: תמיד מחזיר לתצוגת הקוד של הקובץ
function goBackToFile(ev){
  try { if (ev) ev.preventDefault(); } catch(_){ }
  try {
    if (window.location && typeof window.location.replace === 'function') {
      window.location.replace(FILE_VIEW_URL);
    } else {
      window.location.href = FILE_VIEW_URL;
    }
  } catch(_) {
    window.location.href = FILE_VIEW_URL;
  }
  return false;
}

// כפתור "חזור" כללי – אם אין היסטוריה חוזרים לרשימת הקבצים
function goBackTwoSteps(ev){
  try { if (ev) ev.preventDefault(); } catch(_){ }
  try {
    if (window.history && window.history.length > 2) {
      window.history.go(-2);
      return false;
    }
    // Fallback: צעד אחד אחורה
    if (window.history && window.history.length > 1) {
      window.history.back();
      return false;
    }
    if (document.referrer) {
      const ref = new URL(document.referrer, window.location.origin);
      if (ref.origin === window.location.origin) {
        window.location.href = ref.toString();
        return false;
      }
    }
  } catch(_){ }
  window.location.href = '/files';
  return false;
}

// התאמת גודל שם הקובץ: מצמצם פונט הדרגתי עד שנכנס בשורה אחת (עם מינימום מוגן)
(function(){
  try {
    var el = document.getElementById('md-file-name');
    if (!el) return;
    el.setAttribute('title', el.textContent || '');
    var sizeRem = 1.6;    // גודל יעד התחלתי (התואם ל-CSS)
    var minRem = 1.0;     // מינימום – לא קטן מדי
    el.style.fontSize = sizeRem + 'rem';
    var guard = 0;
    while (guard < 15 && el.scrollWidth > el.clientWidth && sizeRem > minRem) {
      sizeRem -= 0.1;
      el.style.fontSize = sizeRem.toFixed(2) + 'rem';
      guard++;
    }
  } catch(_) { }
})();
</script>
<link rel="stylesheet" href="{{ url_for('static', filename='css/sticky-notes.css') }}">
<script src="{{ url_for('static', filename='js/sticky-notes.js') }}"></script>
<script>
  // אתחול פתקים דביקים רק לאחר שרינדור ה-Markdown הושלם (או fallback בטוח)
  (function(){
    try{
      function readyForNotes(){
        const c = document.getElementById('md-content');
        return !!(c && c.innerHTML.trim().length > 0);
      }
      function doInit(){
        if (window._stickyNotes) return; // מניעת כפילויות
        if (typeof window.StickyNotesManager !== 'function') return;
        if (!window.FILE_ID) return;
        if (!readyForNotes()) return;
        // אל תציג למבקרים ציבוריים
        {% if not is_public %}
        window._stickyNotes = new window.StickyNotesManager(window.FILE_ID);
        {% endif %}
      }
      // העדפה: המתן לאירוע מותאם של רינדור ה-Markdown
      document.addEventListener('md:rendered', () => { try { doInit(); } catch(_){} }, { once: true });
      // Fallback: אם האירוע לא יופעל מסיבה כלשהי, ננסה לאחר DOMContentLoaded ואז בעוד קצת זמן
      const fallbackInit = () => {
        if (readyForNotes()) { doInit(); return; }
        setTimeout(() => { try { doInit(); } catch(_){} }, 500);
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', fallbackInit);
      } else {
        fallbackInit();
      }
    } catch(e) { console.warn('sticky notes init failed', e); }
  })();
</script>
{% if not is_public %}{% include 'bookmarks_snippet.html' %}{% endif %}
{% endblock %}

