{% extends "base.html" %}

{% block title %}{{ file.file_name }} - Markdown Preview{% endblock %}

{% block extra_css %}
<style>
/* אזור התצוגה והביצועים */
#md-root {
  /* הרחבת אזור התוכן הלבן לצדדים והרחקה מהשוליים הסגולים */
  max-width: min(1600px, 100vw);
  margin: 0 auto;
  padding: 0.5rem 0; /* את הריווח הצדדי ניתן דרך הכרטיס הפנימי */
}
#md-content {
  background: #ffffff;
  color: #111111;
  border-radius: 12px;
  border: none; /* ביטול מסגרת (שנתפסה כ"סגולה") */
  padding: 14px; /* ריווח אחיד ועדין – לא מרחיק את הבלוק מהגבול */
  transition: background-color 0.3s ease, color 0.3s ease;
}

/* צבעי רקע חומים לתצוגת מארקדאון */
#md-content.bg-light {
  background: #f5e6d3;
  color: #2d2d2d;
}

#md-content.bg-medium {
  background: #e8d4b0;
  color: #1a1a1a;
}

#md-content.bg-dark {
  background: #d4b896;
  color: #0d0d0d;
}

/* התאמת צבעי אלמנטים פנימיים לרקע החום */
#md-content.bg-light code:not(pre code),
#md-content.bg-medium code:not(pre code),
#md-content.bg-dark code:not(pre code) {
  background: rgba(255, 255, 255, 0.4);
  border: 1px solid rgba(0, 0, 0, 0.1);
}

#md-content.bg-light blockquote,
#md-content.bg-medium blockquote,
#md-content.bg-dark blockquote {
  background: rgba(255, 255, 255, 0.3);
  border-inline-start-color: rgba(0, 0, 0, 0.2);
}

#md-content.bg-light table thead,
#md-content.bg-medium table thead,
#md-content.bg-dark table thead {
  background: rgba(255, 255, 255, 0.3);
}

#md-content.bg-light table th,
#md-content.bg-light table td,
#md-content.bg-medium table th,
#md-content.bg-medium table td,
#md-content.bg-dark table th,
#md-content.bg-dark table td {
  border-color: rgba(0, 0, 0, 0.1);
}

/* hover effect for color options */
.bg-color-option:hover {
  transform: scale(1.05);
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.bg-color-option.active {
  border: 2px solid #4a90e2 !important;
  box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
}
/* במסך מלא – לאפשר גלילה בתוך הכרטיס עצמו (תמיכה גם ב-WebKit) */
#mdCard:fullscreen { height: 100vh; overflow: auto; }
#mdCard:-webkit-full-screen { height: 100vh; overflow: auto; }
#md-content img {
  max-width: 100%;
  height: auto;
}
/* הרחבת הקונטיינר בעמוד Markdown כדי לצמצם את הסגול בצדדים */
.main-content > .container {
  /* מכולה רחבה כדי לצמצם "סגול" בצדדים */
  max-width: 100% !important;
  width: 100% !important;
  padding-left: 8px !important;
  padding-right: 8px !important;
}
/* בעמוד Markdown בלבד: צמצום הפס הסגול משמאל – מרחיבים את הכרטיס שמאלה */
.main-content .glass-card {
  margin-left: 0 !important;        /* שמאל קרוב יותר לקצה */
  margin-right: 0.5rem !important;  /* שומרים על ימין קיים */
  width: calc(100% - 0.5rem) !important;
}
/* טבלאות בסגנון GitHub */
#md-content table {
  width: 100%;
  border-collapse: collapse;
  overflow: auto;
  display: block;
}
#md-content table th, #md-content table td {
  border: 1px solid #e5e7eb;
  padding: 0.5rem 0.75rem;
}
#md-content table thead {
  background: #f8fafc;
}
/* קוד (fenced) */
#md-content pre code,
#md-content pre > code,
#md-content code.hljs {
  display: block;
  /* נשמור על ריווח מינימלי בתוך תגית הקוד עצמה – דק שלא יבטל הדגשות */
  padding: 0 2px 0 0;            /* תוספת עדינה מימין ב-RTL */
  border-radius: 8px;
  font-family: 'Fira Code', 'Consolas', monospace;
  font-size: 16px;               /* נגישות טובה יותר */
  line-height: 1.5;              /* רווח אנכי טוב */
  /* גלילה אופקית במקום עטיפה – כדי לא לחתוך קוד ארוך */
  white-space: pre !important;
  word-break: normal !important;
  overflow-wrap: normal !important;
}
#md-content .md-highlight {
  background: linear-gradient(90deg, #ffd700 0%, #ffed4e 100%);
  color: #000;
  padding: 2px 4px;
  border-radius: 3px;
  font-weight: 600;
}
#md-content pre { overflow-x: auto; max-width: 100%; margin: 1rem 0; width: 100%; }
#md-content .hljs { overflow-x: auto; display: block; }
#md-content pre {
  background: linear-gradient(135deg, #1e3a5f 0%, #2d4a6f 100%);
  border: 0;                        /* הסרת מסגרת דקה שמצטיירת כסגולה */
  border-radius: 12px;
  padding: 16px;                    /* בסיס */
  /* ריווח פנימי סימטרי בתוך הבלוק – כדי שהקוד לא ייגע בגבולות */
  padding-right: clamp(22px, 6vw, 36px);
  padding-left: clamp(22px, 6vw, 36px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  overflow-x: auto;
  margin: 1em 0;                    /* אין מרווח שלילי – לא שוברים פריסה */
  width: 100%;                      /* מילוי רוחב הכרטיס, ללא גלישה */
  color: #e8eaed;                   /* Fallback: טקסט בהיר אם hljs לא נטען */
  box-sizing: border-box;
}
#md-content pre code {
  display: block;
  overflow-x: auto;
  /* ריווח עדין בתוך תגית הקוד עצמה */
  padding: 0 2px;
}
#md-content {
  /* לא נחסום גלישה כדי שלא ייחתכו מספרים/תווים מחוץ לקופסה (למשל ברשימות) */
  overflow: visible;
}
/* מניעת גלישה אופקית של טקסט מחוץ לקוד/inline-code */
#md-content p, #md-content li, #md-content blockquote {
  overflow-wrap: anywhere;
  word-break: break-word;
}
/* מרווח נעים בין פסקאות */
#md-content p { margin: 0.75rem 0; }
/* ריווח ברור סביב כותרות משנה כדי למנוע הדבקה לטקסט שלפניהן/אחריהן */
#md-content h2, #md-content h3, #md-content h4 {
  margin-top: 1.25rem;
  margin-bottom: 0.75rem;
}
/* ברשימות ממוספרות/תבליטים ב-RTL המספר/סמל יישב בתוך הבלוק, לא מחוצה לו */
#md-content ol, #md-content ul {
  /* הצגת התבליט/מספור מחוץ לבלוק כדי ליצור הזחה טבעית */
  list-style-position: outside;
  /* ריווח תחתון כדי שלא יידבקו לכותרת/פסקה הבאה */
  margin-block: 0 1rem;
  /* הזחה בצד ההתחלה (RTL: ימין) */
  padding-inline-start: 1.25rem;
}
/* רווח עדין בין פריטי רשימה */
#md-content li { margin: 0.25rem 0; }
/* רשימות מקוננות – מעט רווח מעל/מתחת */
#md-content li > ul, #md-content li > ol { margin-block: 0.25rem 0.5rem; }
#md-content .code-block { position: relative; margin: 1rem 0; }
#md-content .code-block pre {
  margin: 0;
  /* ריווח סימטרי בתוך הבלוק עצמו – לא משפיע על המיקום של הבלוק בדף */
  padding: 16px;
  padding-right: clamp(22px, 6vw, 36px);
  padding-left: clamp(22px, 6vw, 36px);
  padding-top: 2.6rem;           /* מקום לשורת כפתורים עליונה */
  box-sizing: border-box;
}
#md-content .md-copy-btn {
  position: absolute;
  top: 12px;
  left: 12px;
  padding: 8px 10px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
  backdrop-filter: blur(8px);
  z-index: 2;
}
#md-content .md-copy-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  border-color: rgba(255, 255, 255, 0.4);
}
#md-content .md-copy-btn.copied {
  background: rgba(76, 175, 80, 0.3);
  border-color: rgba(76, 175, 80, 0.6);
}
#md-content .md-copy-btn.copy-error {
  background: rgba(220, 38, 38, 0.25);
  border-color: rgba(220, 38, 38, 0.55);
}
#md-content .md-copy-btn::before {
  content: "";
  display: inline-block;
  width: 16px;
  height: 16px;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2'%3E%3Crect x='9' y='9' width='13' height='13' rx='2'/%3E%3Cpath d='M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1'/%3E%3C/svg%3E");
  background-size: contain;
  background-repeat: no-repeat;
  vertical-align: middle;
}
#md-content code:not(pre code) {
  background: #f3f4f6;            /* אפור בהיר עם ניגודיות טובה על לבן */
  color: #111111;                 /* טקסט כהה לקריאות */
  border: 1px solid #e5e7eb;      /* מסגרת עדינה */
  padding: 0.2rem 0.4rem;
  border-radius: 6px;
  font-family: 'Fira Code', 'Consolas', monospace;
}
/* חיווי למופע פעיל בחיפוש */
#md-content .md-highlight.is-active {
  outline: 2px solid #ffd700;
  outline-offset: 1px;
}
/* ציטוטים */
#md-content blockquote {
  margin: 0.75rem 0;
  padding: 0.5rem 0.75rem;
  background: #eef2f7; /* מעט כהה יותר לניגודיות טובה על לבן */
  border-inline-start: 4px solid #cbd5e1; /* קו צד כהה במקצת */
}
/* שם קובץ ארוך – מניעת חריגה במסגרת הכותרת */
#md-file-name-wrap { min-width: 0; }
#md-file-name {
  margin: 0;
  font-size: 1.6rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
  display: block;
}
/* רשימות משימות */
input.md-task-checkbox {
  margin-inline-end: .5rem;
  transform: scale(1.1);
}
/* שיפורי כותרות עם גבולות תחתונים */
#md-content h1 {
  font-size: 2.2em;
  margin-top: 1.5em;
  margin-bottom: 0.5em;
  font-weight: 700;
  border-bottom: 3px solid #e1e4e8;
  padding-bottom: 0.3em;
}

#md-content h2 {
  font-size: 1.8em;
  font-weight: 600;
  border-bottom: 2px solid #e1e4e8;
  padding-bottom: 0.3em;
}

#md-content h3 {
  font-size: 1.4em;
  font-weight: 600;
}

#md-content h4 {
  font-size: 1.2em;
  font-weight: 500;
}

/* שבירת שורות לכותרות ארוכות בתצוגת Markdown */
#md-content h1,
#md-content h2,
#md-content h3,
#md-content h4,
#md-content h5,
#md-content h6 {
  white-space: normal;
  overflow-wrap: anywhere;
  word-break: break-word;
}

/* אנימציות כניסה עדינות */
#md-content > * {
  animation: fadeIn 0.4s ease-in;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* אנימציה מהירה יותר לאלמנטים ספציפיים */
#md-content pre,
#md-content blockquote,
#md-content table {
  animation: fadeIn 0.3s ease-out;
}

@media (prefers-reduced-motion: reduce) {
  /* נטרל אנימציות לכל ילד ישיר */
  #md-content > * { animation: none; }
  /* נטרל גם לכללים הספציפיים יותר כדי לא לעקוף את ההעדפה */
  #md-content pre,
  #md-content blockquote,
  #md-content table { animation: none; }
  /* צמצם גם מעברים לקישורים ואפקט ה-::after שלהם */
  #md-content a,
  #md-content a::after { transition: none; }
}

/* עיצוב משופר לקישורים */
#md-content a {
  color: #0366d6;
  text-decoration: none;
  border-bottom: 1px solid transparent;
  transition: all 0.2s ease;
  position: relative;
}

#md-content a:hover {
  color: #0256c7;
}

/* אפקט hover נוסף אופציונלי - קו תחתון מתרחב */
#md-content a::after {
  content: '';
  position: absolute;
  bottom: -1px;
  left: 50%;
  width: 0;
  height: 1px;
  background: #0366d6;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  transform: translateX(-50%);
}

#md-content a:hover::after {
  width: 100%;
}

/* קישורים בכותרות - ללא קו תחתון */
#md-content h1 a,
#md-content h2 a,
#md-content h3 a {
  border-bottom: none;
}

#md-content h1 a::after,
#md-content h2 a::after,
#md-content h3 a::after {
  display: none;
}

/* קישורי עוגן (permalink) */
#md-content .header-anchor {
  opacity: 0;
  transition: opacity 0.2s;
  margin-left: 0.5em;
  color: #6c757d;
}

#md-content h1:hover .header-anchor,
#md-content h2:hover .header-anchor,
#md-content h3:hover .header-anchor {
  opacity: 1;
}
</style>
<style>
/* === תוכן עניינים צף מתקדם === */
:root {
  --toc-bg-light: linear-gradient(135deg, rgba(255,255,255,0.98) 0%, rgba(250,250,252,0.98) 100%);
  --toc-bg-dark: linear-gradient(135deg, rgba(30,30,40,0.98) 0%, rgba(40,40,50,0.98) 100%);
  --toc-header-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  --toc-text-light: #2d3748;
  --toc-text-dark: #e0e0e0;
  --toc-hover-light: rgba(102, 126, 234, 0.1);
  --toc-hover-dark: rgba(102, 126, 234, 0.2);
  --toc-active-light: rgba(102, 126, 234, 0.15);
  --toc-active-dark: rgba(102, 126, 234, 0.25);
}

:root {
  --toc-bg-light: linear-gradient(135deg, rgba(255,255,255,0.98) 0%, rgba(250,250,252,0.98) 100%);
  --toc-bg-dark: linear-gradient(135deg, rgba(30,30,40,0.98) 0%, rgba(40,40,50,0.98) 100%);
  --toc-header-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  --toc-text-light: #2d3748;
  --toc-text-dark: #e0e0e0;
  --toc-hover-light: rgba(102, 126, 234, 0.1);
  --toc-hover-dark: rgba(102, 126, 234, 0.2);
  --toc-active-light: rgba(102, 126, 234, 0.15);
  --toc-active-dark: rgba(102, 126, 234, 0.25);
}

:root {
  --toc-bg-light: linear-gradient(135deg, rgba(255,255,255,0.98) 0%, rgba(250,250,252,0.98) 100%);
  --toc-bg-dark: linear-gradient(135deg, rgba(30,30,40,0.98) 0%, rgba(40,40,50,0.98) 100%);
  --toc-header-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  --toc-text-light: #2d3748;
  --toc-text-dark: #e0e0e0;
  --toc-hover-light: rgba(102, 126, 234, 0.1);
  --toc-hover-dark: rgba(102, 126, 234, 0.2);
  --toc-active-light: rgba(102, 126, 234, 0.15);
  --toc-active-dark: rgba(102, 126, 234, 0.25);
}

:root {
  --toc-bg-light: linear-gradient(135deg, rgba(255,255,255,0.98) 0%, rgba(250,250,252,0.98) 100%);
  --toc-bg-dark: linear-gradient(135deg, rgba(30,30,40,0.98) 0%, rgba(40,40,50,0.98) 100%);
  --toc-header-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  --toc-text-light: #2d3748;
  --toc-text-dark: #e0e0e0;
  --toc-hover-light: rgba(102, 126, 234, 0.1);
  --toc-hover-dark: rgba(102, 126, 234, 0.2);
  --toc-active-light: rgba(102, 126, 234, 0.15);
  --toc-active-dark: rgba(102, 126, 234, 0.25);
}

.md-toc {
  position: fixed;
  top: 100px;
  left: 20px;
  max-width: 320px;
  min-width: 250px;
  max-height: calc(100vh - 140px);
  background: var(--toc-bg-light);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border-radius: 16px;
  box-shadow:
    0 10px 40px rgba(0,0,0,0.12),
    0 2px 10px rgba(0,0,0,0.06),
    inset 0 1px 0 rgba(255,255,255,0.5);
  border: 1px solid rgba(255,255,255,0.3);
  z-index: 900;
  overflow: hidden;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Dark Mode Support */
@media (prefers-color-scheme: dark) {
  .md-toc {
    background: var(--toc-bg-dark);
    box-shadow:
      0 10px 40px rgba(0,0,0,0.5),
      0 2px 10px rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.1);
  }
}

/* כותרת עם gradient */
.md-toc-header {
  padding: 1rem;
  background: var(--toc-header-gradient);
  color: white;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative;
  user-select: none;
}

.md-toc-title-wrapper {
  flex: 1;
}

.md-toc-title-wrapper h3 {
  margin: 0;
  font-size: 1.1rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: 600;
}

/* פס התקדמות */
.md-toc-progress {
  height: 3px;
  background: rgba(255,255,255,0.2);
  border-radius: 2px;
  margin-top: 0.5rem;
  overflow: hidden;
}

.md-toc-progress-bar {
  height: 100%;
  background: rgba(255,255,255,0.9);
  border-radius: 2px;
  width: 0%;
  transition: width 0.3s ease;
  box-shadow: 0 0 10px rgba(255,255,255,0.5);
}

/* כפתורי בקרה */
.md-toc-controls {
  display: flex;
  gap: 0.5rem;
}

.md-toc-toggle,
.md-toc-search-btn {
  background: rgba(255,255,255,0.2);
  border: 1px solid rgba(255,255,255,0.3);
  border-radius: 8px;
  padding: 0.4rem 0.6rem;
  cursor: pointer;
  color: white;
  transition: all 0.2s ease;
}

.md-toc-toggle:hover,
.md-toc-search-btn:hover {
  background: rgba(255,255,255,0.3);
  transform: scale(1.05);
}

.md-toc-toggle:active,
.md-toc-search-btn:active {
  transform: scale(0.95);
}

.md-toc-toggle i {
  transition: transform 0.3s ease;
}

.md-toc.collapsed .md-toc-toggle i {
  transform: rotate(180deg);
}

/* תיבת חיפוש */
.md-toc-search-container {
  padding: 0.75rem;
  background: rgba(102, 126, 234, 0.05);
  border-bottom: 1px solid rgba(102, 126, 234, 0.2);
}

.md-toc-search-input {
  width: 100%;
  padding: 0.5rem;
  border: 1px solid rgba(102, 126, 234, 0.3);
  border-radius: 8px;
  background: white;
  font-size: 0.9rem;
  transition: all 0.2s ease;
}

.md-toc-search-input:focus {
  outline: none;
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

@media (prefers-color-scheme: dark) {
  .md-toc-search-input {
    background: rgba(255,255,255,0.1);
    color: white;
    border-color: rgba(255,255,255,0.2);
  }
}

.md-toc-search-results {
  display: block;
  margin-top: 0.25rem;
  font-size: 0.75rem;
  color: #667eea;
  text-align: center;
}

/* אזור ניווט עם גלילה */
.md-toc-nav {
  padding: 0.5rem 0;
  overflow-y: auto;
  max-height: calc(100vh - 240px);
  scrollbar-width: thin;
  scrollbar-color: #667eea transparent;
  position: relative;
}

.md-toc-nav::-webkit-scrollbar {
  width: 6px;
}

.md-toc-nav::-webkit-scrollbar-thumb {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 3px;
}

.md-toc-nav::-webkit-scrollbar-track {
  background: transparent;
}

/* פריטי תוכן עניינים */
.md-toc-item {
  padding: 0.6rem 1rem;
  cursor: pointer;
  color: var(--toc-text-light);
  transition: all 0.2s ease;
  border-right: 3px solid transparent;
  font-size: 0.9rem;
  display: block;
  text-decoration: none;
  position: relative;
  overflow: hidden;
}

@media (prefers-color-scheme: dark) {
  .md-toc-item {
    color: var(--toc-text-dark);
  }
}

/* אפקט hover מתקדם */
.md-toc-item::before {
  content: '';
  position: absolute;
  right: 0;
  top: 0;
  height: 100%;
  width: 3px;
  background: var(--toc-header-gradient);
  transform: translateX(100%);
  transition: transform 0.3s ease;
}

.md-toc-item:hover {
  background: var(--toc-hover-light);
  padding-right: 1.25rem;
}

@media (prefers-color-scheme: dark) {
  .md-toc-item:hover {
    background: var(--toc-hover-dark);
  }
}

.md-toc-item:hover::before,
.md-toc-item.active::before {
  transform: translateX(0);
}

.md-toc-item.active {
  background: var(--toc-active-light);
  color: #667eea;
  font-weight: 600;
}

@media (prefers-color-scheme: dark) {
  .md-toc-item.active {
    background: var(--toc-active-dark);
  }
}

/* הדגשת חיפוש */
.md-toc-item.search-match {
  background: rgba(255, 235, 59, 0.2);
}

.md-toc-item.search-match mark {
  background: rgba(255, 235, 59, 0.5);
  color: inherit;
  padding: 0 2px;
  border-radius: 2px;
}

/* הסתרה בחיפוש */
.md-toc-item.search-hidden {
  display: none;
}

/* הזחה לפי רמת כותרת */
.md-toc-item[data-level="1"] { padding-right: 1rem; font-weight: 600; }
.md-toc-item[data-level="2"] { padding-right: 1.25rem; }
.md-toc-item[data-level="3"] { padding-right: 2rem; font-size: 0.85rem; }
.md-toc-item[data-level="4"] { padding-right: 2.75rem; font-size: 0.8rem; }
.md-toc-item[data-level="5"] { padding-right: 3.5rem; font-size: 0.75rem; }
.md-toc-item[data-level="6"] { padding-right: 4.25rem; font-size: 0.75rem; }

/* מצב מכווץ */
.md-toc.collapsed {
  max-height: 60px;
}

.md-toc.collapsed .md-toc-nav,
.md-toc.collapsed .md-toc-search-container {
  display: none;
}

.md-toc.collapsed .md-toc-progress {
  margin-top: 0.25rem;
}

/* מצב מינימלי */
.md-toc.minimized {
  display: none;
}

.md-toc-mini-btn {
  position: fixed;
  top: 100px;
  left: 12px;  /* בצד שמאל של המסך */
  width: 44px;
  height: 44px;
  border-radius: 10px; /* ריבוע מעוגל קלות */
  background: var(--toc-header-gradient);
  color: white;
  border: none;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.35);
  transition: transform 0.15s ease, box-shadow 0.2s ease;
  z-index: 1000;
  touch-action: none; /* מאפשר גרירה חלקה במובייל */
}

.md-toc-mini-btn:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
}

/* Virtual Scrolling - פריט placeholder */
.md-toc-item-placeholder {
  height: 32px;
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: loading 1.5s infinite;
  margin: 0.25rem 1rem;
  border-radius: 4px;
}

@keyframes loading {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

/* התאמה למסכים קטנים */
@media (max-width: 1024px) {
  .md-toc {
    left: 10px;
    max-width: 280px;
    min-width: 220px;
    font-size: 0.85rem;
  }
  
  .md-toc-item {
    padding: 0.5rem 0.75rem;
  }
}

@media (max-width: 768px) {
  /* במובייל: הסתרת הפאנל והצגת כפתור מינימלי לפתיחה */
  .md-toc { display: none; }
  .md-toc-mini-btn { display: block; }
}

/* במסך מלא - הסתר */
#mdCard:fullscreen ~ .md-toc,
#mdCard:-webkit-full-screen ~ .md-toc,
#mdCard:fullscreen ~ .md-toc-mini-btn,
#mdCard:-webkit-full-screen ~ .md-toc-mini-btn {
  display: none !important;
}

/* אנימציות נוספות */
@keyframes slideIn {
  from {
    transform: translateX(-100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.md-toc {
  animation: slideIn 0.3s ease-out;
}

/* Tooltip לכותרות ארוכות */
.md-toc-item[title] {
  position: relative;
}

.md-toc-item[title]:hover::after {
  content: attr(title);
  position: absolute;
  right: calc(100% + 10px);
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0,0,0,0.8);
  color: white;
  padding: 0.5rem;
  border-radius: 6px;
  white-space: nowrap;
  font-size: 0.85rem;
  z-index: 1000;
  max-width: 300px;
  overflow: hidden;
  text-overflow: ellipsis;
}
</style>
{% endblock %}

{% block content %}
<div id="md-root">
  <div class="file-header" style="display:flex;justify-content:space-between;align-items:center;gap:1rem;flex-wrap:wrap;margin-bottom:1rem;">
    <div style="display:flex;align-items:center;gap:.75rem;min-width:0;">
      <span style="font-size:2rem;">📝</span>
      <div id="md-file-name-wrap">
        <h1 id="md-file-name">{{ file.file_name }}</h1>
        <div class="muted" style="margin-top:.25rem;">Markdown</div>
      </div>
    </div>
  <div class="file-actions" style="display:flex;gap:.5rem;flex-wrap:wrap;">
      {% if not is_public %}
      <a href="#" onclick="return goBackToFile(event)" class="btn btn-secondary btn-icon">↩️ חזרה לתצוגת קוד</a>
      {% endif %}
    </div>
  </div>

  <div class="glass-card" id="mdCard" style="padding:1rem;">
    <div class="section-header" style="display:flex;justify-content:space-between;align-items:center;gap:1rem;margin-bottom:.5rem;">
      <h2 class="section-title" style="margin:0;display:flex;align-items:center;gap:.5rem;">
        <i class="fas fa-file-alt"></i>
        תצוגת Markdown
      </h2>
      <button id="mdFullscreenBtn" class="btn btn-secondary btn-icon" title="מסך מלא">
        <i class="fas fa-expand"></i>
        מסך מלא
      </button>
    </div>
    <div class="search-bar" id="md-search" style="display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;background:linear-gradient(135deg,#2d4a7c 0%,#3d5a8c 100%);padding:.75rem;border-radius:12px 12px 0 0;box-shadow:0 2px 8px rgba(0,0,0,0.2);margin:-16px -16px 0 -16px;position:relative;">
      <!-- כפתור החלפת צבעי רקע -->
      <div id="bgColorSwitcher" style="position:absolute;top:-45px;left:50%;transform:translateX(-50%);z-index:100;">
        <button id="bgColorBtn" class="btn btn-secondary btn-icon" style="background:rgba(255,255,255,0.95);color:#333;border:1px solid #ddd;box-shadow:0 2px 8px rgba(0,0,0,0.15);padding:8px 16px;border-radius:8px;font-size:14px;cursor:pointer;transition:all 0.2s ease;" title="החלף צבע רקע">
          <span style="display:inline-block;width:16px;height:16px;border-radius:50%;background:#ffffff;border:2px solid #333;vertical-align:middle;margin-left:6px;"></span>
          צבע רקע
        </button>
        <div id="bgColorOptions" style="display:none;position:absolute;top:100%;left:50%;transform:translateX(-50%);margin-top:5px;background:white;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.2);padding:10px;white-space:nowrap;">
          <button class="bg-color-option" data-color="light" style="display:block;width:100%;padding:8px 12px;margin:4px 0;border:1px solid #ddd;border-radius:6px;background:#f5e6d3;color:#333;cursor:pointer;font-size:14px;transition:all 0.2s ease;">
            <span style="display:inline-block;width:20px;height:20px;border-radius:4px;background:#f5e6d3;border:1px solid #999;vertical-align:middle;margin-left:8px;"></span>
            חום בהיר
          </button>
          <button class="bg-color-option" data-color="medium" style="display:block;width:100%;padding:8px 12px;margin:4px 0;border:1px solid #ddd;border-radius:6px;background:#e8d4b0;color:#333;cursor:pointer;font-size:14px;transition:all 0.2s ease;">
            <span style="display:inline-block;width:20px;height:20px;border-radius:4px;background:#e8d4b0;border:1px solid #999;vertical-align:middle;margin-left:8px;"></span>
            חום בינוני
          </button>
          <button class="bg-color-option" data-color="dark" style="display:block;width:100%;padding:8px 12px;margin:4px 0;border:1px solid #ddd;border-radius:6px;background:#d4b896;color:#333;cursor:pointer;font-size:14px;transition:all 0.2s ease;">
            <span style="display:inline-block;width:20px;height:20px;border-radius:4px;background:#d4b896;border:1px solid #999;vertical-align:middle;margin-left:8px;"></span>
            חום כהה
          </button>
        </div>
      </div>
      <input id="mdSearchInput" type="text" placeholder="🔍 חפש בקוד..." style="flex:1 1 220px;min-width:0;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.2);border-radius:8px;padding:.6rem .8rem;color:#fff;font-size:.95rem;outline:none;">
      <span id="mdSearchCount" class="result-count" style="color:rgba(255,255,255,.9);font-size:.85rem;padding:.35rem .6rem;background:rgba(255,255,255,.12);border-radius:6px;min-width:60px;text-align:center;flex:0 0 auto;"></span>
      <button id="mdSearchNext" type="button" class="btn btn-secondary btn-icon" title="הבא" style="background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.2);flex:0 0 auto;">▶</button>
      <button id="mdSearchClear" type="button" class="btn btn-secondary btn-icon" title="נקה" style="background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.2);flex:0 0 auto;">✕</button>
    </div>
    <div id="md-content" style="margin-inline:-4px;width:calc(100% + 8px);"></div>
  </div>

  <!-- תוכן עניינים צף מתקדם עם כל הפיצ'רים (ממוקם אחרי #mdCard כדי שכללי CSS של fullscreen יעבדו) -->
  <div id="mdToc" class="md-toc" style="display:none;"
       role="navigation"
       aria-label="תוכן עניינים של המסמך">

    <!-- כותרת עם אינדיקטור התקדמות -->
    <div class="md-toc-header">
      <div class="md-toc-title-wrapper">
        <h3 id="toc-heading">
          <i class="fas fa-list" aria-hidden="true"></i>
          תוכן עניינים
        </h3>
        <div class="md-toc-progress" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
          <div class="md-toc-progress-bar" id="tocProgressBar"></div>
        </div>
      </div>
      <div class="md-toc-controls">
        <button id="mdTocSearch"
                class="md-toc-search-btn"
                aria-label="חפש בכותרות"
                title="חיפוש (Ctrl+F)">
          <i class="fas fa-search" aria-hidden="true"></i>
        </button>
        <!-- סמל תפריט (☰) – לחיצה ארוכה תמזער את הפאנל -->
        <button id="mdTocMenuBtn"
                class="md-toc-toggle"
                aria-label="מזעור התפריט בלחיצה ארוכה"
                title="לחיצה ארוכה: מזער (☰)">
          <i class="fas fa-bars" aria-hidden="true"></i>
        </button>
        <button id="mdTocToggle"
                class="md-toc-toggle"
                aria-controls="mdTocNav"
                aria-expanded="true"
                aria-labelledby="toc-heading"
                title="כווץ או הרחב (Ctrl+T)">
          <i class="fas fa-chevron-up" aria-hidden="true"></i>
        </button>
      </div>
    </div>

    <!-- תיבת חיפוש (מוסתרת בהתחלה) -->
    <div class="md-toc-search-container" id="tocSearchContainer" style="display:none;">
      <input type="search"
             id="tocSearchInput"
             class="md-toc-search-input"
             placeholder="חפש בכותרות..."
             aria-label="חיפוש בתוכן העניינים">
      <span class="md-toc-search-results" id="tocSearchResults"></span>
    </div>

    <!-- אזור הניווט עם Virtual Scrolling -->
    <nav id="mdTocNav"
         class="md-toc-nav"
         aria-labelledby="toc-heading"
         role="list">
      <!-- כאן יוכנסו הכותרות דינמית -->
    </nav>
  </div>
  <!-- כפתור מינימלי צף (מחוץ לפאנל) -->
  <button id="mdTocMini"
          class="md-toc-mini-btn"
          style="display:none;"
          aria-label="הצג תוכן עניינים"
          title="הצג תוכן עניינים">
    <i class="fas fa-bars"></i>
  </button>

  {% if not is_public %}
  <div class="glass-card" style="margin-top: 1rem;">
    <h2 class="section-title">
      <i class="fas fa-share-alt"></i>
      שיתוף
    </h2>
    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
      <button onclick="shareToTelegramMd()" class="btn btn-secondary btn-icon">
        <i class="fab fa-telegram"></i>
        שתף בטלגרם
      </button>
      <button onclick="copyLinkMd()" class="btn btn-secondary btn-icon">
        <i class="fas fa-link"></i>
        העתק קישור
      </button>
    </div>
  </div>
  {% endif %}
  <script type="application/json" id="mdText">{{ md_code | tojson | safe }}</script>
</div>

<script>
// מזהה קובץ לשימוש בשמירת העדפות פר-קובץ
const FILE_ID = "{{ file.id }}";
// תוכן ה-Markdown מועבר בבטחה JSON-encoded
const MD_TEXT = (function(){
  try {
    var el = document.getElementById('mdText');
    if (!el) return "";
    return JSON.parse(el.textContent || '""');
  } catch(_) { return ""; }
})();

// שמירת מצב רשימות משימות (לפי קובץ) ב-localStorage
const STORAGE_KEY = `md_tasks_state:{{ file.id }}`;
function loadTaskState(){
  try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); }catch(_){ return {}; }
}
function saveTaskState(state){
  try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state || {})); }catch(_){ }
}
const taskState = loadTaskState();

// טעינת bundle מקומי (ללא CDN)
const BUNDLE = {
  js: "{{ url_for('static', filename='js/md_preview.bundle.js') }}",
  css: "{{ url_for('static', filename='css/md_preview.bundle.css') }}"
};

// תאימות לאחור: מפה "CDN" לערכים מקומיים כך שלא נדרש רשת
const CDN = {
  md: BUNDLE.js,
  mdEmoji: null,
  mdTask: null,
  mdAnchor: null,
  mdFootnote: null,
  mdTocDone: null,
  mdContainer: null,
  mdAdmonition: null,
  hljs: null,
  hljsCss: BUNDLE.css,
  katexCss: BUNDLE.css,
  katexJs: null,
  katexAuto: null,
  mermaid: null
};

function injectCss(href){
  if (!href) return;
  try {
    if (document.querySelector('link[rel="stylesheet"][href="' + href + '"]')) return;
  } catch(_) {}
  const l = document.createElement('link');
  l.rel = 'stylesheet';
  l.href = href;
  document.head.appendChild(l);
}
function loadScript(src){
  return new Promise((res, rej) => {
    if (!src) { res(); return; }
    try {
      if (document.querySelector('script[src="' + src + '"]')) { res(); return; }
    } catch(_) {}
    const s = document.createElement('script');
    s.src = src;
    s.defer = true;
    s.onload = res;
    s.onerror = rej;
    document.head.appendChild(s);
  });
}

(async function(){
  try{
    injectCss(CDN.hljsCss);
    injectCss(CDN.katexCss);
    try { await loadScript(CDN.md); } catch(_){}
    try { await loadScript(CDN.mdEmoji); } catch(_){}
    try { await loadScript(CDN.mdTask); } catch(_){}
    try { await loadScript(CDN.mdAnchor); } catch(_){}
    try { await loadScript(CDN.mdFootnote); } catch(_){}
    try { await loadScript(CDN.mdTocDone); } catch(_){}
    try { await loadScript(CDN.mdContainer); } catch(_){}
    try { await loadScript(CDN.mdAdmonition); } catch(_){}
    try { await loadScript(CDN.hljs); } catch(_){}
    try { await loadScript(CDN.katexJs); } catch(_){}
    try { await loadScript(CDN.katexAuto); } catch(_){}
    try { await loadScript(CDN.mermaid); } catch(_){}

    const md = (window.markdownit ? window.markdownit : (()=>({render:(s)=>s})))({
      breaks: true,
      linkify: true,
      typographer: true,
      html: false,
      // לא לבצע הדגשה בשלב ה-render של markdown-it; נבצע post-process עם hljs
      highlight: function (_str, _lang) { return ''; }
    })
    if (window.markdownitEmoji) md.use(window.markdownitEmoji);
    if (window.markdownitTaskLists) md.use(window.markdownitTaskLists, { label: true, enabled: true });
    // עוגני כותרות – הגדרה יציבה למניעת רגרסיות בין גרסאות התוסף
    if (window.markdownitAnchor) {
      try {
        md.use(window.markdownitAnchor, { permalink: true, permalinkSymbol: '¶' });
      } catch(_) {
        try { md.use(window.markdownitAnchor); } catch(__) {}
      }
    }
    if (window.markdownitFootnote) md.use(window.markdownitFootnote);
    // תמיכה גם בשמות גלובליים שונים של התוסף (markdown-it-admonition)
    (function(){
      try {
        const admonitionPlugin = (window.markdownitAdmonition || window.markdownItAdmonition || window.markdownItAdmonitionDefault || null);
        if (admonitionPlugin) {
          md.use(admonitionPlugin, {
            types: ['note','tip','warning','danger','info','success','question','example','quote','experimental','deprecated','todo','abstract']
          });
        }
      } catch(_) {}
    })();
    // תמיכה רשמית בתחביר ::: ע"י markdown-it-container עבור כל הסוגים וה-details
    (function(){
      try {
        const containerPlugin = (window.markdownitContainer || window.markdownItContainer || null);
        if (!containerPlugin) return;
        const types = ['details','note','tip','warning','danger','info','success','question','example','quote','experimental','deprecated','todo','abstract'];
        const DEFAULT_TITLES = { note:'הערה', tip:'טיפ', warning:'אזהרה', danger:'סכנה', info:'מידע', success:'הצלחה', question:'שאלה', example:'דוגמה', quote:'ציטוט', experimental:'ניסוי', deprecated:'לא מומלץ', todo:'לעשות', abstract:'תקציר' };
        function defaultTitle(type){ return DEFAULT_TITLES[type] || type; }

        types.forEach(function(type){
          if (type === 'details') {
            md.use(containerPlugin, 'details', {
              validate: function(params){ return /^details\b/i.test((params||'').trim()); },
              render: function(tokens, idx){
                const m = (tokens[idx].info || '').trim().match(/^details\s+(.*)$/i);
                const title = (m && m[1] && m[1].trim()) || 'לחץ להצגה';
                if (tokens[idx].nesting === 1) {
                  return `<details class="markdown-details"><summary class="markdown-summary">${md.utils.escapeHtml(title)}</summary><div class="details-content">`;
                }
                return `</div></details>\n`;
              }
            });
          } else {
            // כרטיסיות הסבר (admonitions) עם ::: tip כותרת
            const rxOpen = new RegExp('^' + type + '\\b\\s*(.*)$', 'i');
            md.use(containerPlugin, type, {
              validate: function(params){ return rxOpen.test((params||'').trim()); },
              render: function(tokens, idx){
                const info = (tokens[idx].info || '').trim();
                const m = info.match(rxOpen);
                const title = (m && m[1] && m[1].trim()) || defaultTitle(type);
                if (tokens[idx].nesting === 1) {
                  return `<div class="admonition admonition-${type}"><div class="admonition-title">${md.utils.escapeHtml(title)}</div><div class="admonition-content">`;
                }
                return `</div></div>\n`;
              }
            });
          }
        });
      } catch(_) {}
    })();
    if (window.markdownitTocDoneRight) md.use(window.markdownitTocDoneRight);

    // רינדור ראשוני
    const container = document.getElementById('md-content');
    container.innerHTML = md.render(MD_TEXT || '');
    // בדיקת smoke מהירה: האם ::: tip מומר ל-admonition (לוג בלבד)
    try {
      const smoke = md.render('::: tip בדיקת טיפ\nתוכן\n:::');
      console.info('Admonition(::: tip) supported =', /class="admonition admonition-tip"/.test(smoke));
    } catch(_) {}
    try {
      // השלם מזהי עוגן חסרים והסר כפילויות כדי שסימניות על כותרות יעבדו יציב
      const seen = new Set();
      const gen = (t) => {
        const s = (t || '').toLowerCase().trim().replace(/[^a-z0-9א-ת\-\s]/gi, '').replace(/\s+/g, '-');
        let base = s || 'section'; let k = base; let i = 2;
        while (seen.has(k) || document.getElementById(k)) { k = base + '-' + (i++); }
        seen.add(k); return k;
      };
      Array.from(container.querySelectorAll('h1, h2, h3, h4, h5, h6')).forEach(h => {
        const txt = (h.textContent || '').trim();
        if (!h.id) { h.id = gen(txt); }
        else if (seen.has(h.id)) { h.id = gen(txt); } else { seen.add(h.id); }
      });
    } catch(_) {}

    // המרה של ::: details / ::: admonitions / ??? ו-!!! ל-HTML בטוח לאחר הרינדור
    (function enhanceMarkdownContainers() {
      try {
        if (!container) return;
        const OPEN_RE = /^:{3,}\s*(details|note|tip|warning|danger|info|success|question|example|quote|experimental|deprecated|todo|abstract)\b/i;
        const CLOSE_RE = /^:{3,}\s*$/;
        const Q_OPEN_RE = /^\?{3,}\s*([+\-])?\s*(?:details|note|tip|warning|danger|info|success|question|example|quote|experimental|deprecated|todo|abstract)?\b/i;
        const Q_CLOSE_RE = /^\?{3,}\s*$/;
        const B_OPEN_RE = /^!{3,}\s*([a-z]+)?\s*(.*)$/i; // !!! type? title?
        const B_CLOSE_RE = /^!{3,}\s*$/;
        function isOpenMarker(p){ return p && p.tagName === 'P' && OPEN_RE.test((p.textContent || '').trim()); }
        function isCloseMarker(p){ return p && p.tagName === 'P' && CLOSE_RE.test((p.textContent || '').trim()); }
        function isQOpenMarker(p){ return p && p.tagName === 'P' && Q_OPEN_RE.test((p.textContent || '').trim()); }
        function isQCloseMarker(p){ return p && p.tagName === 'P' && Q_CLOSE_RE.test((p.textContent || '').trim()); }
        function isBOpenMarker(p){ return p && p.tagName === 'P' && B_OPEN_RE.test((p.textContent || '').trim()); }
        function isBCloseMarker(p){ return p && p.tagName === 'P' && B_CLOSE_RE.test((p.textContent || '').trim()); }
        function findMatchingClose(startP) {
          let depth = 0;
          let cursor = startP.nextElementSibling;
          while (cursor) {
            if (isOpenMarker(cursor)) depth += 1;
            else if (isCloseMarker(cursor)) {
              if (depth === 0) return cursor;
              depth -= 1;
            }
            cursor = cursor.nextElementSibling;
          }
          return null;
        }
        function findMatchingQClose(startP) {
          let depth = 0;
          let cursor = startP.nextElementSibling;
          while (cursor) {
            if (isQOpenMarker(cursor)) depth += 1;
            else if (isQCloseMarker(cursor)) {
              if (depth === 0) return cursor;
              depth -= 1;
            }
            cursor = cursor.nextElementSibling;
          }
          return null;
        }
        function findMatchingBClose(startP) {
          let depth = 0;
          let cursor = startP.nextElementSibling;
          while (cursor) {
            if (isBOpenMarker(cursor)) depth += 1;
            else if (isBCloseMarker(cursor)) {
              if (depth === 0) return cursor;
              depth -= 1;
            }
            cursor = cursor.nextElementSibling;
          }
          return null;
        }
        function extractBetween(startP, endP) {
          if (!endP) return null;
          const frag = document.createDocumentFragment();
          let cur = startP.nextSibling;
          while (cur && cur !== endP) { const next = cur.nextSibling; frag.appendChild(cur); cur = next; }
          return frag;
        }
        function defaultTitle(type){ const m={note:'הערה',tip:'טיפ',warning:'אזהרה',danger:'סכנה',info:'מידע',success:'הצלחה',question:'שאלה',example:'דוגמה',quote:'ציטוט',experimental:'ניסוי',deprecated:'לא מומלץ',todo:'לעשות',abstract:'תקציר'}; return m[type]||type; }
        function transformIn(root) {
          let changed = false;
          let node = root.firstElementChild;
          while (node) {
            if (node.tagName === 'P') {
              const text = (node.textContent || '').trim();
              let m = text.match(/^:{3,}\s*details\s*(.*)$/i);
              if (m) {
                const endP = findMatchingClose(node);
                if (!endP) { node = node.nextElementSibling; continue; }
                const frag = extractBetween(node, endP);
                const details = document.createElement('details'); details.className = 'markdown-details';
                const summary = document.createElement('summary'); summary.className = 'markdown-summary'; summary.textContent = m[1] ? m[1].trim() : 'לחץ להצגה';
                const content = document.createElement('div'); content.className = 'details-content'; content.appendChild(frag);
                details.appendChild(summary); details.appendChild(content);
                const parent = node.parentNode; parent.replaceChild(details, node);
                if (endP && endP.parentNode) endP.parentNode.removeChild(endP);
                // עבד רקורסיבית בתוך התוכן, לתמיכה בקינון
                try { transformIn(content); } catch(_) {}
                node = details;
                changed = true;
              } else {
                m = text.match(/^:{3,}\s*(note|tip|warning|danger|info|success|question|example|quote|experimental|deprecated|todo|abstract)\s*(.*)$/i);
                if (m) {
                  const type = m[1].toLowerCase(); const titleTxt = (m[2] || '').trim() || defaultTitle(type);
                  const endP = findMatchingClose(node);
                  if (!endP) { node = node.nextElementSibling; continue; }
                  const frag = extractBetween(node, endP);
                  const wrap = document.createElement('div'); wrap.className = 'admonition admonition-' + type;
                  const title = document.createElement('div'); title.className = 'admonition-title'; title.textContent = titleTxt;
                  const content = document.createElement('div'); content.className = 'admonition-content'; content.appendChild(frag);
                  wrap.appendChild(title); wrap.appendChild(content);
                  const parent = node.parentNode; parent.replaceChild(wrap, node);
                  if (endP && endP.parentNode) endP.parentNode.removeChild(endP);
                  try { transformIn(content); } catch(_) {}
                  node = wrap;
                  changed = true;
                } else {
                  // ??? blocks: ??? [+/−] [type?] [title?]
                  m = text.match(/^\?{3,}\s*([+\-])?\s*([a-z]+)?\s*(.*)$/i);
                  if (m) {
                    const openFlag = (m[1] || '').trim();
                    const type = (m[2] || 'question').toLowerCase();
                    const titleTxt = (m[3] || '').trim() || defaultTitle(type);
                    const endP = findMatchingQClose(node);
                    if (!endP) { node = node.nextElementSibling; continue; }
                    const frag = extractBetween(node, endP);
                    const details = document.createElement('details'); details.className = 'markdown-details admonition admonition-' + type; if (openFlag === '+') details.setAttribute('open', '');
                    const summary = document.createElement('summary'); summary.className = 'markdown-summary admonition-title'; summary.textContent = titleTxt;
                    const content = document.createElement('div'); content.className = 'details-content admonition-content'; content.appendChild(frag);
                    details.appendChild(summary); details.appendChild(content);
                    const parent = node.parentNode; parent.replaceChild(details, node);
                    if (endP && endP.parentNode) endP.parentNode.removeChild(endP);
                    try { transformIn(content); } catch(_) {}
                    node = details;
                    changed = true;
                  } else {
                    // !!! blocks: !!! [type?] [title?] ... !!!
                    m = text.match(/^!{3,}\s*([a-z]+)?\s*(.*)$/i);
                    if (m) {
                      const type = (m[1] || 'note').toLowerCase();
                      const titleTxt = (m[2] || '').trim() || defaultTitle(type);
                      const endP = findMatchingBClose(node);
                      if (!endP) { node = node.nextElementSibling; continue; }
                      const frag = extractBetween(node, endP);
                      const wrap = document.createElement('div'); wrap.className = 'admonition admonition-' + type;
                      const title = document.createElement('div'); title.className = 'admonition-title'; title.textContent = titleTxt;
                      const content = document.createElement('div'); content.className = 'admonition-content'; content.appendChild(frag);
                      wrap.appendChild(title); wrap.appendChild(content);
                      const parent = node.parentNode; parent.replaceChild(wrap, node);
                      if (endP && endP.parentNode) endP.parentNode.removeChild(endP);
                      try { transformIn(content); } catch(_) {}
                      node = wrap;
                      changed = true;
                    }
                  }
                }
              }
            }
            node = node.nextElementSibling;
          }
          return changed;
        }
        // הרץ עד שלא נשארים בלוקים לעיבוד (מגן מלולאות אינסופיות ע"י מקסימום איטרציות)
        let guard = 0;
        while (transformIn(container) && guard < 10) { guard++; }
      } catch(_) {}
    })();

    // הדגשת תחביר לאחר הרינדור: הדגשה ממוקדת בתוך #md-content בלבד
    try {
      if (window.hljs) {
        try { if (typeof window.hljs.highlightAll === 'function') window.hljs.highlightAll(); } catch(_){}
        container.querySelectorAll('pre code').forEach(el => {
          try {
            if (el.classList.contains('hljs')) return;
            var hasLang = /\blanguage-/.test(el.className || '');
            if (hasLang && typeof window.hljs.highlightElement === 'function') {
              window.hljs.highlightElement(el);
            } else if (typeof window.hljs.highlightAuto === 'function') {
              var res = window.hljs.highlightAuto(el.textContent || '');
              el.innerHTML = res.value;
              el.classList.add('hljs');
            }
          } catch(__) {}
        });
      }
    } catch(_) { }

    // אחרי הדגשת hljs – נשמור מקור רק לכל בלוק קוד (לא לכל הקונטיינר)
    try {
      const blocks = container.querySelectorAll('pre code');
      blocks.forEach(code => {
        if (!code.hasAttribute('data-original-html')) {
          code.setAttribute('data-original-html', code.innerHTML);
        }
      });
    } catch(_) {}

    // חיפוש והדגשה בתוך קטעי קוד בלבד
    (function(){
      const input = document.getElementById('mdSearchInput');
      const clearBtn = document.getElementById('mdSearchClear');
      const nextBtn = document.getElementById('mdSearchNext');
      const countEl = document.getElementById('mdSearchCount');
      if (!input || !clearBtn || !countEl) return;
      let justAutoFocused = false;

      function restore() {
        // משחזר כל בלוק קוד מהמקור שנשמר בו, בלי לגעת בשאר ה-HTML והדגשות hljs
        const blocks = container.querySelectorAll('pre code');
        blocks.forEach(code => {
          try {
            const orig = code.getAttribute('data-original-html');
            if (orig != null) {
              code.innerHTML = orig;
            }
          } catch(_) {}
        });
      }

      function highlightTerm(term) {
        // מדגיש רק בתוך pre > code כדי לא לשבור HTML מחוץ לקוד
        const blocks = container.querySelectorAll('pre code');
        let total = 0;
        blocks.forEach(code => {
          try {
            const original = code.getAttribute('data-original-html') || code.innerHTML;
            code.setAttribute('data-original-html', original);
            if (!term) { code.innerHTML = original; return; }
            const safe = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const rx = new RegExp(`(${safe})`, 'gi');
            const replaced = original.replace(rx, '<span class="md-highlight">$1</span>');
            code.innerHTML = replaced;
            total += (original.match(rx) || []).length;
          } catch(_) {}
        });
        return total;
      }

      function updateCount(n, term){
        if (!term) { countEl.textContent = ''; return; }
        const active = container.querySelector('.md-highlight.is-active');
        const activeIndex = active ? (Array.from(container.querySelectorAll('.md-highlight')).indexOf(active) + 1) : 0;
        countEl.textContent = n > 0 ? (activeIndex ? `${activeIndex}/${n}` : `${n} תוצאות`) : 'אין תוצאות';
      }

      function setActiveAndScroll(target){
        try { container.querySelectorAll('.md-highlight.is-active').forEach(el => el.classList.remove('is-active')); } catch(_){ }
        if (!target) return;
        try { target.classList.add('is-active'); } catch(_){ }
        try { target.scrollIntoView({ behavior:'smooth', block:'center' }); } catch(_){ }
      }

      function focusFirst(){
        const first = container.querySelector('.md-highlight');
        if (first) setActiveAndScroll(first);
      }

      function focusNext(){
        const all = Array.from(container.querySelectorAll('.md-highlight'));
        if (all.length === 0) return;
        const current = container.querySelector('.md-highlight.is-active');
        const idx = current ? all.indexOf(current) : -1;
        const next = all[(idx + 1) % all.length];
        setActiveAndScroll(next);
        updateCount(all.length, input.value.trim());
      }

      input.addEventListener('input', () => {
        const term = (input.value || '').trim();
        restore();
        const n = highlightTerm(term);
        if (term && n > 0) {
          focusFirst();
          justAutoFocused = true;
        }
        updateCount(n, term);
      });

      clearBtn.addEventListener('click', () => {
        input.value = '';
        restore();
        updateCount(0, '');
        justAutoFocused = false;
      });

      if (nextBtn) {
        nextBtn.addEventListener('click', () => {
          const term = (input.value || '').trim();
          if (!term) return;
          const active = container.querySelector('.md-highlight.is-active');
          if (justAutoFocused || !active) {
            const first = container.querySelector('.md-highlight');
            if (first) setActiveAndScroll(first);
            justAutoFocused = false;
            updateCount(container.querySelectorAll('.md-highlight').length, term);
          } else {
            focusNext();
          }
        });
      }

      input.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') {
          ev.preventDefault();
          const all = container.querySelectorAll('.md-highlight');
          if (all.length === 0) return;
          if (ev.shiftKey) {
            const arr = Array.from(all);
            const current = container.querySelector('.md-highlight.is-active');
            const idx = current ? arr.indexOf(current) : 0;
            const prev = arr[(idx - 1 + arr.length) % arr.length];
            setActiveAndScroll(prev);
            // reset auto-focus state so forward navigation advances
            justAutoFocused = false;
            updateCount(arr.length, input.value.trim());
          } else {
            const active = container.querySelector('.md-highlight.is-active');
            if (justAutoFocused || !active) {
              const first = container.querySelector('.md-highlight');
              if (first) setActiveAndScroll(first);
              justAutoFocused = false;
              updateCount(all.length, input.value.trim());
            } else {
              focusNext();
            }
          }
        }
      });

      // הוסר הקוד הכפול מהמיין; נשארת רק הלוגיקה החדשה שלא מדלגת על הראשונה
    })();

    // Lazy loading לתמונות
    container.querySelectorAll('img').forEach(img => { img.loading = 'lazy'; });

    // KaTeX אוטו-רנדר (בבטחה; אין html גולמי)
    try { if (window.renderMathInElement) window.renderMathInElement(container, { delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}] }); } catch(_){ }

    // Mermaid: רנדר דיאגרמות בקוד fence ```mermaid
    try {
      if (!window.mermaid) throw new Error('mermaid missing');
      window.mermaid.initialize({ startOnLoad: false, securityLevel: 'strict' });
      const blocks = container.querySelectorAll('code.language-mermaid, pre code.language-mermaid');
      let i=0;
      for (const el of blocks) {
        const parent = el.closest('pre') || el.parentElement;
        const svgId = 'mmd_' + (++i);
        const code = el.textContent;
        const wrapper = document.createElement('div');
        parent.replaceWith(wrapper);
        try {
          const { svg } = await window.mermaid.render(svgId, code);
          wrapper.innerHTML = svg;
        } catch(e) {
          wrapper.innerHTML = '<div class="alert alert-warning">Mermaid render failed</div>';
        }
      }
    } catch(_){ }

    // פונקציות עזר נגישות בשימוש משותף (copy/permalink)
    function announceToScreenReader(message) {
      try {
        const announcement = document.createElement('div');
        announcement.setAttribute('role', 'status');
        announcement.setAttribute('aria-live', 'polite');
        announcement.className = 'sr-only';
        announcement.textContent = message;
        document.body.appendChild(announcement);
        setTimeout(() => { try { document.body.removeChild(announcement); } catch(_){} }, 1000);
      } catch(_) {}
    }
    function fallbackCopy(text) {
      try {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        const success = document.execCommand('copy');
        document.body.removeChild(textarea);
        return success;
      } catch(_) { return false; }
    }
    // כפתור העתקה משופר לכל בלוק קוד + נגישות מלאה
    try {
      function showCopySuccess(btn) {
        try {
          btn.classList.add('copied');
          const copyText = btn.querySelector('.copy-text');
          const copiedText = btn.querySelector('.copied-text');
          if (copyText) copyText.style.display = 'none';
          if (copiedText) copiedText.style.display = 'inline';
          setTimeout(() => {
            btn.classList.remove('copied');
            if (copyText) copyText.style.display = 'inline';
            if (copiedText) copiedText.style.display = 'none';
          }, 2000);
        } catch(_) {}
      }
      function showCopyError(btn) {
        try { btn.classList.add('copy-error'); setTimeout(() => btn.classList.remove('copy-error'), 2000); } catch(_) {}
      }
      function addCopyButtons() {
        const pres = document.querySelectorAll('#md-content pre');
        pres.forEach(pre => {
          if (pre.querySelector('.md-copy-btn')) return;
          let wrapper = pre.parentElement;
          if (!wrapper || !wrapper.classList || !wrapper.classList.contains('code-block')) {
            wrapper = document.createElement('div');
            wrapper.className = 'code-block';
            pre.replaceWith(wrapper);
            wrapper.appendChild(pre);
          }
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'md-copy-btn';
          btn.setAttribute('aria-label', 'העתק קוד');
          btn.setAttribute('role', 'button');
          btn.innerHTML = `
            <span class="copy-icon" aria-hidden="true">📋</span>
            <span class="copy-text">העתק</span>
            <span class="copied-text" style="display:none">✅ הועתק!</span>
          `;
          btn.addEventListener('click', async () => {
            const code = pre.querySelector('code')?.innerText || pre.innerText;
            try {
              await navigator.clipboard.writeText(code);
              showCopySuccess(btn);
              announceToScreenReader('הקוד הועתק ללוח');
            } catch(_) {
              if (fallbackCopy(code)) {
                showCopySuccess(btn);
                announceToScreenReader('הקוד הועתק ללוח');
              } else {
                showCopyError(btn);
                announceToScreenReader('ההעתקה נכשלה');
              }
            }
          });
          btn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              btn.click();
            }
          });
          wrapper.appendChild(btn);
        });
      }
      addCopyButtons();
    } catch(_){ }

    // Permalinks נגישים: העתקת קישור כותרת בלחיצה ומשוב ידידותי
    try {
      function showTooltip(element, message) {
        try {
          const tooltip = document.createElement('div');
          tooltip.className = 'permalink-tooltip';
          tooltip.textContent = message;
          tooltip.setAttribute('role', 'tooltip');
          const rect = element.getBoundingClientRect();
          tooltip.style.position = 'fixed';
          tooltip.style.top = `${rect.top - 30}px`;
          tooltip.style.left = `${rect.left}px`;
          document.body.appendChild(tooltip);
          setTimeout(() => { tooltip.style.opacity = '0'; setTimeout(() => { try { document.body.removeChild(tooltip); } catch(_){} }, 300); }, 2000);
        } catch(_) {}
      }
      function enhanceHeaderPermalinks() {
        const headers = document.querySelectorAll('#md-content h1, #md-content h2, #md-content h3, #md-content h4, #md-content h5, #md-content h6');
        headers.forEach(header => {
          if (!header.id) {
            // יצירת מזהה ייחודי אם חסר
            const base = (header.textContent || '').trim().toLowerCase()
              .replace(/[^\w\u0590-\u05FF\s-]/g, '')
              .replace(/[\s_]+/g, '-')
              .replace(/^-+|-+$/g, '') || 'section';
            let id = base; let i = 1;
            while (document.getElementById(id)) { id = `${base}-${++i}`; }
            header.id = id;
          }
          // אם אין עוגן שנוצר ע"י התוסף – הוסף ידנית
          if (!header.querySelector('.header-anchor')) {
            const permalink = document.createElement('a');
            permalink.className = 'header-anchor';
            permalink.href = `#${header.id}`;
            permalink.innerHTML = '🔗';
            permalink.setAttribute('aria-label', `קישור קבוע לסעיף: ${header.textContent || ''}`);
            permalink.setAttribute('title', 'העתק קישור לסעיף זה');
            header.appendChild(permalink);
          }
        });
        // רישום מאזינים להעתקה
        document.querySelectorAll('#md-content .header-anchor').forEach(permalink => {
          permalink.addEventListener('click', async (e) => {
            e.preventDefault();
            const header = permalink.closest('h1, h2, h3, h4, h5, h6');
            if (!header || !header.id) return;
            const url = new URL(window.location.href);
            url.hash = header.id;
            try {
              await navigator.clipboard.writeText(url.toString());
              showTooltip(permalink, 'הקישור הועתק!');
              // שימוש בפונקציה שהוגדרה למעלה (אם קיימת)
              try { announceToScreenReader('קישור לכותרת הועתק'); } catch(_){}
            } catch(_) {
              if (fallbackCopy(url.toString())) {
                showTooltip(permalink, 'הקישור הועתק!');
                try { announceToScreenReader('קישור לכותרת הועתק'); } catch(_){}
              }
            }
            try { header.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch(_){}
          });
        });
      }
      enhanceHeaderPermalinks();
    } catch(_){ }

    // קיצורי מקלדת בסיסיים: העתקת קוד ראשון והעתקת קישור לכותרת גלויה
    try {
      function getCurrentVisibleHeader() {
        const headers = document.querySelectorAll('#md-content h1, #md-content h2, #md-content h3, #md-content h4, #md-content h5, #md-content h6');
        const scrollPos = window.scrollY + 100;
        for (let i = headers.length - 1; i >= 0; i--) {
          const el = headers[i];
          if (el.offsetTop <= scrollPos) return el;
        }
        return headers[0] || null;
      }
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.shiftKey && e.key.toUpperCase() === 'C') {
          e.preventDefault();
          const firstCopyBtn = document.querySelector('#md-content .md-copy-btn');
          if (firstCopyBtn) firstCopyBtn.click();
        }
        if (e.ctrlKey && (e.key === 'l' || e.key === 'L')) {
          e.preventDefault();
          const currentHeader = getCurrentVisibleHeader();
          if (currentHeader) {
            const permalink = currentHeader.querySelector('.header-anchor');
            if (permalink) permalink.click();
          }
        }
      });
    } catch(_){ }

    // גלילה/פוקוס לפי hash אם הוזן בכניסה
    try {
      (function restoreScrollPosition(){
        const hash = window.location.hash;
        if (!hash) return;
        const element = document.querySelector(hash);
        if (!element) return;
        setTimeout(() => { try { element.scrollIntoView({ behavior: 'smooth', block: 'start' }); element.tabIndex = -1; element.focus(); } catch(_){} }, 100);
      })();
    } catch(_){ }

    // רשימות משימות אינטראקטיביות: שמירה/שחזור מצב
    // ב-render, markdown-it-task-lists הופך ל-input[type=checkbox]
    const boxes = container.querySelectorAll('input[type="checkbox"]');
    let idx = 0;
    boxes.forEach(cb => {
      cb.classList.add('md-task-checkbox');
      const key = 'i' + (idx++);
      // שחזור מצב
      if (Object.prototype.hasOwnProperty.call(taskState, key)) {
        cb.checked = !!taskState[key];
      }
      cb.addEventListener('change', () => {
        taskState[key] = cb.checked;
        saveTaskState(taskState);
      });
    });

    // וירטואליזציה בסיסית למסמכים ארוכים (חלוקה לקטעים לפי כותרות)
    try {
      const MAX_NODES = 2000;
      const nodes = Array.from(container.childNodes);
      if (nodes.length > MAX_NODES) {
        const chunk = document.createDocumentFragment();
        nodes.slice(0, MAX_NODES).forEach(n => chunk.appendChild(n));
        const rest = nodes.slice(MAX_NODES);
        container.innerHTML = '';
        container.appendChild(chunk);
        const more = document.createElement('button');
        more.className = 'btn btn-secondary btn-icon';
        more.textContent = 'טען עוד…';
        more.addEventListener('click', () => {
          const frag = document.createDocumentFragment();
          rest.forEach(n => frag.appendChild(n));
          container.appendChild(frag);
          more.remove();
        });
        container.appendChild(document.createElement('hr'));
        container.appendChild(more);
      }
    } catch(_){ }

  } catch (e) {
    console.error('Markdown preview failed', e);
    const container = document.getElementById('md-content');
    container.innerHTML = '<div class="alert alert-error">שגיאה ברינדור Markdown</div>';
  }
})();

// === מערכת החלפת צבעי רקע למארקדאון ===
(function initBackgroundColorSwitcher() {
  'use strict';
  
  const COLORS = {
    light: '#f5e6d3',
    medium: '#e8d4b0',
    dark: '#d4b896'
  };
  
  const STORAGE_KEY = 'md_bg_color_preference';
  
  // שליפת העדפה שמורה
  function getSavedColorPreference() {
    try {
      return localStorage.getItem(STORAGE_KEY) || null;
    } catch(_) {
      return null;
    }
  }
  
  // שמירת העדפה
  function saveColorPreference(color) {
    try {
      if (color) {
        localStorage.setItem(STORAGE_KEY, color);
      } else {
        localStorage.removeItem(STORAGE_KEY);
      }
    } catch(_) {}
  }
  
  // החלת צבע רקע
  function applyBackgroundColor(color) {
    const mdContent = document.getElementById('md-content');
    if (!mdContent) return;
    
    // הסרת כל המחלקות הקודמות
    mdContent.classList.remove('bg-light', 'bg-medium', 'bg-dark');
    
    // החלת צבע חדש אם נבחר
    if (color && COLORS[color]) {
      mdContent.classList.add(`bg-${color}`);
      
      // עדכון הכפתור הראשי
      const indicator = document.querySelector('#bgColorBtn span');
      if (indicator) {
        indicator.style.background = COLORS[color];
      }
    } else {
      // חזרה לצבע ברירת המחדל (לבן)
      const indicator = document.querySelector('#bgColorBtn span');
      if (indicator) {
        indicator.style.background = '#ffffff';
      }
    }
    
    // סימון האפשרות הפעילה
    document.querySelectorAll('.bg-color-option').forEach(btn => {
      btn.classList.remove('active');
      // השוואה גם לערך ריק עבור ברירת המחדל
      if ((color === null || color === '') && (btn.dataset.color === '' || btn.dataset.color === 'default')) {
        btn.classList.add('active');
      } else if (btn.dataset.color === color) {
        btn.classList.add('active');
      }
    });
    
    // שמירת ההעדפה
    saveColorPreference(color);
  }
  
  // אתחול המערכת
  function init() {
    const bgColorBtn = document.getElementById('bgColorBtn');
    const bgColorOptions = document.getElementById('bgColorOptions');
    
    if (!bgColorBtn || !bgColorOptions) return;
    
    // טעינת העדפה שמורה
    const savedColor = getSavedColorPreference();
    if (savedColor) {
      applyBackgroundColor(savedColor);
    }
    
    // פתיחה/סגירה של התפריט
    bgColorBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const isVisible = bgColorOptions.style.display !== 'none';
      bgColorOptions.style.display = isVisible ? 'none' : 'block';
    });
    
    // בחירת צבע
    document.querySelectorAll('.bg-color-option').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const color = btn.dataset.color;
        applyBackgroundColor(color);
        bgColorOptions.style.display = 'none';
      });
    });
    
    // סגירת התפריט בלחיצה מחוץ לאזור
    document.addEventListener('click', (e) => {
      if (!e.target.closest('#bgColorSwitcher')) {
        bgColorOptions.style.display = 'none';
      }
    });
    
    // הוספת אפשרות לחזור לצבע הלבן המקורי
    const defaultBtn = document.createElement('button');
    defaultBtn.className = 'bg-color-option';
    defaultBtn.dataset.color = ''; // ערך ריק לברירת מחדל
    defaultBtn.style = 'display:block;width:100%;padding:8px 12px;margin:4px 0;border:1px solid #ddd;border-radius:6px;background:#ffffff;color:#333;cursor:pointer;font-size:14px;transition:all 0.2s ease;';
    defaultBtn.innerHTML = `
      <span style="display:inline-block;width:20px;height:20px;border-radius:4px;background:#ffffff;border:1px solid #999;vertical-align:middle;margin-left:8px;"></span>
      לבן (ברירת מחדל)
    `;
    defaultBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      applyBackgroundColor(null); // שימוש בפונקציה המרכזית
      bgColorOptions.style.display = 'none';
    });
    
    // הוספת כפתור ברירת המחדל לתחילת הרשימה
    bgColorOptions.insertBefore(defaultBtn, bgColorOptions.firstChild);
    
    // סימון ברירת המחדל אם אין צבע שמור - יעשה אוטומטית דרך applyBackgroundColor
  }
  
  // הפעלת המערכת לאחר טעינת הדף
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();

// === תוכן עניינים צף מתקדם - גרסה 2.0 ===
(function initAdvancedTableOfContents() {
  'use strict';
  const CONFIG = {
    MAX_HEADINGS: 200,
    VIRTUAL_SCROLL_THRESHOLD: 50,
    SEARCH_DEBOUNCE: 300,
    SCROLL_OFFSET: 120,
    INTERSECTION_THRESHOLD: 0.5,
    INTERSECTION_MARGIN: '-20% 0% -70% 0%',
    WAIT_TIMEOUT: 5000,
    CHECK_INTERVAL: 100,
    LONG_PRESS_MS: 450,
    MINI_POS_KEY: 'md_toc_mini_top',
    MINIMIZED_KEY_GLOBAL: 'mdTocMinimized',
    MINIMIZED_KEY_PER_FILE_PREFIX: 'mdTocMinimized:'
  };
  let tocState = {
    headings: [],
    visibleHeadings: [],
    activeHeading: null,
    observer: null,
    clickHandlers: [],
    searchTerm: '',
    isCollapsed: false,
    isMinimized: false,
    scrollPercentage: 0
  };
  function clamp(value, min, max){ return Math.min(Math.max(value, min), max); }
  function getSavedMiniTop(){
    try { const v = parseInt(localStorage.getItem(CONFIG.MINI_POS_KEY) || '100', 10); return isNaN(v) ? 100 : v; } catch(_) { return 100; }
  }
  function saveMiniTop(top){ try { localStorage.setItem(CONFIG.MINI_POS_KEY, String(top)); } catch(_){} }
  function applyMiniTop(top){
    const miniBtn = document.getElementById('mdTocMini');
    const tocElement = document.getElementById('mdToc');
    if (miniBtn) miniBtn.style.top = top + 'px';
    if (tocElement) tocElement.style.top = top + 'px';
  }
  function debounce(func, wait) {
    let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); };
  }
  function sanitizeText(text) {
    const div = document.createElement('div'); div.textContent = text; return div.innerHTML.replace(/[<>\"'&]/g, '').replace(/¶/g, '').trim();
  }
  function generateUniqueId(prefix, index) {
    return `${prefix}-${Date.now()}-${index}-${Math.random().toString(36).substr(2, 9)}`;
  }
  function waitForContent(callback) {
    const startTime = Date.now();
    function check() {
      try {
        const container = document.getElementById('md-content');
        const hasContent = container && container.innerHTML.trim().length > 0 && container.querySelector('h1, h2, h3, h4, h5, h6');
        if (hasContent) { setTimeout(callback, 50); }
        else if (Date.now() - startTime < CONFIG.WAIT_TIMEOUT) { setTimeout(check, CONFIG.CHECK_INTERVAL); }
        else { console.warn('TOC: תוכן לא נטען בזמן המוגדר'); hideTOC(); }
      } catch (e) { console.error('TOC: שגיאה בבדיקת תוכן', e); hideTOC(); }
    }
    check();
  }
  function hideTOC() { const tocElement = document.getElementById('mdToc'); if (tocElement) tocElement.style.display = 'none'; }
  function cleanup() {
    try {
      if (tocState.observer) { tocState.observer.disconnect(); tocState.observer = null; }
      tocState.clickHandlers.forEach(({ element, event, handler }) => { element.removeEventListener(event, handler); });
      tocState.clickHandlers = [];
    } catch (e) { console.error('TOC: שגיאה בניקוי', e); }
  }
  function buildTOC() {
    try {
      const container = document.getElementById('md-content');
      const tocElement = document.getElementById('mdToc');
      const tocNav = document.getElementById('mdTocNav');
      if (!container || !tocElement || !tocNav) { console.error('TOC: אלמנטים חסרים'); return; }
      let headings = Array.from(container.querySelectorAll('h1, h2, h3, h4, h5, h6'));
      if (headings.length === 0) { console.info('TOC: לא נמצאו כותרות במסמך'); hideTOC(); return; }
      if (headings.length > CONFIG.MAX_HEADINGS) { console.warn(`TOC: נמצאו ${headings.length} כותרות, מציג רק ${CONFIG.MAX_HEADINGS} הראשונות`); headings = headings.slice(0, CONFIG.MAX_HEADINGS); }
      tocState.headings = headings;
      const fragment = document.createDocumentFragment();
      const seenIds = new Map();
      headings.forEach((heading, index) => {
        try {
          const level = parseInt(heading.tagName.substring(1));
          const text = sanitizeText(heading.textContent || '');
          // שמירת מזהים קיימים שנוצרו ע״י markdown-it-anchor; שינוי רק במקרה כפילויות או חוסר מזהה
          let currentId = heading.id || '';
          if (!currentId) {
            currentId = generateUniqueId('toc-heading', index);
            heading.id = currentId;
          }
          const priorCount = seenIds.get(currentId) || 0;
          if (priorCount > 0) {
            // הפוך לכותרת ייחודית בלי לשנות את הראשונה
            let suffix = priorCount + 1;
            let candidate = `${currentId}-${suffix}`;
            while (document.getElementById(candidate) || seenIds.has(candidate)) {
              suffix += 1;
              candidate = `${currentId}-${suffix}`;
            }
            heading.id = candidate;
            currentId = candidate;
          }
          seenIds.set(currentId, (seenIds.get(currentId) || 0) + 1);

          const item = document.createElement('a');
          item.className = 'md-toc-item';
          item.setAttribute('data-level', level);
          item.setAttribute('href', `#${encodeURIComponent(currentId)}`);
          item.setAttribute('data-index', index);
          item.setAttribute('aria-label', `עבור לכותרת: ${text}`);
          item.textContent = text;
          if (text.length > 30) { item.title = text; item.textContent = text.substring(0, 30) + '...'; }
          const clickHandler = (e) => { e.preventDefault(); try { heading.scrollIntoView({ behavior: 'smooth', block: 'start' }); updateActiveItem(item); closeSearch(); minimizeTOC(); } catch (error) { console.error('TOC: שגיאה בגלילה', error); } };
          item.addEventListener('click', clickHandler);
          tocState.clickHandlers.push({ element: item, event: 'click', handler: clickHandler });
          fragment.appendChild(item);
        } catch (error) { console.error('TOC: שגיאה ביצירת פריט', error); }
      });
      tocNav.appendChild(fragment);
      if (headings.length > CONFIG.VIRTUAL_SCROLL_THRESHOLD) { setupVirtualScrolling(); }
      setupIntersectionObserver();
      setupInteractions();
      setupSearch();
      setupKeyboardShortcuts();
      setupProgressIndicator();
      tocElement.style.display = 'block';
      // החלת העדפת מיזעור (גלובלי/פר-קובץ) לאחר בנייה
      try { if (typeof getSavedMinimizedPreference === 'function' && getSavedMinimizedPreference()) { minimizeTOC(); } } catch(_) {}
      console.info(`TOC: נבנה בהצלחה עם ${headings.length} כותרות`);
    } catch (e) { console.error('TOC: שגיאה כללית בבנייה', e); hideTOC(); }
  }
  function setupVirtualScrolling() {
    console.info('TOC: מפעיל Virtual Scrolling');
    const tocNav = document.getElementById('mdTocNav'); if (!tocNav) return;
    const observer = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) { entry.target.classList.remove('md-toc-item-placeholder'); } else { entry.target.classList.add('md-toc-item-placeholder'); } }); }, { root: tocNav, rootMargin: '100px' });
    tocNav.querySelectorAll('.md-toc-item').forEach(item => { observer.observe(item); });
  }
  function setupIntersectionObserver() {
    try {
      const options = { rootMargin: CONFIG.INTERSECTION_MARGIN, threshold: CONFIG.INTERSECTION_THRESHOLD };
      tocState.observer = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) { const index = tocState.headings.indexOf(entry.target); if (index !== -1) { const item = document.querySelector(`.md-toc-item[data-index="${index}"]`); if (item) updateActiveItem(item); } } }); }, options);
      tocState.headings.forEach(heading => { tocState.observer.observe(heading); });
      console.debug('TOC: Intersection Observer מופעל');
    } catch (e) { console.error('TOC: שגיאה ב-Intersection Observer', e); setupScrollFallback(); }
  }
  function setupScrollFallback() {
    console.info('TOC: משתמש ב-scroll event כ-fallback');
    let ticking = false; const scrollHandler = () => { if (!ticking) { window.requestAnimationFrame(() => { updateActiveHeadingByScroll(); ticking = false; }); ticking = true; } };
    window.addEventListener('scroll', scrollHandler, { passive: true });
    tocState.clickHandlers.push({ element: window, event: 'scroll', handler: scrollHandler });
  }
  function updateActiveHeadingByScroll() {
    const scrollPos = window.scrollY + CONFIG.SCROLL_OFFSET; let activeHeading = null;
    for (let i = tocState.headings.length - 1; i >= 0; i--) { const heading = tocState.headings[i]; if (heading.offsetTop <= scrollPos) { activeHeading = heading; break; } }
    if (activeHeading) { const index = tocState.headings.indexOf(activeHeading); const item = document.querySelector(`.md-toc-item[data-index="${index}"]`); if (item) updateActiveItem(item); }
  }
  function updateActiveItem(newActiveItem) {
    document.querySelectorAll('.md-toc-item').forEach(item => { item.classList.remove('active'); });
    if (newActiveItem) {
      newActiveItem.classList.add('active'); tocState.activeHeading = newActiveItem;
      const tocNav = document.getElementById('mdTocNav'); if (tocNav) { const itemRect = newActiveItem.getBoundingClientRect(); const navRect = tocNav.getBoundingClientRect(); if (itemRect.top < navRect.top || itemRect.bottom > navRect.bottom) { newActiveItem.scrollIntoView({ behavior: 'smooth', block: 'center' }); } }
    }
  }
  function setupInteractions() {
    const tocElement = document.getElementById('mdToc');
    const tocToggle = document.getElementById('mdTocToggle');
    const tocHeader = document.querySelector('.md-toc-header');
    const miniBtn = document.getElementById('mdTocMini');
    const menuBtn = document.getElementById('mdTocMenuBtn');
    if (tocToggle && tocElement) {
      const toggleHandler = (e) => { e.stopPropagation(); tocState.isCollapsed = !tocState.isCollapsed; tocElement.classList.toggle('collapsed'); tocToggle.setAttribute('aria-expanded', !tocState.isCollapsed); localStorage.setItem('mdTocCollapsed', tocState.isCollapsed); };
      tocToggle.addEventListener('click', toggleHandler);
      tocState.clickHandlers.push({ element: tocToggle, event: 'click', handler: toggleHandler });
    }
    if (tocHeader && tocElement) {
      const headerHandler = () => { tocState.isCollapsed = !tocState.isCollapsed; tocElement.classList.toggle('collapsed'); if (tocToggle) { tocToggle.setAttribute('aria-expanded', !tocState.isCollapsed); } localStorage.setItem('mdTocCollapsed', tocState.isCollapsed); };
      tocHeader.addEventListener('click', headerHandler);
      tocState.clickHandlers.push({ element: tocHeader, event: 'click', handler: headerHandler });
    }
    if (miniBtn && tocElement) {
      // שחזור מיקום שמור
      applyMiniTop(getSavedMiniTop());
      const miniHandler = () => {
        tocElement.classList.remove('minimized');
        tocElement.classList.remove('collapsed');
        const tocToggle = document.getElementById('mdTocToggle');
        if (tocToggle) tocToggle.setAttribute('aria-expanded', 'true');
        tocState.isCollapsed = false;
        tocElement.style.display = 'block';
        miniBtn.style.display = 'none';
        tocState.isMinimized = false;
      };
      miniBtn.addEventListener('click', miniHandler);
      tocState.clickHandlers.push({ element: miniBtn, event: 'click', handler: miniHandler });

      // גרירה אנכית לריבוע הצף (שומר מיקום)
      let dragActive = false; let startY = 0; let startTop = 0; const onPointerDown = (ev) => {
        try { ev.preventDefault(); } catch(_){}
        dragActive = true; startY = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || 0;
        startTop = parseInt(window.getComputedStyle(miniBtn).top || '100', 10) || 100;
        try { miniBtn.setPointerCapture && miniBtn.setPointerCapture(ev.pointerId); } catch(_){}
      };
      const onPointerMove = (ev) => {
        if (!dragActive) return; const y = ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || 0; const delta = y - startY; let newTop = startTop + delta; const maxTop = Math.max(60, window.innerHeight - 64); newTop = clamp(newTop, 60, maxTop); applyMiniTop(newTop);
      };
      const onPointerUp = (ev) => { if (!dragActive) return; dragActive = false; const top = parseInt(miniBtn.style.top || '100', 10) || 100; saveMiniTop(top); };
      miniBtn.addEventListener('pointerdown', onPointerDown, { passive: false });
      window.addEventListener('pointermove', onPointerMove, { passive: false });
      window.addEventListener('pointerup', onPointerUp);
      window.addEventListener('pointercancel', onPointerUp);
      // רישום לניקוי
      tocState.clickHandlers.push({ element: miniBtn, event: 'pointerdown', handler: onPointerDown });
      tocState.clickHandlers.push({ element: window, event: 'pointermove', handler: onPointerMove });
      tocState.clickHandlers.push({ element: window, event: 'pointerup', handler: onPointerUp });
      tocState.clickHandlers.push({ element: window, event: 'pointercancel', handler: onPointerUp });
    }
    // לחיצה ארוכה על סמל ☰ למזעור מהיר
    if (menuBtn) {
      let pressTimer = null;
      const start = (e) => { try { e.preventDefault(); } catch(_){}; clearTimeout(pressTimer); pressTimer = setTimeout(() => { minimizeTOC(); }, CONFIG.LONG_PRESS_MS); };
      const cancel = () => { clearTimeout(pressTimer); };
      const ctxHandler = (e)=>{ try{ e.preventDefault(); }catch(_){} };
      menuBtn.addEventListener('pointerdown', start);
      menuBtn.addEventListener('pointerup', cancel);
      menuBtn.addEventListener('pointerleave', cancel);
      menuBtn.addEventListener('contextmenu', ctxHandler);
      // רישום לניקוי
      tocState.clickHandlers.push({ element: menuBtn, event: 'pointerdown', handler: start });
      tocState.clickHandlers.push({ element: menuBtn, event: 'pointerup', handler: cancel });
      tocState.clickHandlers.push({ element: menuBtn, event: 'pointerleave', handler: cancel });
      tocState.clickHandlers.push({ element: menuBtn, event: 'contextmenu', handler: ctxHandler });
    }
    const savedCollapsed = localStorage.getItem('mdTocCollapsed');
    if (savedCollapsed === 'true') {
      tocElement?.classList.add('collapsed'); if (tocToggle) tocToggle.setAttribute('aria-expanded', 'false'); tocState.isCollapsed = true;
    }
  }
  function setupSearch() {
    const searchBtn = document.getElementById('mdTocSearch');
    const searchContainer = document.getElementById('tocSearchContainer');
    const searchInput = document.getElementById('tocSearchInput');
    const searchResults = document.getElementById('tocSearchResults');
    if (!searchBtn || !searchContainer || !searchInput) return;
    const searchBtnHandler = (e) => { e.stopPropagation(); const isVisible = searchContainer.style.display !== 'none'; searchContainer.style.display = isVisible ? 'none' : 'block'; if (!isVisible) { searchInput.focus(); } else { closeSearch(); } };
    searchBtn.addEventListener('click', searchBtnHandler);
    tocState.clickHandlers.push({ element: searchBtn, event: 'click', handler: searchBtnHandler });
    function escapeRegExp(string) { return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
    function highlightText(element, searchTerm) {
      const originalText = element.textContent; if (!searchTerm) { element.textContent = originalText; return; }
      element.textContent = ''; const escapedTerm = escapeRegExp(searchTerm); const regex = new RegExp(escapedTerm, 'gi'); let lastIndex = 0; let match; const maxIterations = 100; let iterations = 0;
      while ((match = regex.exec(originalText)) !== null && iterations < maxIterations) {
        iterations++; if (match.index > lastIndex) { const textNode = document.createTextNode(originalText.slice(lastIndex, match.index)); element.appendChild(textNode); }
        const mark = document.createElement('mark'); mark.textContent = match[0]; element.appendChild(mark); lastIndex = regex.lastIndex; if (regex.lastIndex === match.index) { regex.lastIndex++; }
      }
      if (lastIndex < originalText.length) { const textNode = document.createTextNode(originalText.slice(lastIndex)); element.appendChild(textNode); }
    }
    const searchHandler = debounce((e) => {
      const searchTerm = e.target.value.toLowerCase().trim(); const MAX_SEARCH_LENGTH = 100; if (searchTerm.length > MAX_SEARCH_LENGTH) { console.warn('TOC: חיפוש ארוך מדי'); return; }
      tocState.searchTerm = searchTerm; const items = document.querySelectorAll('.md-toc-item'); let matchCount = 0; items.forEach(item => { if (!item.dataset.originalText) { item.dataset.originalText = item.textContent; } const originalText = item.dataset.originalText; const text = originalText.toLowerCase(); if (!searchTerm) { item.classList.remove('search-hidden', 'search-match'); item.textContent = originalText; } else if (text.includes(searchTerm)) { item.classList.remove('search-hidden'); item.classList.add('search-match'); highlightText(item, searchTerm); matchCount++; } else { item.classList.add('search-hidden'); item.classList.remove('search-match'); item.textContent = originalText; } }); if (searchResults) { if (!searchTerm) { searchResults.textContent = ''; } else if (matchCount === 0) { searchResults.textContent = 'לא נמצאו תוצאות'; } else { searchResults.textContent = `נמצאו ${matchCount} תוצאות`; } }
    }, CONFIG.SEARCH_DEBOUNCE);
    searchInput.addEventListener('input', searchHandler);
    tocState.clickHandlers.push({ element: searchInput, event: 'input', handler: searchHandler });
    const escapeHandler = (e) => { if (e.key === 'Escape' && searchContainer.style.display !== 'none') { closeSearch(); } };
    searchInput.addEventListener('keydown', escapeHandler);
    tocState.clickHandlers.push({ element: searchInput, event: 'keydown', handler: escapeHandler });
  }
  function closeSearch() {
    const searchContainer = document.getElementById('tocSearchContainer');
    const searchInput = document.getElementById('tocSearchInput');
    const searchResults = document.getElementById('tocSearchResults');
    if (searchContainer) searchContainer.style.display = 'none'; if (searchInput) searchInput.value = ''; if (searchResults) searchResults.textContent = '';
    document.querySelectorAll('.md-toc-item').forEach(item => { item.classList.remove('search-hidden', 'search-match'); if (item.dataset.originalText) { item.textContent = item.dataset.originalText; } });
    tocState.searchTerm = '';
  }
  function setupKeyboardShortcuts() {
    const keyboardHandler = (e) => {
      if (e.ctrlKey && e.key === 't') { e.preventDefault(); const tocToggle = document.getElementById('mdTocToggle'); if (tocToggle) tocToggle.click(); }
      if (e.ctrlKey && e.key === 'f') { const tocElement = document.getElementById('mdToc'); if (tocElement && tocElement.contains(document.activeElement)) { e.preventDefault(); const searchBtn = document.getElementById('mdTocSearch'); if (searchBtn) searchBtn.click(); } }
      if (e.ctrlKey && e.key === 'm') { e.preventDefault(); toggleMinimize(); }
    };
    document.addEventListener('keydown', keyboardHandler);
    tocState.clickHandlers.push({ element: document, event: 'keydown', handler: keyboardHandler });
  }
  function setMinimizedPreference(isMinimized){
    try {
      // שמירה גלובלית
      localStorage.setItem(CONFIG.MINIMIZED_KEY_GLOBAL, isMinimized ? '1' : '0');
      // שמירה פר-קובץ
      if (typeof FILE_ID !== 'undefined' && FILE_ID) {
        localStorage.setItem(CONFIG.MINIMIZED_KEY_PER_FILE_PREFIX + FILE_ID, isMinimized ? '1' : '0');
      }
    } catch(_) {}
  }
  function getSavedMinimizedPreference(){
    try {
      // עדיפות להגדרה פר-קובץ אם קיימת
      if (typeof FILE_ID !== 'undefined' && FILE_ID) {
        const perFile = localStorage.getItem(CONFIG.MINIMIZED_KEY_PER_FILE_PREFIX + FILE_ID);
        if (perFile === '1' || perFile === '0') return perFile === '1';
      }
      const globalVal = localStorage.getItem(CONFIG.MINIMIZED_KEY_GLOBAL);
      if (globalVal === '1' || globalVal === '0') return globalVal === '1';
    } catch(_) {}
    return false;
  }
  function minimizeTOC(){
    const tocElement = document.getElementById('mdToc');
    const miniBtn = document.getElementById('mdTocMini');
    if (!tocElement || !miniBtn) return;
    tocState.isMinimized = true;
    tocElement.style.display = 'none';
    miniBtn.style.display = 'block';
    applyMiniTop(parseInt(miniBtn.style.top||String(getSavedMiniTop()),10));
    setMinimizedPreference(true);
  }
  function restoreTOC(){
    const tocElement = document.getElementById('mdToc');
    const miniBtn = document.getElementById('mdTocMini');
    if (!tocElement || !miniBtn) return;
    tocState.isMinimized = false;
    tocElement.style.display = 'block';
    miniBtn.style.display = 'none';
    setMinimizedPreference(false);
  }
  function toggleMinimize() { if (tocState.isMinimized) { restoreTOC(); } else { minimizeTOC(); } }
  function setupProgressIndicator() {
    const progressBar = document.getElementById('tocProgressBar'); if (!progressBar) return; const updateProgress = () => { const scrollHeight = document.documentElement.scrollHeight - window.innerHeight; const scrollPosition = window.scrollY; const percentage = Math.round((scrollPosition / scrollHeight) * 100); progressBar.style.width = `${percentage}%`; tocState.scrollPercentage = percentage; const progressContainer = document.querySelector('.md-toc-progress'); if (progressContainer) { progressContainer.setAttribute('aria-valuenow', percentage); } };
    updateProgress(); let progressTicking = false; const progressHandler = () => { if (!progressTicking) { window.requestAnimationFrame(() => { updateProgress(); progressTicking = false; }); progressTicking = true; } };
    window.addEventListener('scroll', progressHandler, { passive: true });
    tocState.clickHandlers.push({ element: window, event: 'scroll', handler: progressHandler });
  }
  function init() {
    try {
      console.info('TOC: מתחיל אתחול');
      waitForContent(buildTOC);
      window.addEventListener('beforeunload', cleanup);
      if (window.navigation) { window.navigation.addEventListener('navigate', cleanup); }
      // יישר מיקום התפריט והכפתור המינימלי לשורה אחת בצד שמאל
      applyMiniTop(getSavedMiniTop());
      // שחזור העדפת מיזעור (גלובלי/פר-קובץ)
      if (getSavedMinimizedPreference()) {
        // נבטיח שהכפתור המינימלי נראה כבר בטעינה
        const tocElement = document.getElementById('mdToc');
        const miniBtn = document.getElementById('mdTocMini');
        if (tocElement && miniBtn) {
          tocElement.style.display = 'none';
          miniBtn.style.display = 'block';
          tocState.isMinimized = true;
        }
      }
    } catch (e) { console.error('TOC: שגיאה באתחול', e); hideTOC(); }
  }
  init();
})();
// מסך מלא ל- Markdown Card
(function(){
  try {
    const btn = document.getElementById('mdFullscreenBtn');
    const card = document.getElementById('mdCard');
    if (!btn || !card) return;
    function isFullscreen(){ return document.fullscreenElement === card; }
    function updateButton(){
      if (isFullscreen()) {
        btn.innerHTML = '<i class="fas fa-compress"></i> יציאה ממסך מלא';
        // Fallback: הסתרת TOC במצב מסך מלא גם אם כלל ה-CSS לא תופס
        try {
          const toc = document.getElementById('mdToc');
          const mini = document.getElementById('mdTocMini');
          if (toc) { toc.dataset.prevDisplay = toc.style.display || ''; toc.style.display = 'none'; }
          if (mini) { mini.dataset.prevDisplay = mini.style.display || ''; mini.style.display = 'none'; }
        } catch(_) {}
      } else {
        btn.innerHTML = '<i class="fas fa-expand"></i> מסך מלא';
        // Fallback: שחזור מצב ה-TOC לאחר יציאה ממסך מלא
        try {
          const toc = document.getElementById('mdToc');
          const mini = document.getElementById('mdTocMini');
          if (toc && Object.prototype.hasOwnProperty.call(toc.dataset, 'prevDisplay')) {
            toc.style.display = toc.dataset.prevDisplay;
            delete toc.dataset.prevDisplay;
          }
          if (mini && Object.prototype.hasOwnProperty.call(mini.dataset, 'prevDisplay')) {
            mini.style.display = mini.dataset.prevDisplay;
            delete mini.dataset.prevDisplay;
          }
        } catch(_) {}
      }
    }
    btn.addEventListener('click', async function(){
      try {
        if (!isFullscreen()) { await card.requestFullscreen(); }
        else { await document.exitFullscreen(); }
      } catch(_) {}
    });
    document.addEventListener('fullscreenchange', updateButton);
    updateButton();
  } catch(_) {}
})();

// יצירת קישור ציבורי שמכוון לתצוגת Markdown (view=md)
async function ensurePublicLinkMd(){
  try {
    const resp = await fetch(`/api/share/{{ file.id }}`, { method: 'POST' });
    const data = await resp.json();
    let baseUrl = window.location.origin;
    let url = (data && data.ok && data.url) ? data.url : window.location.href;
    try {
      const u = new URL(url, window.location.origin);
      u.searchParams.set('view', 'md');
      return u.toString();
    } catch(_) {
      return url + (url.includes('?') ? '&' : '?') + 'view=md';
    }
  } catch (e) {
    try {
      const u = new URL(window.location.href);
      u.searchParams.set('view','md');
      return u.toString();
    } catch(_) {
      return window.location.href;
    }
  }
}

async function copyLinkMd(){
  const url = await ensurePublicLinkMd();
  try { await navigator.clipboard.writeText(url); alert('הקישור הציבורי הועתק!'); }
  catch(e){ console.error('copy failed', e); alert('לא הצלחנו להעתיק את הקישור'); }
}

async function shareToTelegramMd(){
  const url = await ensurePublicLinkMd();
  const text = `צפה במסמך Markdown ב-Code Keeper:`;
  const telegramUrl = `https://t.me/share/url?url=${encodeURIComponent(url)}&text=${encodeURIComponent(text)}`;
  try { window.open(telegramUrl, '_blank'); } catch(_) { window.location.href = telegramUrl; }
}

// ניווט חזרה אמין: אם יש היסטוריה – חזור; אחרת נווט ישירות לעמוד הקובץ
function goBackToFile(ev){
  try { if (ev) ev.preventDefault(); } catch(_){ }
  try {
    const sameOriginRef = document.referrer && new URL(document.referrer, window.location.origin).origin === window.location.origin;
    if (window.history && window.history.length > 1 && sameOriginRef) {
      window.history.back();
      return false;
    }
  } catch(_){ }
  try { window.location.replace('/file/{{ file.id }}'); } catch(_) { window.location.href = '/file/{{ file.id }}'; }
  return false;
}

// התאמת גודל שם הקובץ: מצמצם פונט הדרגתי עד שנכנס בשורה אחת (עם מינימום מוגן)
(function(){
  try {
    var el = document.getElementById('md-file-name');
    if (!el) return;
    el.setAttribute('title', el.textContent || '');
    var sizeRem = 1.6;    // גודל יעד התחלתי (התואם ל-CSS)
    var minRem = 1.0;     // מינימום – לא קטן מדי
    el.style.fontSize = sizeRem + 'rem';
    var guard = 0;
    while (guard < 15 && el.scrollWidth > el.clientWidth && sizeRem > minRem) {
      sizeRem -= 0.1;
      el.style.fontSize = sizeRem.toFixed(2) + 'rem';
      guard++;
    }
  } catch(_) { }
})();
</script>
{% if not is_public %}{% include 'bookmarks_snippet.html' %}{% endif %}
{% endblock %}

