# 🕵️ מדריך איתור תקלות וניתוח שורש (Root Cause Analysis)

מסמך זה מתאר את המתודולוגיה המומלצת לחקירת באגים ובעיות ביצועים במערכת.
הגישה שלנו היא **"שיטת המשפך"**: מתחילים מהתמונה הגדולה ומצמצמים עד לשורת הקוד הבעייתית.

## 🛠️ כלים נדרשים
* **Sentry:** לזיהוי שגיאות בזמן אמת (Exceptions).
* **Logs / Kibana:** לזיהוי איטיות ותהליכים (Latency/Traffic).
* **Code Editor:** לבדיקת הקוד ומציאת האשמים.

---

## 🚦 שלב 1: מתי זה התחיל? (The Timeline)
הנתון הקריטי ביותר בחקירה הוא הזמן. ב-Sentry, תמיד בדוק את שדה **First Seen**.

* **קרה לפני דקות/שעות?**
  * שאל: "מה השתנה במערכת?"
  * האם בוצע Deploy לקוד חדש? ⬅️ חשד ל**באג לוגי**.
  * האם יש קפיצה בכמות המשתמשים? ⬅️ חשד ל**בעיית משאבים/עומס**.

* **קרה לפני ימים/חודשים?**
  * זוהי ככל הנראה **בעיה תשתיתית כרונית** (כגון ניתוקי רשת אקראיים) או מקרה קצה (Edge Case) נדיר.

---

## 📍 שלב 2: איפה זה כואב? (The Stack Trace)
אל תסתפק בכותרת השגיאה (למשל `internal_alert`). פתח את הלוג המלא (Traceback).

1. **Top Frame (השורה העליונה):** בדרך כלל ספרייה חיצונית (כגון `pymongo`, `requests`).
   * *משמעות:* "איך נפלתי?" (למשל: Timeout, Connection Error).
2. **Your Frame (הקוד שלך):** גלול למטה עד שתמצא את הקובץ הראשון ששייך לפרויקט (למשל `services/manager.py`).
   * *משמעות:* "מי הפיל אותי?" (הפונקציה שקראה לפעולה שנכשלה).

---

## 🔗 שלב 3: חפש דפוסים (Correlations)
באגים אוהבים חברה. חפש אירועים שקרו במקביל.

* **Latency גבוה + שאילתה כבדה:**
  אם השרת הגיב לאט (למשל ב-`/healthz`), בדוק האם באותו רגע רצה שאילתה כבדה (כגון `aggregations`).
  * *מסקנה:* Resource Starvation (הרעבת משאבים).

* **שגיאות רשת + חוסר פעילות:**
  אם השגיאות קורות רק לאחר זמן מנוחה (לילה/סופ"ש).
  * *מסקנה:* Connection Pool Cold Start (ניתוק בגלל Idle Timeout).

---

## 🕵️‍♂️ שלב 4: שיטת "5 הלמה" (The 5 Whys)
כדי להגיע לשורש הבעיה ולא רק לטפל בסימפטום, שאל "למה?" 5 פעמים.

**דוגמה (מקרה אמיתי - שגיאת MongoDB 40):**
1. **למה נכשלתי?** קיבלתי `Conflict Error` ממונגו.
2. **למה Conflict?** ניסיתי לעדכן את השדה `username` פעמיים באותה פעולה.
3. **למה פעמיים?** השדה נשלח גם ב-`$set` וגם ב-`$setOnInsert`.
4. **למה בשניהם?** פונקציית ה-Save מוסיפה ברירות מחדל ל-Insert אוטומטית.
5. **למה זה לא נוקה?** חסרה בדיקת קוד שמוחקת כפילויות לפני השליחה.
   * ✅ **התיקון:** הוספת תנאי `if` למניעת כפילות.

---

## 🧪 שלב 5: השחזור (Reproduction)
הדרך היחידה לוודא שמצאת את הבעיה היא לשחזר אותה.

* האם אפשר לגרום לשגיאה לקרות בכוונה בסביבה מקומית (Local)?
* דוגמה: "אם אריץ את הפקודה `/stats` פעמיים רצוף, האם אקבל את השגיאה?"
* **הצלחת לשחזר?** מזל טוב, פתרון הבעיה הוא עניין של זמן קצר.

---

## 🐢 אבחון איטיות (High Latency Diagnosis)

כאשר מתקבלות התראות על `High Latency` או `anomaly_detected`, יש לבדוק בלוגים את השדה `queue_time_ms` (אם קיים) כדי לבודד את מקור הבעיה.

### טבלת אבחון מהירה (The Latency Compass)

| סימפטום בלוגים | משמעות (Diagnosis) | פעולות לביצוע (Action Items) |
| :--- | :--- | :--- |
| **`queue_time` גבוה** <br> (ו-`duration` גבוה) | **בעיית קיבולת (Capacity)** <br> השרת "פקוק". הבקשה המתינה זמן רב עד ש-Worker התפנה לטפל בה. הקוד עצמו אולי תקין. | 1. **Connection Pool:** בדוק אם ה-Pool חנוק (High Utilization). <br> 2. **Workers:** שקול להגדיל מספר Workers/Memory. <br> 3. **Noisy Neighbor:** האם יש בוטים שמפציצים את ה-API? |
| **`queue_time` נמוך** <br> (אבל `duration` גבוה) | **בעיית קוד (Code/Logic)** <br> הבקשה נכנסה מיד לעיבוד, אך הלוגיקה רצה לאט. | 1. **DB:** חפש שאילתות כבדות (`currentOp` או Slow Query Log). <br> 2. **External:** האם יש קריאה איטית ל-API חיצוני (Telegram/AI)? <br> 3. **CPU:** האם יש לולאה כבדה בקוד? |

### 👻 הערה על "בקשות רפאים"
אם מופיע לוג חריג בשעה לא הגיונית (למשל אמצע הלילה) עם `queue_time` גבוה מאוד:
* **זהו אירוע מושהה.** האירוע קרה בפועל בזמן: `timestamp` מינוס `queue_time`.
* זה מעיד בדרך כלל על התאוששות מתקיעה (למשל: חידוש חיבור ל-DB אחרי ניתוק).

