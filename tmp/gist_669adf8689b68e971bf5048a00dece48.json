{
  "url": "https://api.github.com/gists/669adf8689b68e971bf5048a00dece48",
  "forks_url": "https://api.github.com/gists/669adf8689b68e971bf5048a00dece48/forks",
  "commits_url": "https://api.github.com/gists/669adf8689b68e971bf5048a00dece48/commits",
  "id": "669adf8689b68e971bf5048a00dece48",
  "node_id": "G_kwDODNevjNoAIDY2OWFkZjg2ODliNjhlOTcxYmY1MDQ4YTAwZGVjZTQ4",
  "git_pull_url": "https://gist.github.com/669adf8689b68e971bf5048a00dece48.git",
  "git_push_url": "https://gist.github.com/669adf8689b68e971bf5048a00dece48.git",
  "html_url": "https://gist.github.com/amirbiron/669adf8689b68e971bf5048a00dece48",
  "files": {
    "4.js": {
      "filename": "4.js",
      "type": "text/javascript",
      "language": "JavaScript",
      "raw_url": "https://gist.githubusercontent.com/amirbiron/669adf8689b68e971bf5048a00dece48/raw/8f40a06b4341edbbe07c423878062e51551249ae/4.js",
      "size": 28703,
      "truncated": false,
      "content": "/**\n * Bookmarks Manager for WebApp\n * ××¢×¨×›×ª × ×™×”×•×œ ×¡×™×× ×™×•×ª ××œ××” ×œ×§×‘×¦×™ ×§×•×“\n */\n\nclass BookmarkManager {\n    constructor(fileId) {\n        this.fileId = fileId;\n        this.bookmarks = new Map();\n        this.api = new BookmarkAPI(fileId);\n        this.ui = new BookmarkUI();\n        this.offline = new OfflineBookmarkManager();\n        this.syncChecker = new SyncChecker(fileId);\n        \n        this.init();\n    }\n    \n    async init() {\n        try {\n            // ×˜×¢×Ÿ ×¡×™×× ×™×•×ª ×§×™×™××•×ª\n            await this.loadBookmarks();\n            \n            // ×”×’×“×¨ event delegation\n            this.setupEventDelegation();\n            \n            // ×”×’×“×¨ keyboard shortcuts\n            this.setupKeyboardShortcuts();\n            \n            // ×”×ª×—×œ ×‘×“×™×§×ª ×¡× ×›×¨×•×Ÿ\n            this.syncChecker.startMonitoring();\n            \n            // ×¡× ×›×¨×Ÿ offline bookmarks\n            await this.offline.syncPending();\n            \n            console.log('BookmarkManager initialized successfully');\n            \n        } catch (error) {\n            console.error('Error initializing BookmarkManager:', error);\n            this.ui.showError('×©×’×™××” ×‘××ª×—×•×œ ××¢×¨×›×ª ×”×¡×™×× ×™×•×ª');\n        }\n    }\n    \n    setupEventDelegation() {\n        // Event delegation ×œ×§×•×“\n        const codeContainer = document.querySelector('.highlight, .highlighttable');\n        if (codeContainer) {\n            codeContainer.addEventListener('click', (e) => this.handleCodeClick(e));\n            codeContainer.addEventListener('mouseover', (e) => this.handleCodeHover(e));\n        }\n        \n        // Event delegation ×œ×¤×× ×œ\n        const panel = document.getElementById('bookmarksPanel');\n        if (panel) {\n            panel.addEventListener('click', (e) => this.handlePanelClick(e));\n        }\n        \n        // ×›×¤×ª×•×¨ toggle ×¤×× ×œ\n        const toggleBtn = document.getElementById('toggleBookmarksBtn');\n        if (toggleBtn) {\n            toggleBtn.addEventListener('click', () => this.ui.togglePanel());\n        }\n    }\n    \n    setupKeyboardShortcuts() {\n        document.addEventListener('keydown', (e) => {\n            // Ctrl/Cmd + B - toggle bookmark\n            if ((e.ctrlKey || e.metaKey) && e.key === 'b') {\n                e.preventDefault();\n                const currentLine = this.getCurrentLineFromSelection();\n                if (currentLine) {\n                    this.toggleBookmark(currentLine);\n                }\n            }\n            \n            // Ctrl/Cmd + Shift + B - toggle panel\n            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'B') {\n                e.preventDefault();\n                this.ui.togglePanel();\n            }\n            \n            // Escape - ×¡×’×•×¨ ×¤×× ×œ\n            if (e.key === 'Escape' && this.ui.isPanelOpen()) {\n                this.ui.closePanel();\n            }\n        });\n    }\n    \n    async handleCodeClick(event) {\n        const lineNumEl = event.target.closest('.linenos span, .linenodiv a');\n        if (!lineNumEl) return;\n        \n        event.preventDefault();\n        event.stopPropagation();\n        \n        const lineNumber = this.extractLineNumber(lineNumEl);\n        if (!lineNumber) return;\n        \n        // Shift+Click = ×”×•×¡×£/×¢×¨×•×š ×”×¢×¨×”\n        if (event.shiftKey) {\n            await this.promptForNote(lineNumber);\n        }\n        // Ctrl/Cmd+Click = ××—×§ ×¡×™×× ×™×™×”\n        else if (event.ctrlKey || event.metaKey) {\n            if (this.bookmarks.has(lineNumber)) {\n                await this.deleteBookmark(lineNumber);\n            }\n        }\n        // Click ×¨×’×™×œ = toggle\n        else {\n            await this.toggleBookmark(lineNumber);\n        }\n    }\n    \n    handleCodeHover(event) {\n        const lineNumEl = event.target.closest('.linenos span, .linenodiv a');\n        if (!lineNumEl) return;\n        \n        const lineNumber = this.extractLineNumber(lineNumEl);\n        if (!lineNumber) return;\n        \n        // ×”×¦×’ tooltip ×× ×™×© ×¡×™×× ×™×™×”\n        if (this.bookmarks.has(lineNumber)) {\n            const bookmark = this.bookmarks.get(lineNumber);\n            if (bookmark.note) {\n                this.ui.showTooltip(lineNumEl, bookmark.note);\n            }\n        }\n    }\n    \n    async handlePanelClick(event) {\n        // ×œ×—×™×¦×” ×¢×œ ×¡×™×× ×™×™×”\n        const bookmarkItem = event.target.closest('.bookmark-item');\n        if (bookmarkItem) {\n            const lineNumber = parseInt(bookmarkItem.dataset.lineNumber);\n            \n            // ×œ×—×™×¦×” ×¢×œ ×›×¤×ª×•×¨ ××—×™×§×”\n            if (event.target.closest('.delete-btn')) {\n                event.stopPropagation();\n                await this.deleteBookmark(lineNumber);\n                return;\n            }\n            \n            // ×œ×—×™×¦×” ×¢×œ ×›×¤×ª×•×¨ ×¢×¨×™×›×”\n            if (event.target.closest('.edit-btn')) {\n                event.stopPropagation();\n                await this.promptForNote(lineNumber);\n                return;\n            }\n            \n            // ×œ×—×™×¦×” ×¢×œ ×”×¡×™×× ×™×™×” - ×’×œ×•×œ ×œ×©×•×¨×”\n            this.scrollToLine(lineNumber);\n        }\n        \n        // ×›×¤×ª×•×¨ × ×™×§×•×™ ×›×œ ×”×¡×™×× ×™×•×ª\n        if (event.target.closest('#clearAllBookmarks')) {\n            if (confirm('×”×× ×œ××—×•×§ ××ª ×›×œ ×”×¡×™×× ×™×•×ª ×‘×§×•×‘×¥ ×–×”?')) {\n                await this.clearAllBookmarks();\n            }\n        }\n        \n        // ×›×¤×ª×•×¨ ×™×™×¦×•×\n        if (event.target.closest('#exportBookmarks')) {\n            this.exportBookmarks();\n        }\n    }\n    \n    async toggleBookmark(lineNumber) {\n        try {\n            // ×”×¦×’ loading\n            this.ui.showLineLoading(lineNumber, true);\n            \n            // ×§×‘×œ ×˜×§×¡×˜ ×”×©×•×¨×”\n            const lineText = this.getLineText(lineNumber);\n            \n            // ×©×œ×— ×œ×©×¨×ª\n            const result = await this.api.toggleBookmark(lineNumber, lineText);\n            \n            if (result.ok) {\n                if (result.action === 'added') {\n                    this.bookmarks.set(lineNumber, result.bookmark);\n                    this.ui.addBookmarkIndicator(lineNumber);\n                    this.ui.showNotification('×¡×™×× ×™×™×” × ×•×¡×¤×”', 'success');\n                } else if (result.action === 'removed') {\n                    this.bookmarks.delete(lineNumber);\n                    this.ui.removeBookmarkIndicator(lineNumber);\n                    this.ui.showNotification('×¡×™×× ×™×™×” ×”×•×¡×¨×”', 'info');\n                }\n                \n                this.ui.updateCount(this.bookmarks.size);\n                this.ui.refreshPanel(Array.from(this.bookmarks.values()));\n            } else {\n                throw new Error(result.error || '×©×’×™××” ×‘×©××™×¨×ª ×”×¡×™×× ×™×™×”');\n            }\n            \n        } catch (error) {\n            console.error('Toggle bookmark error:', error);\n            \n            // × ×¡×” offline\n            if (!navigator.onLine) {\n                await this.offline.saveBookmark(this.fileId, lineNumber);\n                this.ui.showNotification('×©××•×¨ ××§×•××™×ª - ×™×¡×•× ×›×¨×Ÿ ×××•×—×¨ ×™×•×ª×¨', 'warning');\n            } else {\n                this.ui.showError(error.message);\n            }\n            \n        } finally {\n            this.ui.showLineLoading(lineNumber, false);\n        }\n    }\n    \n    async deleteBookmark(lineNumber) {\n        try {\n            const result = await this.api.deleteBookmark(lineNumber);\n            \n            if (result.ok) {\n                this.bookmarks.delete(lineNumber);\n                this.ui.removeBookmarkIndicator(lineNumber);\n                this.ui.updateCount(this.bookmarks.size);\n                this.ui.refreshPanel(Array.from(this.bookmarks.values()));\n                this.ui.showNotification('×¡×™×× ×™×™×” × ××—×§×”', 'info');\n            }\n            \n        } catch (error) {\n            this.ui.showError('×©×’×™××” ×‘××—×™×§×ª ×”×¡×™×× ×™×™×”');\n        }\n    }\n    \n    async promptForNote(lineNumber) {\n        const existingNote = this.bookmarks.get(lineNumber)?.note || '';\n        const note = prompt('×”×•×¡×£/×¢×¨×•×š ×”×¢×¨×” ×œ×¡×™×× ×™×™×”:', existingNote);\n        \n        if (note === null) return; // ×‘×™×˜×•×œ\n        \n        try {\n            if (!this.bookmarks.has(lineNumber)) {\n                // ×¦×•×¨ ×¡×™×× ×™×™×” ×—×“×©×” ×¢× ×”×¢×¨×”\n                const lineText = this.getLineText(lineNumber);\n                const result = await this.api.toggleBookmark(lineNumber, lineText, note);\n                \n                if (result.ok && result.action === 'added') {\n                    this.bookmarks.set(lineNumber, result.bookmark);\n                    this.ui.addBookmarkIndicator(lineNumber);\n                }\n            } else {\n                // ×¢×“×›×Ÿ ×”×¢×¨×” ×§×™×™××ª\n                const result = await this.api.updateNote(lineNumber, note);\n                \n                if (result.ok) {\n                    const bookmark = this.bookmarks.get(lineNumber);\n                    bookmark.note = note;\n                    this.bookmarks.set(lineNumber, bookmark);\n                }\n            }\n            \n            this.ui.refreshPanel(Array.from(this.bookmarks.values()));\n            this.ui.showNotification('×”×”×¢×¨×” × ×©××¨×”', 'success');\n            \n        } catch (error) {\n            this.ui.showError('×©×’×™××” ×‘×©××™×¨×ª ×”×”×¢×¨×”');\n        }\n    }\n    \n    async clearAllBookmarks() {\n        try {\n            const result = await this.api.clearFileBookmarks();\n            \n            if (result.ok) {\n                this.bookmarks.clear();\n                this.ui.clearAllIndicators();\n                this.ui.updateCount(0);\n                this.ui.refreshPanel([]);\n                this.ui.showNotification(`${result.deleted} ×¡×™×× ×™×•×ª × ××—×§×•`, 'info');\n            }\n            \n        } catch (error) {\n            this.ui.showError('×©×’×™××” ×‘××—×™×§×ª ×”×¡×™×× ×™×•×ª');\n        }\n    }\n    \n    async loadBookmarks() {\n        try {\n            const result = await this.api.getFileBookmarks();\n            \n            if (result.ok) {\n                result.bookmarks.forEach(bm => {\n                    this.bookmarks.set(bm.line_number, bm);\n                    this.ui.addBookmarkIndicator(bm.line_number);\n                });\n                \n                this.ui.updateCount(this.bookmarks.size);\n                this.ui.refreshPanel(result.bookmarks);\n            }\n            \n        } catch (error) {\n            console.error('Error loading bookmarks:', error);\n            \n            // ×˜×¢×Ÿ ×-cache ×× ×™×©\n            const cached = this.offline.getCachedBookmarks(this.fileId);\n            if (cached.length > 0) {\n                cached.forEach(bm => {\n                    this.bookmarks.set(bm.line_number, bm);\n                    this.ui.addBookmarkIndicator(bm.line_number);\n                });\n                \n                this.ui.showNotification('×˜×¢×™× ×” ×××˜××•×Ÿ ××§×•××™', 'warning');\n            }\n        }\n    }\n    \n    scrollToLine(lineNumber) {\n        const lineElement = document.querySelector(\n            `.linenos span:nth-child(${lineNumber}), .linenodiv a:nth-child(${lineNumber})`\n        );\n        \n        if (lineElement) {\n            lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n            \n            // ×”×“×’×© ××ª ×”×©×•×¨×”\n            this.ui.highlightLine(lineNumber);\n        }\n    }\n    \n    getLineText(lineNumber) {\n        const codeLines = document.querySelectorAll('.code pre > span, .highlight pre > span');\n        \n        if (codeLines[lineNumber - 1]) {\n            return codeLines[lineNumber - 1].textContent.trim().substring(0, 100);\n        }\n        \n        return '';\n    }\n    \n    extractLineNumber(element) {\n        // × ×¡×” ×œ×§×‘×œ ×-text content\n        const text = element.textContent.trim();\n        const num = parseInt(text);\n        if (num > 0) return num;\n        \n        // × ×¡×” ×œ×§×‘×œ ×-href (×œ×¤×•×¨××˜ #L123)\n        const href = element.getAttribute('href');\n        if (href) {\n            const match = href.match(/#L?(\\d+)/);\n            if (match) return parseInt(match[1]);\n        }\n        \n        // × ×¡×” ×œ×§×‘×œ ×-index\n        const parent = element.parentElement;\n        if (parent) {\n            const index = Array.from(parent.children).indexOf(element);\n            if (index >= 0) return index + 1;\n        }\n        \n        return null;\n    }\n    \n    getCurrentLineFromSelection() {\n        const selection = window.getSelection();\n        if (!selection.rangeCount) return null;\n        \n        const range = selection.getRangeAt(0);\n        const container = range.commonAncestorContainer;\n        \n        // ×—×¤×© ××ª ×”×©×•×¨×” ×”×§×¨×•×‘×” ×‘×™×•×ª×¨\n        let element = container.nodeType === 3 ? container.parentElement : container;\n        \n        while (element) {\n            const lineNum = element.querySelector('.linenos span, .linenodiv a');\n            if (lineNum) {\n                return this.extractLineNumber(lineNum);\n            }\n            element = element.parentElement;\n        }\n        \n        return null;\n    }\n    \n    exportBookmarks() {\n        const data = {\n            file_id: this.fileId,\n            file_name: document.title,\n            bookmarks: Array.from(this.bookmarks.values()),\n            exported_at: new Date().toISOString()\n        };\n        \n        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });\n        const url = URL.createObjectURL(blob);\n        \n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `bookmarks_${this.fileId}_${Date.now()}.json`;\n        a.click();\n        \n        URL.revokeObjectURL(url);\n        this.ui.showNotification('×”×¡×™×× ×™×•×ª ×™×•×¦××• ×‘×”×¦×œ×—×”', 'success');\n    }\n}\n\n// ==================== BookmarkAPI Class ====================\n\nclass BookmarkAPI {\n    constructor(fileId) {\n        this.fileId = fileId;\n        this.baseUrl = '/api/bookmarks';\n        this.maxRetries = 3;\n        this.retryDelay = 1000;\n    }\n    \n    async toggleBookmark(lineNumber, lineText = '', note = '') {\n        return this.retryableRequest('POST', `/${this.fileId}/toggle`, {\n            line_number: lineNumber,\n            line_text: lineText,\n            note: note\n        });\n    }\n    \n    async getFileBookmarks() {\n        return this.retryableRequest('GET', `/${this.fileId}`);\n    }\n    \n    async updateNote(lineNumber, note) {\n        return this.retryableRequest('PUT', `/${this.fileId}/${lineNumber}/note`, {\n            note: note\n        });\n    }\n    \n    async deleteBookmark(lineNumber) {\n        return this.retryableRequest('DELETE', `/${this.fileId}/${lineNumber}`);\n    }\n    \n    async clearFileBookmarks() {\n        return this.retryableRequest('DELETE', `/${this.fileId}/clear`);\n    }\n    \n    async retryableRequest(method, path, body = null) {\n        let lastError;\n        \n        for (let attempt = 1; attempt <= this.maxRetries; attempt++) {\n            try {\n                const options = {\n                    method: method,\n                    headers: {\n                        'Content-Type': 'application/json'\n                    }\n                };\n                \n                if (body && method !== 'GET') {\n                    options.body = JSON.stringify(body);\n                }\n                \n                const response = await fetch(this.baseUrl + path, options);\n                \n                if (!response.ok) {\n                    if (response.status === 429) {\n                        // Rate limiting\n                        const retryAfter = response.headers.get('Retry-After') || 60;\n                        throw new Error(`Rate limited. Try again in ${retryAfter} seconds`);\n                    }\n                    \n                    if (response.status >= 500 && attempt < this.maxRetries) {\n                        // Server error - retry\n                        await this.sleep(this.retryDelay * attempt);\n                        continue;\n                    }\n                    \n                    const errorData = await response.json();\n                    throw new Error(errorData.error || 'Request failed');\n                }\n                \n                return await response.json();\n                \n            } catch (error) {\n                lastError = error;\n                \n                if (attempt < this.maxRetries && !error.message.includes('Rate limited')) {\n                    await this.sleep(this.retryDelay * attempt);\n                    continue;\n                }\n            }\n        }\n        \n        throw lastError || new Error('Request failed after retries');\n    }\n    \n    sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n}\n\n// ==================== BookmarkUI Class ====================\n\nclass BookmarkUI {\n    constructor() {\n        this.panel = document.getElementById('bookmarksPanel');\n        this.countBadge = document.getElementById('bookmarkCount');\n        this.notificationContainer = this.createNotificationContainer();\n    }\n    \n    createNotificationContainer() {\n        let container = document.getElementById('notificationContainer');\n        if (!container) {\n            container = document.createElement('div');\n            container.id = 'notificationContainer';\n            container.className = 'notification-container';\n            document.body.appendChild(container);\n        }\n        return container;\n    }\n    \n    showNotification(message, type = 'info') {\n        const notification = document.createElement('div');\n        notification.className = `notification notification-${type}`;\n        notification.innerHTML = `\n            <span class=\"notification-icon\">${this.getNotificationIcon(type)}</span>\n            <span class=\"notification-message\">${this.escapeHtml(message)}</span>\n        `;\n        \n        this.notificationContainer.appendChild(notification);\n        \n        // ×× ×™××¦×™×™×ª ×›× ×™×¡×”\n        setTimeout(() => notification.classList.add('show'), 10);\n        \n        // ×”×¡×¨×” ××•×˜×•××˜×™×ª\n        setTimeout(() => {\n            notification.classList.remove('show');\n            setTimeout(() => notification.remove(), 300);\n        }, 3000);\n    }\n    \n    showError(message) {\n        this.showNotification(message, 'error');\n    }\n    \n    getNotificationIcon(type) {\n        const icons = {\n            'success': 'âœ“',\n            'error': 'âœ•',\n            'warning': 'âš ',\n            'info': 'â„¹'\n        };\n        return icons[type] || icons['info'];\n    }\n    \n    addBookmarkIndicator(lineNumber) {\n        const lineElement = document.querySelector(\n            `.linenos span:nth-child(${lineNumber}), .linenodiv a:nth-child(${lineNumber})`\n        );\n        \n        if (lineElement && !lineElement.classList.contains('bookmarked')) {\n            lineElement.classList.add('bookmarked');\n            \n            // ×”×•×¡×£ ××™×™×§×•×Ÿ\n            if (!lineElement.querySelector('.bookmark-icon')) {\n                const icon = document.createElement('span');\n                icon.className = 'bookmark-icon';\n                icon.innerHTML = 'ğŸ”–';\n                lineElement.appendChild(icon);\n            }\n        }\n    }\n    \n    removeBookmarkIndicator(lineNumber) {\n        const lineElement = document.querySelector(\n            `.linenos span:nth-child(${lineNumber}), .linenodiv a:nth-child(${lineNumber})`\n        );\n        \n        if (lineElement) {\n            lineElement.classList.remove('bookmarked');\n            const icon = lineElement.querySelector('.bookmark-icon');\n            if (icon) icon.remove();\n        }\n    }\n    \n    clearAllIndicators() {\n        document.querySelectorAll('.bookmarked').forEach(el => {\n            el.classList.remove('bookmarked');\n            const icon = el.querySelector('.bookmark-icon');\n            if (icon) icon.remove();\n        });\n    }\n    \n    updateCount(count) {\n        if (this.countBadge) {\n            this.countBadge.textContent = count;\n            this.countBadge.style.display = count > 0 ? 'inline-block' : 'none';\n        }\n    }\n    \n    refreshPanel(bookmarks) {\n        if (!this.panel) return;\n        \n        const listContainer = this.panel.querySelector('.bookmarks-list');\n        if (!listContainer) return;\n        \n        if (bookmarks.length === 0) {\n            listContainer.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>××™×Ÿ ×¡×™×× ×™×•×ª ×‘×§×•×‘×¥ ×–×”</p>\n                    <p>×œ×—×¥ ×¢×œ ××¡×¤×¨ ×©×•×¨×” ×›×“×™ ×œ×”×•×¡×™×£ ×¡×™×× ×™×™×”</p>\n                </div>\n            `;\n            return;\n        }\n        \n        // ××™×™×Ÿ ×œ×¤×™ ××¡×¤×¨ ×©×•×¨×”\n        bookmarks.sort((a, b) => a.line_number - b.line_number);\n        \n        listContainer.innerHTML = bookmarks.map(bm => `\n            <div class=\"bookmark-item\" data-line-number=\"${bm.line_number}\">\n                <div class=\"bookmark-content\">\n                    <span class=\"line-number\">×©×•×¨×” ${bm.line_number}</span>\n                    <span class=\"line-preview\">${this.escapeHtml(bm.line_text_preview || '')}</span>\n                    ${bm.note ? `<span class=\"bookmark-note\">${this.escapeHtml(bm.note)}</span>` : ''}\n                </div>\n                <div class=\"bookmark-actions\">\n                    <button class=\"edit-btn\" title=\"×¢×¨×•×š ×”×¢×¨×”\">âœï¸</button>\n                    <button class=\"delete-btn\" title=\"××—×§ ×¡×™×× ×™×™×”\">ğŸ—‘ï¸</button>\n                </div>\n            </div>\n        `).join('');\n    }\n    \n    togglePanel() {\n        if (this.panel) {\n            this.panel.classList.toggle('open');\n            \n            // ×¢×“×›×Ÿ ARIA\n            const toggleBtn = document.getElementById('toggleBookmarksBtn');\n            if (toggleBtn) {\n                const isOpen = this.panel.classList.contains('open');\n                toggleBtn.setAttribute('aria-expanded', isOpen);\n            }\n        }\n    }\n    \n    closePanel() {\n        if (this.panel) {\n            this.panel.classList.remove('open');\n        }\n    }\n    \n    isPanelOpen() {\n        return this.panel && this.panel.classList.contains('open');\n    }\n    \n    showLineLoading(lineNumber, show) {\n        const lineElement = document.querySelector(\n            `.linenos span:nth-child(${lineNumber}), .linenodiv a:nth-child(${lineNumber})`\n        );\n        \n        if (lineElement) {\n            if (show) {\n                lineElement.classList.add('loading');\n            } else {\n                lineElement.classList.remove('loading');\n            }\n        }\n    }\n    \n    highlightLine(lineNumber) {\n        // ×”×¡×¨ ×”×“×’×©×•×ª ×§×•×“××•×ª\n        document.querySelectorAll('.line-highlighted').forEach(el => {\n            el.classList.remove('line-highlighted');\n        });\n        \n        // ×”×“×’×© ××ª ×”×©×•×¨×” ×”×—×“×©×”\n        const lineElement = document.querySelector(\n            `.code pre > span:nth-child(${lineNumber}), .highlight pre > span:nth-child(${lineNumber})`\n        );\n        \n        if (lineElement) {\n            lineElement.classList.add('line-highlighted');\n            \n            // ×”×¡×¨ ×”×“×’×©×” ××—×¨×™ 2 ×©× ×™×•×ª\n            setTimeout(() => {\n                lineElement.classList.remove('line-highlighted');\n            }, 2000);\n        }\n    }\n    \n    showTooltip(element, text) {\n        // ×™×¦×™×¨×ª tooltip\n        let tooltip = document.getElementById('bookmark-tooltip');\n        if (!tooltip) {\n            tooltip = document.createElement('div');\n            tooltip.id = 'bookmark-tooltip';\n            tooltip.className = 'bookmark-tooltip';\n            document.body.appendChild(tooltip);\n        }\n        \n        tooltip.textContent = text;\n        tooltip.style.display = 'block';\n        \n        // ××™×§×•×\n        const rect = element.getBoundingClientRect();\n        tooltip.style.left = rect.right + 10 + 'px';\n        tooltip.style.top = rect.top + 'px';\n        \n        // ×”×¡×ª×¨×” ×‘×¢×–×™×‘×”\n        element.addEventListener('mouseleave', () => {\n            tooltip.style.display = 'none';\n        }, { once: true });\n    }\n    \n    escapeHtml(text) {\n        const map = {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;',\n            \"'\": '&#039;',\n            '/': '&#x2F;'\n        };\n        return (text || '').replace(/[&<>\"'/]/g, m => map[m]);\n    }\n}\n\n// ==================== OfflineBookmarkManager Class ====================\n\nclass OfflineBookmarkManager {\n    constructor() {\n        this.STORAGE_KEY = 'pending_bookmarks';\n        this.CACHE_KEY = 'cached_bookmarks';\n        \n        // ×¡× ×›×¨×Ÿ ×›×©×—×•×–×¨×™× online\n        window.addEventListener('online', () => this.syncPending());\n    }\n    \n    async saveBookmark(fileId, lineNumber, note = '') {\n        const pending = this.getPending();\n        const id = `${fileId}_${lineNumber}_${Date.now()}`;\n        \n        pending[id] = {\n            fileId,\n            lineNumber,\n            note,\n            timestamp: Date.now()\n        };\n        \n        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(pending));\n        return true;\n    }\n    \n    async syncPending() {\n        if (!navigator.onLine) return;\n        \n        const pending = this.getPending();\n        const failed = {};\n        \n        for (const [id, bookmark] of Object.entries(pending)) {\n            try {\n                const api = new BookmarkAPI(bookmark.fileId);\n                await api.toggleBookmark(bookmark.lineNumber, '', bookmark.note);\n                console.log(`Synced offline bookmark: ${id}`);\n            } catch (error) {\n                console.error(`Failed to sync ${id}:`, error);\n                failed[id] = bookmark;\n            }\n        }\n        \n        // ×©××•×¨ ×¨×§ ××ª ××” ×©× ×›×©×œ\n        if (Object.keys(failed).length > 0) {\n            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(failed));\n        } else {\n            localStorage.removeItem(this.STORAGE_KEY);\n        }\n    }\n    \n    getPending() {\n        const stored = localStorage.getItem(this.STORAGE_KEY);\n        return stored ? JSON.parse(stored) : {};\n    }\n    \n    cacheBookmarks(fileId, bookmarks) {\n        const cache = this.getCache();\n        cache[fileId] = {\n            bookmarks,\n            timestamp: Date.now()\n        };\n        localStorage.setItem(this.CACHE_KEY, JSON.stringify(cache));\n    }\n    \n    getCachedBookmarks(fileId) {\n        const cache = this.getCache();\n        const fileCache = cache[fileId];\n        \n        if (fileCache) {\n            // ×‘×“×•×§ ×× ×”××˜××•×Ÿ ×œ× ×™×©×Ÿ ××“×™ (24 ×©×¢×•×ª)\n            const age = Date.now() - fileCache.timestamp;\n            if (age < 24 * 60 * 60 * 1000) {\n                return fileCache.bookmarks;\n            }\n        }\n        \n        return [];\n    }\n    \n    getCache() {\n        const stored = localStorage.getItem(this.CACHE_KEY);\n        return stored ? JSON.parse(stored) : {};\n    }\n}\n\n// ==================== SyncChecker Class ====================\n\nclass SyncChecker {\n    constructor(fileId) {\n        this.fileId = fileId;\n        this.checkInterval = 60000; // ×“×§×”\n        this.intervalId = null;\n    }\n    \n    startMonitoring() {\n        // ×‘×“×•×§ ×›×œ ×“×§×” ×× ×”×§×•×‘×¥ ×”×©×ª× ×”\n        this.intervalId = setInterval(() => this.checkSync(), this.checkInterval);\n    }\n    \n    stopMonitoring() {\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n            this.intervalId = null;\n        }\n    }\n    \n    async checkSync() {\n        // TODO: implement sync checking with server\n        // This would check if the file content changed and update bookmarks accordingly\n    }\n}\n\n// ==================== ××ª×—×•×œ ====================\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    // ×§×‘×œ ××ª ×”-file ID\n    const fileIdElement = document.getElementById('fileId');\n    const fileId = fileIdElement ? fileIdElement.value : null;\n    \n    if (fileId) {\n        // ×¦×•×¨ ××ª ×× ×”×œ ×”×¡×™×× ×™×•×ª\n        window.bookmarkManager = new BookmarkManager(fileId);\n        console.log('Bookmarks system initialized for file:', fileId);\n    } else {\n        console.warn('No file ID found, bookmarks system not initialized');\n    }\n});",
      "encoding": "utf-8"
    }
  },
  "public": true,
  "created_at": "2025-10-09T13:48:04Z",
  "updated_at": "2025-10-09T13:48:05Z",
  "description": "webapp/static/js/bookmarks.js",
  "comments": 0,
  "user": null,
  "comments_enabled": true,
  "comments_url": "https://api.github.com/gists/669adf8689b68e971bf5048a00dece48/comments",
  "owner": {
    "login": "amirbiron",
    "id": 215461772,
    "node_id": "U_kgDODNevjA",
    "avatar_url": "https://avatars.githubusercontent.com/u/215461772?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amirbiron",
    "html_url": "https://github.com/amirbiron",
    "followers_url": "https://api.github.com/users/amirbiron/followers",
    "following_url": "https://api.github.com/users/amirbiron/following{/other_user}",
    "gists_url": "https://api.github.com/users/amirbiron/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amirbiron/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amirbiron/subscriptions",
    "organizations_url": "https://api.github.com/users/amirbiron/orgs",
    "repos_url": "https://api.github.com/users/amirbiron/repos",
    "events_url": "https://api.github.com/users/amirbiron/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amirbiron/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "forks": [

  ],
  "history": [
    {
      "user": {
        "login": "amirbiron",
        "id": 215461772,
        "node_id": "U_kgDODNevjA",
        "avatar_url": "https://avatars.githubusercontent.com/u/215461772?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amirbiron",
        "html_url": "https://github.com/amirbiron",
        "followers_url": "https://api.github.com/users/amirbiron/followers",
        "following_url": "https://api.github.com/users/amirbiron/following{/other_user}",
        "gists_url": "https://api.github.com/users/amirbiron/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/amirbiron/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/amirbiron/subscriptions",
        "organizations_url": "https://api.github.com/users/amirbiron/orgs",
        "repos_url": "https://api.github.com/users/amirbiron/repos",
        "events_url": "https://api.github.com/users/amirbiron/events{/privacy}",
        "received_events_url": "https://api.github.com/users/amirbiron/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "version": "41011210de6ca821078023dd017e956bde3777f5",
      "committed_at": "2025-10-09T13:48:04Z",
      "change_status": {
        "total": 844,
        "additions": 844,
        "deletions": 0
      },
      "url": "https://api.github.com/gists/669adf8689b68e971bf5048a00dece48/41011210de6ca821078023dd017e956bde3777f5"
    }
  ],
  "truncated": false
}
