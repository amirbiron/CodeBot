{
  "url": "https://api.github.com/gists/d891ae93dfc9df54b3863538f3c49dc6",
  "forks_url": "https://api.github.com/gists/d891ae93dfc9df54b3863538f3c49dc6/forks",
  "commits_url": "https://api.github.com/gists/d891ae93dfc9df54b3863538f3c49dc6/commits",
  "id": "d891ae93dfc9df54b3863538f3c49dc6",
  "node_id": "G_kwDODNevjNoAIGQ4OTFhZTkzZGZjOWRmNTRiMzg2MzUzOGYzYzQ5ZGM2",
  "git_pull_url": "https://gist.github.com/d891ae93dfc9df54b3863538f3c49dc6.git",
  "git_push_url": "https://gist.github.com/d891ae93dfc9df54b3863538f3c49dc6.git",
  "html_url": "https://gist.github.com/amirbiron/d891ae93dfc9df54b3863538f3c49dc6",
  "files": {
    "8.py": {
      "filename": "8.py",
      "type": "application/x-python",
      "language": "Python",
      "raw_url": "https://gist.githubusercontent.com/amirbiron/d891ae93dfc9df54b3863538f3c49dc6/raw/40b56878001b914ee27e088cdcf2ad980b85f599/8.py",
      "size": 14128,
      "truncated": false,
      "content": "#!/usr/bin/env python3\n\"\"\"\nTest suite for Bookmarks feature\nבדיקות למערכת הסימניות\n\"\"\"\n\nimport unittest\nimport sys\nfrom pathlib import Path\nfrom datetime import datetime, timezone\nfrom unittest.mock import Mock, patch, MagicMock\n\n# Add project root to path\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom database.models.bookmark import FileBookmark, MAX_BOOKMARKS_PER_FILE, MAX_BOOKMARKS_PER_USER\nfrom database.bookmarks_manager import BookmarksManager\n\n\nclass TestFileBookmarkModel(unittest.TestCase):\n    \"\"\"Tests for FileBookmark model\"\"\"\n    \n    def test_bookmark_creation(self):\n        \"\"\"Test creating a bookmark\"\"\"\n        bookmark = FileBookmark(\n            user_id=123,\n            file_id=\"abc123\",\n            file_name=\"test.py\",\n            file_path=\"/path/test.py\",\n            line_number=42,\n            line_text_preview=\"def test():\",\n            note=\"Test note\"\n        )\n        \n        self.assertEqual(bookmark.user_id, 123)\n        self.assertEqual(bookmark.line_number, 42)\n        self.assertEqual(bookmark.note, \"Test note\")\n        self.assertTrue(bookmark.valid)\n    \n    def test_bookmark_to_dict(self):\n        \"\"\"Test converting bookmark to dictionary\"\"\"\n        bookmark = FileBookmark(\n            user_id=123,\n            file_id=\"abc123\",\n            file_name=\"test.py\",\n            file_path=\"/path/test.py\",\n            line_number=42\n        )\n        \n        data = bookmark.to_dict()\n        \n        self.assertIn(\"user_id\", data)\n        self.assertIn(\"file_id\", data)\n        self.assertIn(\"line_number\", data)\n        self.assertEqual(data[\"user_id\"], 123)\n        self.assertEqual(data[\"line_number\"], 42)\n    \n    def test_bookmark_from_dict(self):\n        \"\"\"Test creating bookmark from dictionary\"\"\"\n        data = {\n            \"user_id\": 456,\n            \"file_id\": \"def456\",\n            \"file_name\": \"another.py\",\n            \"file_path\": \"/another.py\",\n            \"line_number\": 100,\n            \"note\": \"Another note\",\n            \"created_at\": datetime.now(timezone.utc)\n        }\n        \n        bookmark = FileBookmark.from_dict(data)\n        \n        self.assertEqual(bookmark.user_id, 456)\n        self.assertEqual(bookmark.file_id, \"def456\")\n        self.assertEqual(bookmark.line_number, 100)\n        self.assertEqual(bookmark.note, \"Another note\")\n    \n    def test_text_length_limits(self):\n        \"\"\"Test that text fields are properly limited\"\"\"\n        long_text = \"x\" * 1000\n        \n        bookmark = FileBookmark(\n            user_id=123,\n            file_id=\"abc\",\n            file_name=\"test.py\",\n            file_path=\"/test.py\",\n            line_number=1,\n            line_text_preview=long_text,\n            note=long_text,\n            code_context=long_text\n        )\n        \n        data = bookmark.to_dict()\n        \n        self.assertEqual(len(data[\"line_text_preview\"]), 100)\n        self.assertEqual(len(data[\"note\"]), 500)\n        self.assertEqual(len(data[\"code_context\"]), 500)\n\n\nclass TestBookmarksManager(unittest.TestCase):\n    \"\"\"Tests for BookmarksManager\"\"\"\n    \n    def setUp(self):\n        \"\"\"Setup test database mock\"\"\"\n        self.mock_db = MagicMock()\n        self.mock_collection = MagicMock()\n        self.mock_db.file_bookmarks = self.mock_collection\n        self.mock_db.bookmark_events = MagicMock()\n        self.mock_db.files = MagicMock()\n        \n        self.manager = BookmarksManager(self.mock_db)\n    \n    def test_toggle_bookmark_add(self):\n        \"\"\"Test adding a new bookmark\"\"\"\n        # Mock that bookmark doesn't exist\n        self.mock_collection.find_one.return_value = None\n        self.mock_collection.count_documents.return_value = 0\n        self.mock_collection.insert_one.return_value = Mock(inserted_id=\"new_id\")\n        \n        result = self.manager.toggle_bookmark(\n            user_id=123,\n            file_id=\"file123\",\n            file_name=\"test.py\",\n            file_path=\"/test.py\",\n            line_number=42,\n            line_text=\"def test():\",\n            note=\"Test bookmark\"\n        )\n        \n        self.assertTrue(result[\"ok\"])\n        self.assertEqual(result[\"action\"], \"added\")\n        self.assertIsNotNone(result[\"bookmark\"])\n        \n        # Verify insert was called\n        self.mock_collection.insert_one.assert_called_once()\n    \n    def test_toggle_bookmark_remove(self):\n        \"\"\"Test removing an existing bookmark\"\"\"\n        # Mock that bookmark exists\n        existing = {\"_id\": \"existing_id\", \"user_id\": 123}\n        self.mock_collection.find_one.return_value = existing\n        \n        result = self.manager.toggle_bookmark(\n            user_id=123,\n            file_id=\"file123\",\n            file_name=\"test.py\",\n            file_path=\"/test.py\",\n            line_number=42\n        )\n        \n        self.assertTrue(result[\"ok\"])\n        self.assertEqual(result[\"action\"], \"removed\")\n        self.assertIsNone(result[\"bookmark\"])\n        \n        # Verify delete was called\n        self.mock_collection.delete_one.assert_called_once_with({\"_id\": \"existing_id\"})\n    \n    def test_bookmark_limits_per_file(self):\n        \"\"\"Test that bookmarks are limited per file\"\"\"\n        # Mock that bookmark doesn't exist\n        self.mock_collection.find_one.return_value = None\n        # Mock that we're at the limit\n        self.mock_collection.count_documents.side_effect = [\n            MAX_BOOKMARKS_PER_FILE,  # File limit check\n            0  # User limit check\n        ]\n        \n        result = self.manager.toggle_bookmark(\n            user_id=123,\n            file_id=\"file123\",\n            file_name=\"test.py\",\n            file_path=\"/test.py\",\n            line_number=42\n        )\n        \n        self.assertFalse(result[\"ok\"])\n        self.assertEqual(result[\"action\"], \"error\")\n        self.assertIn(str(MAX_BOOKMARKS_PER_FILE), result[\"error\"])\n    \n    def test_bookmark_limits_per_user(self):\n        \"\"\"Test that bookmarks are limited per user\"\"\"\n        # Mock that bookmark doesn't exist\n        self.mock_collection.find_one.return_value = None\n        # Mock that we're at the user limit\n        self.mock_collection.count_documents.side_effect = [\n            0,  # File limit check (OK)\n            MAX_BOOKMARKS_PER_USER  # User limit check (at limit)\n        ]\n        \n        result = self.manager.toggle_bookmark(\n            user_id=123,\n            file_id=\"file123\",\n            file_name=\"test.py\",\n            file_path=\"/test.py\",\n            line_number=42\n        )\n        \n        self.assertFalse(result[\"ok\"])\n        self.assertEqual(result[\"action\"], \"error\")\n        self.assertIn(str(MAX_BOOKMARKS_PER_USER), result[\"error\"])\n    \n    def test_invalid_line_number(self):\n        \"\"\"Test that invalid line numbers are rejected\"\"\"\n        result = self.manager.toggle_bookmark(\n            user_id=123,\n            file_id=\"file123\",\n            file_name=\"test.py\",\n            file_path=\"/test.py\",\n            line_number=0  # Invalid\n        )\n        \n        self.assertFalse(result[\"ok\"])\n        self.assertEqual(result[\"action\"], \"error\")\n        self.assertIn(\"מספר שורה\", result[\"error\"])\n    \n    def test_get_file_bookmarks(self):\n        \"\"\"Test getting bookmarks for a file\"\"\"\n        mock_bookmarks = [\n            {\n                \"_id\": \"id1\",\n                \"user_id\": 123,\n                \"file_id\": \"file123\",\n                \"line_number\": 10,\n                \"note\": \"First\"\n            },\n            {\n                \"_id\": \"id2\",\n                \"user_id\": 123,\n                \"file_id\": \"file123\",\n                \"line_number\": 20,\n                \"note\": \"Second\"\n            }\n        ]\n        \n        mock_cursor = MagicMock()\n        mock_cursor.sort.return_value = mock_bookmarks\n        self.mock_collection.find.return_value = mock_cursor\n        \n        bookmarks = self.manager.get_file_bookmarks(123, \"file123\")\n        \n        self.assertEqual(len(bookmarks), 2)\n        self.assertEqual(bookmarks[0][\"line_number\"], 10)\n        self.assertEqual(bookmarks[1][\"line_number\"], 20)\n    \n    def test_update_bookmark_note(self):\n        \"\"\"Test updating a bookmark's note\"\"\"\n        self.mock_collection.update_one.return_value = Mock(modified_count=1)\n        \n        result = self.manager.update_bookmark_note(\n            user_id=123,\n            file_id=\"file123\",\n            line_number=42,\n            note=\"Updated note\"\n        )\n        \n        self.assertTrue(result[\"ok\"])\n        self.assertIn(\"עודכנה\", result[\"message\"])\n        \n        # Verify update was called with correct data\n        call_args = self.mock_collection.update_one.call_args\n        self.assertEqual(call_args[0][0][\"line_number\"], 42)\n        self.assertEqual(call_args[0][1][\"$set\"][\"note\"], \"Updated note\")\n    \n    def test_delete_bookmark(self):\n        \"\"\"Test deleting a specific bookmark\"\"\"\n        self.mock_collection.delete_one.return_value = Mock(deleted_count=1)\n        \n        result = self.manager.delete_bookmark(\n            user_id=123,\n            file_id=\"file123\",\n            line_number=42\n        )\n        \n        self.assertTrue(result[\"ok\"])\n        self.assertIn(\"נמחקה\", result[\"message\"])\n        \n        # Verify delete was called\n        self.mock_collection.delete_one.assert_called_once()\n    \n    def test_delete_file_bookmarks(self):\n        \"\"\"Test deleting all bookmarks for a file\"\"\"\n        self.mock_collection.delete_many.return_value = Mock(deleted_count=5)\n        \n        result = self.manager.delete_file_bookmarks(123, \"file123\")\n        \n        self.assertTrue(result[\"ok\"])\n        self.assertEqual(result[\"deleted\"], 5)\n        \n        # Verify delete_many was called\n        self.mock_collection.delete_many.assert_called_once()\n\n\nclass TestSyncFunctionality(unittest.TestCase):\n    \"\"\"Tests for sync checking functionality\"\"\"\n    \n    def setUp(self):\n        \"\"\"Setup test environment\"\"\"\n        self.mock_db = MagicMock()\n        self.mock_collection = MagicMock()\n        self.mock_db.file_bookmarks = self.mock_collection\n        self.mock_db.bookmark_events = MagicMock()\n        self.mock_db.files = MagicMock()\n        \n        self.manager = BookmarksManager(self.mock_db)\n    \n    def test_check_line_status_unchanged(self):\n        \"\"\"Test detecting unchanged lines\"\"\"\n        old_text = \"def test():\"\n        new_lines = [\"import os\", \"def test():\", \"    pass\"]\n        \n        from difflib import SequenceMatcher\n        matcher = SequenceMatcher(None, [], new_lines)\n        \n        status = self.manager._check_line_status(2, old_text, new_lines, matcher)\n        \n        self.assertFalse(status[\"needs_update\"])\n    \n    def test_check_line_status_modified(self):\n        \"\"\"Test detecting modified lines\"\"\"\n        old_text = \"def test():\"\n        new_lines = [\"import os\", \"def test_modified():\", \"    pass\"]\n        \n        from difflib import SequenceMatcher\n        matcher = SequenceMatcher(None, [], new_lines)\n        \n        status = self.manager._check_line_status(2, old_text, new_lines, matcher)\n        \n        self.assertTrue(status[\"needs_update\"])\n        self.assertEqual(status[\"status\"], \"modified\")\n        self.assertEqual(status[\"new_line\"], 2)\n    \n    def test_check_line_status_moved(self):\n        \"\"\"Test detecting moved lines\"\"\"\n        old_text = \"def specific_function():\"\n        new_lines = [\"import os\", \"import sys\", \"\", \"def specific_function():\", \"    pass\"]\n        \n        from difflib import SequenceMatcher\n        matcher = SequenceMatcher(None, [], new_lines)\n        \n        status = self.manager._check_line_status(1, old_text, new_lines, matcher)\n        \n        self.assertTrue(status[\"needs_update\"])\n        self.assertEqual(status[\"status\"], \"moved\")\n        self.assertEqual(status[\"new_line\"], 4)\n    \n    def test_check_line_status_deleted(self):\n        \"\"\"Test detecting deleted lines\"\"\"\n        old_text = \"def deleted_function():\"\n        new_lines = [\"import os\", \"def other_function():\", \"    pass\"]\n        \n        from difflib import SequenceMatcher\n        matcher = SequenceMatcher(None, [], new_lines)\n        \n        status = self.manager._check_line_status(2, old_text, new_lines, matcher)\n        \n        self.assertTrue(status[\"needs_update\"])\n        self.assertEqual(status[\"status\"], \"deleted\")\n        self.assertIsNone(status[\"new_line\"])\n\n\nclass TestIntegration(unittest.TestCase):\n    \"\"\"Integration tests\"\"\"\n    \n    @patch('database.bookmarks_manager.logger')\n    def test_error_handling(self, mock_logger):\n        \"\"\"Test that errors are properly logged\"\"\"\n        mock_db = MagicMock()\n        mock_collection = MagicMock()\n        mock_db.file_bookmarks = mock_collection\n        mock_db.bookmark_events = MagicMock()\n        mock_db.files = MagicMock()\n        \n        # Make insert_one raise an exception\n        mock_collection.find_one.return_value = None\n        mock_collection.count_documents.return_value = 0\n        mock_collection.insert_one.side_effect = Exception(\"DB Error\")\n        \n        manager = BookmarksManager(mock_db)\n        \n        result = manager.toggle_bookmark(\n            user_id=123,\n            file_id=\"file123\",\n            file_name=\"test.py\",\n            file_path=\"/test.py\",\n            line_number=42\n        )\n        \n        self.assertFalse(result[\"ok\"])\n        self.assertEqual(result[\"action\"], \"error\")\n        \n        # Check that error was logged\n        mock_logger.error.assert_called()\n\n\ndef run_tests():\n    \"\"\"Run all tests\"\"\"\n    loader = unittest.TestLoader()\n    suite = unittest.TestSuite()\n    \n    # Add all test classes\n    suite.addTests(loader.loadTestsFromTestCase(TestFileBookmarkModel))\n    suite.addTests(loader.loadTestsFromTestCase(TestBookmarksManager))\n    suite.addTests(loader.loadTestsFromTestCase(TestSyncFunctionality))\n    suite.addTests(loader.loadTestsFromTestCase(TestIntegration))\n    \n    runner = unittest.TextTestRunner(verbosity=2)\n    result = runner.run(suite)\n    \n    return result.wasSuccessful()\n\n\nif __name__ == \"__main__\":\n    success = run_tests()\n    sys.exit(0 if success else 1)",
      "encoding": "utf-8"
    }
  },
  "public": true,
  "created_at": "2025-10-09T14:08:51Z",
  "updated_at": "2025-10-09T14:08:51Z",
  "description": "test_bookmarks.py",
  "comments": 0,
  "user": null,
  "comments_enabled": true,
  "comments_url": "https://api.github.com/gists/d891ae93dfc9df54b3863538f3c49dc6/comments",
  "owner": {
    "login": "amirbiron",
    "id": 215461772,
    "node_id": "U_kgDODNevjA",
    "avatar_url": "https://avatars.githubusercontent.com/u/215461772?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amirbiron",
    "html_url": "https://github.com/amirbiron",
    "followers_url": "https://api.github.com/users/amirbiron/followers",
    "following_url": "https://api.github.com/users/amirbiron/following{/other_user}",
    "gists_url": "https://api.github.com/users/amirbiron/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amirbiron/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amirbiron/subscriptions",
    "organizations_url": "https://api.github.com/users/amirbiron/orgs",
    "repos_url": "https://api.github.com/users/amirbiron/repos",
    "events_url": "https://api.github.com/users/amirbiron/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amirbiron/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "forks": [

  ],
  "history": [
    {
      "user": {
        "login": "amirbiron",
        "id": 215461772,
        "node_id": "U_kgDODNevjA",
        "avatar_url": "https://avatars.githubusercontent.com/u/215461772?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amirbiron",
        "html_url": "https://github.com/amirbiron",
        "followers_url": "https://api.github.com/users/amirbiron/followers",
        "following_url": "https://api.github.com/users/amirbiron/following{/other_user}",
        "gists_url": "https://api.github.com/users/amirbiron/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/amirbiron/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/amirbiron/subscriptions",
        "organizations_url": "https://api.github.com/users/amirbiron/orgs",
        "repos_url": "https://api.github.com/users/amirbiron/repos",
        "events_url": "https://api.github.com/users/amirbiron/events{/privacy}",
        "received_events_url": "https://api.github.com/users/amirbiron/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "version": "60a9b8d14bb9e118c639e9e169be397cbaaa3449",
      "committed_at": "2025-10-09T14:08:51Z",
      "change_status": {
        "total": 413,
        "additions": 413,
        "deletions": 0
      },
      "url": "https://api.github.com/gists/d891ae93dfc9df54b3863538f3c49dc6/60a9b8d14bb9e118c639e9e169be397cbaaa3449"
    }
  ],
  "truncated": false
}
