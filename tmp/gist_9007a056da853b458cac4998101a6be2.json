{
  "url": "https://api.github.com/gists/9007a056da853b458cac4998101a6be2",
  "forks_url": "https://api.github.com/gists/9007a056da853b458cac4998101a6be2/forks",
  "commits_url": "https://api.github.com/gists/9007a056da853b458cac4998101a6be2/commits",
  "id": "9007a056da853b458cac4998101a6be2",
  "node_id": "G_kwDODNevjNoAIDkwMDdhMDU2ZGE4NTNiNDU4Y2FjNDk5ODEwMWE2YmUy",
  "git_pull_url": "https://gist.github.com/9007a056da853b458cac4998101a6be2.git",
  "git_push_url": "https://gist.github.com/9007a056da853b458cac4998101a6be2.git",
  "html_url": "https://gist.github.com/amirbiron/9007a056da853b458cac4998101a6be2",
  "files": {
    "2.py": {
      "filename": "2.py",
      "type": "application/x-python",
      "language": "Python",
      "raw_url": "https://gist.githubusercontent.com/amirbiron/9007a056da853b458cac4998101a6be2/raw/50bf0543b708d319b0f4a8da9f42cceae1912b47/2.py",
      "size": 24126,
      "truncated": false,
      "content": "\"\"\"\nBookmarks Manager - מנהל סימניות לקבצי קוד\n\"\"\"\nimport hashlib\nimport logging\nfrom datetime import datetime, timezone, timedelta\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom difflib import SequenceMatcher\nfrom bson import ObjectId\nfrom pymongo import ASCENDING, DESCENDING, IndexModel\nfrom pymongo.errors import DuplicateKeyError, BulkWriteError\n\nfrom database.models.bookmark import (\n    FileBookmark, \n    MAX_BOOKMARKS_PER_FILE, \n    MAX_BOOKMARKS_PER_USER,\n    MAX_NOTE_LENGTH\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass BookmarksManager:\n    \"\"\"מנהל סימניות בקבצים\"\"\"\n    \n    def __init__(self, db):\n        \"\"\"\n        Initialize bookmarks manager\n        \n        Args:\n            db: MongoDB database instance\n        \"\"\"\n        self.db = db\n        self.collection = db.file_bookmarks\n        self.events_collection = db.bookmark_events\n        self.files_collection = db.files\n        \n        # יצירת indexes\n        self._ensure_indexes()\n    \n    def _ensure_indexes(self):\n        \"\"\"יצירת אינדקסים לביצועים מיטביים\"\"\"\n        try:\n            indexes = [\n                # אינדקס ייחודי למניעת כפילויות\n                IndexModel(\n                    [(\"user_id\", ASCENDING), (\"file_id\", ASCENDING), (\"line_number\", ASCENDING)],\n                    unique=True,\n                    name=\"unique_user_file_line\"\n                ),\n                # אינדקס לחיפוש מהיר לפי משתמש וקובץ\n                IndexModel(\n                    [(\"user_id\", ASCENDING), (\"file_id\", ASCENDING)],\n                    name=\"user_file_lookup\"\n                ),\n                # אינדקס לחיפוש לפי משתמש בלבד\n                IndexModel(\n                    [(\"user_id\", ASCENDING), (\"created_at\", DESCENDING)],\n                    name=\"user_recent_bookmarks\"\n                ),\n                # אינדקס לחיפוש טקסט בהערות\n                IndexModel(\n                    [(\"note\", \"text\")],\n                    name=\"note_text_search\"\n                ),\n                # TTL index למחיקה אוטומטית של סימניות ישנות (אופציונלי - שנה)\n                # IndexModel(\n                #     \"created_at\",\n                #     expireAfterSeconds=31536000,  # שנה בשניות\n                #     name=\"ttl_old_bookmarks\"\n                # )\n            ]\n            \n            self.collection.create_indexes(indexes)\n            logger.info(\"Bookmarks indexes created successfully\")\n            \n        except Exception as e:\n            logger.warning(f\"Failed to create some bookmarks indexes: {e}\")\n    \n    # ==================== CRUD Operations ====================\n    \n    def toggle_bookmark(self, \n                       user_id: int,\n                       file_id: str,\n                       file_name: str,\n                       file_path: str,\n                       line_number: int,\n                       line_text: str = \"\",\n                       note: str = \"\",\n                       color: str = \"yellow\") -> Dict[str, Any]:\n        \"\"\"\n        הוספה/הסרה של סימנייה (toggle)\n        \n        Returns:\n            dict: {\n                \"ok\": bool,\n                \"action\": \"added\" | \"removed\" | \"error\",\n                \"bookmark\": dict | None,\n                \"error\": str | None\n            }\n        \"\"\"\n        try:\n            # ולידציה\n            if line_number <= 0:\n                return {\"ok\": False, \"action\": \"error\", \"error\": \"מספר שורה לא תקין\"}\n            \n            if len(note) > MAX_NOTE_LENGTH:\n                note = note[:MAX_NOTE_LENGTH]\n            \n            # בדיקה אם הסימנייה קיימת\n            existing = self.collection.find_one({\n                \"user_id\": user_id,\n                \"file_id\": file_id,\n                \"line_number\": line_number\n            })\n            \n            if existing:\n                # הסרת סימנייה קיימת\n                self.collection.delete_one({\"_id\": existing[\"_id\"]})\n                self._track_event(user_id, \"removed\", file_id, line_number)\n                \n                return {\n                    \"ok\": True,\n                    \"action\": \"removed\",\n                    \"bookmark\": None\n                }\n            \n            # בדיקת הגבלות לפני הוספה\n            limits_check = self._check_limits(user_id, file_id)\n            if not limits_check[\"ok\"]:\n                return {\n                    \"ok\": False,\n                    \"action\": \"error\",\n                    \"error\": limits_check[\"error\"]\n                }\n            \n            # חישוב hash של הקובץ\n            file_hash = self._calculate_file_hash(file_id)\n            \n            # יצירת סימנייה חדשה\n            bookmark = FileBookmark(\n                user_id=user_id,\n                file_id=file_id,\n                file_name=file_name,\n                file_path=file_path,\n                line_number=line_number,\n                line_text_preview=line_text[:100] if line_text else \"\",\n                note=note,\n                color=color,\n                file_hash=file_hash\n            )\n            \n            # שמירה ב-DB\n            result = self.collection.insert_one(bookmark.to_dict())\n            bookmark._id = result.inserted_id\n            \n            # מעקב אירועים\n            self._track_event(user_id, \"added\", file_id, line_number, {\"note_length\": len(note)})\n            \n            return {\n                \"ok\": True,\n                \"action\": \"added\",\n                \"bookmark\": self._bookmark_to_response(bookmark)\n            }\n            \n        except DuplicateKeyError:\n            # במקרה של race condition\n            return {\n                \"ok\": False,\n                \"action\": \"error\",\n                \"error\": \"הסימנייה כבר קיימת\"\n            }\n        except Exception as e:\n            logger.error(f\"Error toggling bookmark: {e}\", exc_info=True)\n            return {\n                \"ok\": False,\n                \"action\": \"error\",\n                \"error\": \"שגיאה בשמירת הסימנייה\"\n            }\n    \n    def get_file_bookmarks(self, \n                          user_id: int, \n                          file_id: str,\n                          include_invalid: bool = False) -> List[Dict[str, Any]]:\n        \"\"\"\n        קבלת כל הסימניות של קובץ מסוים\n        \n        Args:\n            user_id: מזהה המשתמש\n            file_id: מזהה הקובץ\n            include_invalid: האם לכלול סימניות לא תקפות\n            \n        Returns:\n            רשימת סימניות ממוינות לפי מספר שורה\n        \"\"\"\n        try:\n            query = {\n                \"user_id\": user_id,\n                \"file_id\": file_id\n            }\n            \n            if not include_invalid:\n                query[\"valid\"] = {\"$ne\": False}\n            \n            bookmarks = list(self.collection.find(query).sort(\"line_number\", 1))\n            \n            # עדכון last_accessed\n            if bookmarks:\n                bookmark_ids = [b[\"_id\"] for b in bookmarks]\n                self.collection.update_many(\n                    {\"_id\": {\"$in\": bookmark_ids}},\n                    {\"$set\": {\"last_accessed\": datetime.now(timezone.utc)}}\n                )\n            \n            return [self._bookmark_to_response(FileBookmark.from_dict(b)) for b in bookmarks]\n            \n        except Exception as e:\n            logger.error(f\"Error getting file bookmarks: {e}\")\n            return []\n    \n    def get_user_bookmarks(self,\n                          user_id: int,\n                          limit: int = 100,\n                          skip: int = 0) -> Dict[str, Any]:\n        \"\"\"\n        קבלת כל הסימניות של משתמש\n        \n        Returns:\n            dict עם סימניות מקובצות לפי קבצים\n        \"\"\"\n        try:\n            # אגרגציה לקיבוץ לפי קבצים\n            pipeline = [\n                {\"$match\": {\"user_id\": user_id, \"valid\": {\"$ne\": False}}},\n                {\"$sort\": {\"created_at\": -1}},\n                {\"$skip\": skip},\n                {\"$limit\": limit},\n                {\"$group\": {\n                    \"_id\": {\n                        \"file_id\": \"$file_id\",\n                        \"file_name\": \"$file_name\",\n                        \"file_path\": \"$file_path\"\n                    },\n                    \"bookmarks\": {\"$push\": {\n                        \"line_number\": \"$line_number\",\n                        \"note\": \"$note\",\n                        \"color\": \"$color\",\n                        \"created_at\": \"$created_at\"\n                    }},\n                    \"count\": {\"$sum\": 1}\n                }},\n                {\"$sort\": {\"count\": -1}}\n            ]\n            \n            result = list(self.collection.aggregate(pipeline))\n            \n            # עיבוד התוצאות\n            files = []\n            for item in result:\n                files.append({\n                    \"file_id\": item[\"_id\"][\"file_id\"],\n                    \"file_name\": item[\"_id\"][\"file_name\"],\n                    \"file_path\": item[\"_id\"][\"file_path\"],\n                    \"bookmarks\": sorted(item[\"bookmarks\"], key=lambda x: x[\"line_number\"]),\n                    \"count\": item[\"count\"]\n                })\n            \n            # סטטיסטיקות כלליות\n            total_count = self.collection.count_documents({\"user_id\": user_id})\n            \n            return {\n                \"ok\": True,\n                \"files\": files,\n                \"total_bookmarks\": total_count,\n                \"files_count\": len(files)\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting user bookmarks: {e}\")\n            return {\n                \"ok\": False,\n                \"error\": str(e),\n                \"files\": []\n            }\n    \n    def update_bookmark_note(self,\n                            user_id: int,\n                            file_id: str,\n                            line_number: int,\n                            note: str) -> Dict[str, Any]:\n        \"\"\"עדכון הערה של סימנייה\"\"\"\n        try:\n            if len(note) > MAX_NOTE_LENGTH:\n                note = note[:MAX_NOTE_LENGTH]\n            \n            result = self.collection.update_one(\n                {\n                    \"user_id\": user_id,\n                    \"file_id\": file_id,\n                    \"line_number\": line_number\n                },\n                {\n                    \"$set\": {\n                        \"note\": note,\n                        \"updated_at\": datetime.now(timezone.utc)\n                    }\n                }\n            )\n            \n            if result.modified_count > 0:\n                self._track_event(user_id, \"note_updated\", file_id, line_number)\n                return {\"ok\": True, \"message\": \"ההערה עודכנה\"}\n            else:\n                return {\"ok\": False, \"error\": \"הסימנייה לא נמצאה\"}\n                \n        except Exception as e:\n            logger.error(f\"Error updating bookmark note: {e}\")\n            return {\"ok\": False, \"error\": \"שגיאה בעדכון ההערה\"}\n    \n    def delete_bookmark(self,\n                       user_id: int,\n                       file_id: str,\n                       line_number: int) -> Dict[str, Any]:\n        \"\"\"מחיקת סימנייה ספציפית\"\"\"\n        try:\n            result = self.collection.delete_one({\n                \"user_id\": user_id,\n                \"file_id\": file_id,\n                \"line_number\": line_number\n            })\n            \n            if result.deleted_count > 0:\n                self._track_event(user_id, \"deleted\", file_id, line_number)\n                return {\"ok\": True, \"message\": \"הסימנייה נמחקה\"}\n            else:\n                return {\"ok\": False, \"error\": \"הסימנייה לא נמצאה\"}\n                \n        except Exception as e:\n            logger.error(f\"Error deleting bookmark: {e}\")\n            return {\"ok\": False, \"error\": \"שגיאה במחיקת הסימנייה\"}\n    \n    def delete_file_bookmarks(self, user_id: int, file_id: str) -> Dict[str, Any]:\n        \"\"\"מחיקת כל הסימניות של קובץ\"\"\"\n        try:\n            result = self.collection.delete_many({\n                \"user_id\": user_id,\n                \"file_id\": file_id\n            })\n            \n            if result.deleted_count > 0:\n                self._track_event(user_id, \"file_cleared\", file_id, metadata={\"count\": result.deleted_count})\n                return {\"ok\": True, \"deleted\": result.deleted_count}\n            else:\n                return {\"ok\": True, \"deleted\": 0}\n                \n        except Exception as e:\n            logger.error(f\"Error deleting file bookmarks: {e}\")\n            return {\"ok\": False, \"error\": \"שגיאה במחיקת הסימניות\"}\n    \n    # ==================== Sync Operations ====================\n    \n    def check_file_sync(self, \n                       file_id: str,\n                       new_content: str) -> Dict[str, Any]:\n        \"\"\"\n        בדיקת סנכרון סימניות עם שינויים בקובץ\n        \n        Returns:\n            מידע על סימניות שהושפעו משינויים\n        \"\"\"\n        try:\n            # חישוב hash חדש\n            new_hash = hashlib.sha256(new_content.encode()).hexdigest()\n            \n            # קבלת hash קודם\n            file_doc = self.files_collection.find_one({\"_id\": ObjectId(file_id)})\n            old_hash = file_doc.get(\"content_hash\") if file_doc else None\n            \n            if old_hash == new_hash:\n                return {\"changed\": False, \"affected\": []}\n            \n            # ניתוח השפעה על סימניות\n            old_lines = file_doc.get(\"content\", \"\").splitlines() if file_doc else []\n            new_lines = new_content.splitlines()\n            \n            affected = self._analyze_bookmark_changes(file_id, old_lines, new_lines)\n            \n            # עדכון hash בקובץ\n            self.files_collection.update_one(\n                {\"_id\": ObjectId(file_id)},\n                {\"$set\": {\n                    \"content_hash\": new_hash,\n                    \"content\": new_content,\n                    \"last_sync\": datetime.now(timezone.utc)\n                }}\n            )\n            \n            return {\n                \"changed\": True,\n                \"old_hash\": old_hash,\n                \"new_hash\": new_hash,\n                \"affected\": affected\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error checking file sync: {e}\")\n            return {\"changed\": False, \"error\": str(e)}\n    \n    def _analyze_bookmark_changes(self,\n                                 file_id: str,\n                                 old_lines: List[str],\n                                 new_lines: List[str]) -> List[Dict[str, Any]]:\n        \"\"\"ניתוח השפעת שינויים על סימניות\"\"\"\n        \n        matcher = SequenceMatcher(None, old_lines, new_lines)\n        bookmarks = list(self.collection.find({\"file_id\": file_id}))\n        affected = []\n        \n        for bookmark in bookmarks:\n            line_num = bookmark[\"line_number\"]\n            old_text = bookmark.get(\"line_text_preview\", \"\")\n            \n            # בדיקת סטטוס השורה\n            status = self._check_line_status(line_num, old_text, new_lines, matcher)\n            \n            if status[\"needs_update\"]:\n                affected.append({\n                    \"bookmark_id\": str(bookmark[\"_id\"]),\n                    \"user_id\": bookmark[\"user_id\"],\n                    \"old_line\": line_num,\n                    \"new_line\": status.get(\"new_line\"),\n                    \"status\": status[\"status\"],\n                    \"confidence\": status.get(\"confidence\", 0)\n                })\n                \n                # עדכון הסימנייה ב-DB\n                self._update_bookmark_sync_status(\n                    bookmark[\"_id\"],\n                    status\n                )\n        \n        return affected\n    \n    def _check_line_status(self,\n                          line_num: int,\n                          old_text: str,\n                          new_lines: List[str],\n                          matcher: SequenceMatcher) -> Dict[str, Any]:\n        \"\"\"בדיקת סטטוס של שורה ספציפית\"\"\"\n        \n        # בדיקה אם השורה עדיין קיימת באותו מקום\n        if 0 < line_num <= len(new_lines):\n            new_text = new_lines[line_num - 1]\n            \n            # השורה לא השתנתה\n            if old_text in new_text or new_text in old_text:\n                return {\"needs_update\": False}\n            \n            # השורה השתנתה מעט\n            similarity = SequenceMatcher(None, old_text, new_text).ratio()\n            if similarity > 0.7:  # 70% דמיון\n                return {\n                    \"needs_update\": True,\n                    \"status\": \"modified\",\n                    \"new_line\": line_num,\n                    \"confidence\": similarity\n                }\n        \n        # חיפוש השורה במקום אחר\n        best_match = None\n        best_similarity = 0.7  # סף מינימלי\n        \n        for i, new_line in enumerate(new_lines, 1):\n            similarity = SequenceMatcher(None, old_text, new_line).ratio()\n            if similarity > best_similarity:\n                best_similarity = similarity\n                best_match = i\n        \n        if best_match:\n            return {\n                \"needs_update\": True,\n                \"status\": \"moved\",\n                \"new_line\": best_match,\n                \"confidence\": best_similarity\n            }\n        \n        # השורה נמחקה\n        return {\n            \"needs_update\": True,\n            \"status\": \"deleted\",\n            \"new_line\": None,\n            \"confidence\": 0\n        }\n    \n    def _update_bookmark_sync_status(self,\n                                    bookmark_id: ObjectId,\n                                    status: Dict[str, Any]):\n        \"\"\"עדכון סטטוס סנכרון של סימנייה\"\"\"\n        \n        update_data = {\n            \"sync_status\": status[\"status\"],\n            \"sync_confidence\": status.get(\"confidence\", 0),\n            \"updated_at\": datetime.now(timezone.utc)\n        }\n        \n        if status[\"status\"] == \"deleted\":\n            update_data[\"valid\"] = False\n        elif status[\"status\"] in [\"moved\", \"modified\"]:\n            if status.get(\"new_line\"):\n                update_data[\"line_number\"] = status[\"new_line\"]\n        \n        self.collection.update_one(\n            {\"_id\": bookmark_id},\n            {\"$set\": update_data}\n        )\n    \n    # ==================== Helper Methods ====================\n    \n    def _check_limits(self, user_id: int, file_id: str) -> Dict[str, Any]:\n        \"\"\"בדיקת הגבלות לפני הוספת סימנייה\"\"\"\n        \n        # בדיקת מגבלה לקובץ\n        file_count = self.collection.count_documents({\n            \"user_id\": user_id,\n            \"file_id\": file_id\n        })\n        \n        if file_count >= MAX_BOOKMARKS_PER_FILE:\n            return {\n                \"ok\": False,\n                \"error\": f\"הגעת למגבלה של {MAX_BOOKMARKS_PER_FILE} סימניות לקובץ\"\n            }\n        \n        # בדיקת מגבלה כללית\n        total_count = self.collection.count_documents({\"user_id\": user_id})\n        \n        if total_count >= MAX_BOOKMARKS_PER_USER:\n            return {\n                \"ok\": False,\n                \"error\": f\"הגעת למגבלה של {MAX_BOOKMARKS_PER_USER} סימניות סך הכל\"\n            }\n        \n        return {\"ok\": True}\n    \n    def _calculate_file_hash(self, file_id: str) -> str:\n        \"\"\"חישוב hash של תוכן הקובץ\"\"\"\n        try:\n            file_doc = self.files_collection.find_one({\"_id\": ObjectId(file_id)})\n            if file_doc and \"content\" in file_doc:\n                return hashlib.sha256(file_doc[\"content\"].encode()).hexdigest()\n        except Exception as e:\n            logger.warning(f\"Failed to calculate file hash: {e}\")\n        \n        return \"\"\n    \n    def _track_event(self,\n                    user_id: int,\n                    event_type: str,\n                    file_id: str = None,\n                    line_number: int = None,\n                    metadata: Dict[str, Any] = None):\n        \"\"\"רישום אירוע למעקב\"\"\"\n        try:\n            event = {\n                \"user_id\": user_id,\n                \"event_type\": event_type,\n                \"file_id\": file_id,\n                \"line_number\": line_number,\n                \"metadata\": metadata or {},\n                \"timestamp\": datetime.now(timezone.utc)\n            }\n            \n            self.events_collection.insert_one(event)\n            \n        except Exception as e:\n            logger.debug(f\"Failed to track event: {e}\")\n    \n    def _bookmark_to_response(self, bookmark: FileBookmark) -> Dict[str, Any]:\n        \"\"\"המרת סימנייה לפורמט תגובה\"\"\"\n        return {\n            \"id\": str(bookmark._id) if bookmark._id else None,\n            \"line_number\": bookmark.line_number,\n            \"line_text_preview\": bookmark.line_text_preview,\n            \"note\": bookmark.note,\n            \"color\": bookmark.color,\n            \"valid\": bookmark.valid,\n            \"sync_status\": bookmark.sync_status,\n            \"created_at\": bookmark.created_at.isoformat() if bookmark.created_at else None,\n            \"updated_at\": bookmark.updated_at.isoformat() if bookmark.updated_at else None\n        }\n    \n    # ==================== Analytics Methods ====================\n    \n    def get_user_stats(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"קבלת סטטיסטיקות משתמש\"\"\"\n        try:\n            total_bookmarks = self.collection.count_documents({\"user_id\": user_id})\n            \n            # הקבצים עם הכי הרבה סימניות\n            pipeline = [\n                {\"$match\": {\"user_id\": user_id}},\n                {\"$group\": {\n                    \"_id\": \"$file_name\",\n                    \"count\": {\"$sum\": 1}\n                }},\n                {\"$sort\": {\"count\": -1}},\n                {\"$limit\": 5}\n            ]\n            \n            top_files = list(self.collection.aggregate(pipeline))\n            \n            # סימניות שנוצרו השבוע\n            week_ago = datetime.now(timezone.utc) - timedelta(days=7)\n            recent_count = self.collection.count_documents({\n                \"user_id\": user_id,\n                \"created_at\": {\"$gte\": week_ago}\n            })\n            \n            return {\n                \"total_bookmarks\": total_bookmarks,\n                \"recent_bookmarks\": recent_count,\n                \"top_files\": top_files,\n                \"max_allowed\": MAX_BOOKMARKS_PER_USER\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting user stats: {e}\")\n            return {}\n    \n    def cleanup_invalid_bookmarks(self, days_old: int = 30) -> int:\n        \"\"\"ניקוי סימניות לא תקפות ישנות\"\"\"\n        try:\n            cutoff_date = datetime.now(timezone.utc) - timedelta(days=days_old)\n            \n            result = self.collection.delete_many({\n                \"valid\": False,\n                \"updated_at\": {\"$lt\": cutoff_date}\n            })\n            \n            logger.info(f\"Cleaned up {result.deleted_count} invalid bookmarks\")\n            return result.deleted_count\n            \n        except Exception as e:\n            logger.error(f\"Error cleaning up bookmarks: {e}\")\n            return 0",
      "encoding": "utf-8"
    }
  },
  "public": true,
  "created_at": "2025-10-09T13:39:11Z",
  "updated_at": "2025-10-09T13:39:11Z",
  "description": "database/bookmarks_manager.py",
  "comments": 0,
  "user": null,
  "comments_enabled": true,
  "comments_url": "https://api.github.com/gists/9007a056da853b458cac4998101a6be2/comments",
  "owner": {
    "login": "amirbiron",
    "id": 215461772,
    "node_id": "U_kgDODNevjA",
    "avatar_url": "https://avatars.githubusercontent.com/u/215461772?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amirbiron",
    "html_url": "https://github.com/amirbiron",
    "followers_url": "https://api.github.com/users/amirbiron/followers",
    "following_url": "https://api.github.com/users/amirbiron/following{/other_user}",
    "gists_url": "https://api.github.com/users/amirbiron/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amirbiron/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amirbiron/subscriptions",
    "organizations_url": "https://api.github.com/users/amirbiron/orgs",
    "repos_url": "https://api.github.com/users/amirbiron/repos",
    "events_url": "https://api.github.com/users/amirbiron/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amirbiron/received_events",
    "type": "User",
    "user_view_type": "public",
    "site_admin": false
  },
  "forks": [

  ],
  "history": [
    {
      "user": {
        "login": "amirbiron",
        "id": 215461772,
        "node_id": "U_kgDODNevjA",
        "avatar_url": "https://avatars.githubusercontent.com/u/215461772?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amirbiron",
        "html_url": "https://github.com/amirbiron",
        "followers_url": "https://api.github.com/users/amirbiron/followers",
        "following_url": "https://api.github.com/users/amirbiron/following{/other_user}",
        "gists_url": "https://api.github.com/users/amirbiron/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/amirbiron/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/amirbiron/subscriptions",
        "organizations_url": "https://api.github.com/users/amirbiron/orgs",
        "repos_url": "https://api.github.com/users/amirbiron/repos",
        "events_url": "https://api.github.com/users/amirbiron/events{/privacy}",
        "received_events_url": "https://api.github.com/users/amirbiron/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "version": "3c1c24eea29728d9ccba849b84536f890045d21a",
      "committed_at": "2025-10-09T13:39:11Z",
      "change_status": {
        "total": 645,
        "additions": 645,
        "deletions": 0
      },
      "url": "https://api.github.com/gists/9007a056da853b458cac4998101a6be2/3c1c24eea29728d9ccba849b84536f890045d21a"
    }
  ],
  "truncated": false
}
